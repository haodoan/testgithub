###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             24/Jan/2015  12:32:30 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_St #
#                    dPeriph_Driver\src\stm8s_spi.c                           #
#    Command line =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_St #
#                    dPeriph_Driver\src\stm8s_spi.c -e -Ol --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_cross_call --debug --code_model medium              #
#                    --data_model medium -o D:\Project\STM8S_StdPeriph_Lib_V2 #
#                    .1.0\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S208\Ob #
#                    j\ --dlib_config "C:\Program Files\IAR Systems\Embedded  #
#                    Workbench 6.0\stm8\LIB\dlstm8mmn.h" -D                   #
#                    USE_STM8_128_EVAL -D STM8S003 -lC                        #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\ -lb                 #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\ -I                  #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\ -I                             #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\..\..\Libraries\STM8S_StdPeriph #
#                    _Driver\inc\ -I D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Pr #
#                    oject\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Utilities #
#                    \STM8S_EVAL\ -I D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Pr #
#                    oject\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Utilities #
#                    \STM8S_EVAL\STM8S-128_EVAL\ -I                           #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\..\..\Utilities\STM8S_EVAL\Comm #
#                    on\ --vregs 16                                           #
#    List file    =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\stm8s_spi.lst        #
#    Object file  =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\Obj\stm8s_spi.o           #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_StdPeriph_Driver\src\stm8s_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_spi.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the SPI peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_spi.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28            
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          
     35          /** @addtogroup SPI_Public_Functions
     36            * @{
     37            */
     38          
     39          /**
     40            * @brief  Deinitializes the SPI peripheral registers to their default reset values.
     41            * @param  None
     42            * @retval None
     43            */

   \                                 In section .far_func.text, align 1
     44          void SPI_DeInit(void)
     45          {
     46              SPI->CR1    = SPI_CR1_RESET_VALUE;
   \                     SPI_DeInit:
   \   000000 35005200              MOV       L:0x5200, #0x0
     47              SPI->CR2    = SPI_CR2_RESET_VALUE;
   \   000004 35005201              MOV       L:0x5201, #0x0
     48              SPI->ICR    = SPI_ICR_RESET_VALUE;
   \   000008 35005202              MOV       L:0x5202, #0x0
     49              SPI->SR     = SPI_SR_RESET_VALUE;
   \   00000C 35025203              MOV       L:0x5203, #0x2
     50              SPI->CRCPR  = SPI_CRCPR_RESET_VALUE;
   \   000010 35075205              MOV       L:0x5205, #0x7
     51          }
   \   000014 87                    RETF
     52          
     53          /**
     54            * @brief  Initializes the SPI according to the specified parameters.
     55            * @param  FirstBit : This parameter can be any of the 
     56            *         @ref SPI_FirstBit_TypeDef enumeration.
     57            * @param  BaudRatePrescaler : This parameter can be any of the 
     58            *         @ref SPI_BaudRatePrescaler_TypeDef enumeration.
     59            * @param  Mode : This parameter can be any of the  
     60            *         @ref SPI_Mode_TypeDef enumeration.
     61            * @param  ClockPolarity : This parameter can be any of the 
     62            *         @ref SPI_ClockPolarity_TypeDef enumeration.
     63            * @param  ClockPhase : This parameter can be any of the 
     64            *         @ref SPI_ClockPhase_TypeDef enumeration.
     65            * @param  Data_Direction : This parameter can be any of the 
     66            *         @ref SPI_DataDirection_TypeDef enumeration.
     67            * @param  Slave_Management : This parameter can be any of the 
     68            *         @ref SPI_NSS_TypeDef enumeration.
     69            * @param  CRCPolynomial : Configures the CRC polynomial.
     70            * @retval None
     71            */

   \                                 In section .far_func.text, align 1
     72          void SPI_Init(SPI_FirstBit_TypeDef FirstBit, SPI_BaudRatePrescaler_TypeDef BaudRatePrescaler, SPI_Mode_TypeDef Mode, SPI_ClockPolarity_TypeDef ClockPolarity, SPI_ClockPhase_TypeDef ClockPhase, SPI_DataDirection_TypeDef Data_Direction, SPI_NSS_TypeDef Slave_Management, uint8_t CRCPolynomial)
     73          {
   \                     SPI_Init:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l3
   \   000008 B700                  LD        S:?b15, A
   \   00000A 450000                MOV       S:?b8, S:?b0
   \   00000D 450000                MOV       S:?b9, S:?b1
   \   000010 450000                MOV       S:?b14, S:?b2
   \   000013 450000                MOV       S:?b13, S:?b3
   \   000016 450000                MOV       S:?b10, S:?b4
   \   000019 450000                MOV       S:?b12, S:?b5
   \   00001C 450000                MOV       S:?b11, S:?b6
     74              /* Check structure elements */
     75              assert_param(IS_SPI_FIRSTBIT_OK(FirstBit));
   \   00001F 3D00                  TNZ       S:?b15
   \   000021 2715                  JREQ      L:??SPI_Init_0
   \   000023 B600                  LD        A, S:?b15
   \   000025 A180                  CP        A, #0x80
   \   000027 270F                  JREQ      L:??SPI_Init_0
   \   000029 AE004B                LDW       X, #0x4b
   \   00002C BF00                  LDW       S:?w1, X
   \   00002E 5F                    CLRW      X
   \   00002F BF00                  LDW       S:?w0, X
   \   000031 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000034 8D000000              CALLF     assert_failed
     76              assert_param(IS_SPI_BAUDRATE_PRESCALER_OK(BaudRatePrescaler));
   \                     ??SPI_Init_0:
   \   000038 3D00                  TNZ       S:?b8
   \   00003A 2739                  JREQ      L:??SPI_Init_1
   \   00003C B600                  LD        A, S:?b8
   \   00003E A108                  CP        A, #0x8
   \   000040 2733                  JREQ      L:??SPI_Init_1
   \   000042 B600                  LD        A, S:?b8
   \   000044 A110                  CP        A, #0x10
   \   000046 272D                  JREQ      L:??SPI_Init_1
   \   000048 B600                  LD        A, S:?b8
   \   00004A A118                  CP        A, #0x18
   \   00004C 2727                  JREQ      L:??SPI_Init_1
   \   00004E B600                  LD        A, S:?b8
   \   000050 A120                  CP        A, #0x20
   \   000052 2721                  JREQ      L:??SPI_Init_1
   \   000054 B600                  LD        A, S:?b8
   \   000056 A128                  CP        A, #0x28
   \   000058 271B                  JREQ      L:??SPI_Init_1
   \   00005A B600                  LD        A, S:?b8
   \   00005C A130                  CP        A, #0x30
   \   00005E 2715                  JREQ      L:??SPI_Init_1
   \   000060 B600                  LD        A, S:?b8
   \   000062 A138                  CP        A, #0x38
   \   000064 270F                  JREQ      L:??SPI_Init_1
   \   000066 AE004C                LDW       X, #0x4c
   \   000069 BF00                  LDW       S:?w1, X
   \   00006B 5F                    CLRW      X
   \   00006C BF00                  LDW       S:?w0, X
   \   00006E AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000071 8D000000              CALLF     assert_failed
     77              assert_param(IS_SPI_MODE_OK(Mode));
   \                     ??SPI_Init_1:
   \   000075 B600                  LD        A, S:?b9
   \   000077 A104                  CP        A, #0x4
   \   000079 2713                  JREQ      L:??SPI_Init_2
   \   00007B 3D00                  TNZ       S:?b9
   \   00007D 270F                  JREQ      L:??SPI_Init_2
   \   00007F AE004D                LDW       X, #0x4d
   \   000082 BF00                  LDW       S:?w1, X
   \   000084 5F                    CLRW      X
   \   000085 BF00                  LDW       S:?w0, X
   \   000087 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00008A 8D000000              CALLF     assert_failed
     78              assert_param(IS_SPI_POLARITY_OK(ClockPolarity));
   \                     ??SPI_Init_2:
   \   00008E 3D00                  TNZ       S:?b14
   \   000090 2715                  JREQ      L:??SPI_Init_3
   \   000092 B600                  LD        A, S:?b14
   \   000094 A102                  CP        A, #0x2
   \   000096 270F                  JREQ      L:??SPI_Init_3
   \   000098 AE004E                LDW       X, #0x4e
   \   00009B BF00                  LDW       S:?w1, X
   \   00009D 5F                    CLRW      X
   \   00009E BF00                  LDW       S:?w0, X
   \   0000A0 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   0000A3 8D000000              CALLF     assert_failed
     79              assert_param(IS_SPI_PHASE_OK(ClockPhase));
   \                     ??SPI_Init_3:
   \   0000A7 3D00                  TNZ       S:?b13
   \   0000A9 2715                  JREQ      L:??SPI_Init_4
   \   0000AB B600                  LD        A, S:?b13
   \   0000AD A101                  CP        A, #0x1
   \   0000AF 270F                  JREQ      L:??SPI_Init_4
   \   0000B1 AE004F                LDW       X, #0x4f
   \   0000B4 BF00                  LDW       S:?w1, X
   \   0000B6 5F                    CLRW      X
   \   0000B7 BF00                  LDW       S:?w0, X
   \   0000B9 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   0000BC 8D000000              CALLF     assert_failed
     80              assert_param(IS_SPI_DATA_DIRECTION_OK(Data_Direction));
   \                     ??SPI_Init_4:
   \   0000C0 3D00                  TNZ       S:?b10
   \   0000C2 2721                  JREQ      L:??SPI_Init_5
   \   0000C4 B600                  LD        A, S:?b10
   \   0000C6 A104                  CP        A, #0x4
   \   0000C8 271B                  JREQ      L:??SPI_Init_5
   \   0000CA B600                  LD        A, S:?b10
   \   0000CC A180                  CP        A, #0x80
   \   0000CE 2715                  JREQ      L:??SPI_Init_5
   \   0000D0 B600                  LD        A, S:?b10
   \   0000D2 A1C0                  CP        A, #0xc0
   \   0000D4 270F                  JREQ      L:??SPI_Init_5
   \   0000D6 AE0050                LDW       X, #0x50
   \   0000D9 BF00                  LDW       S:?w1, X
   \   0000DB 5F                    CLRW      X
   \   0000DC BF00                  LDW       S:?w0, X
   \   0000DE AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   0000E1 8D000000              CALLF     assert_failed
     81              assert_param(IS_SPI_SLAVEMANAGEMENT_OK(Slave_Management));
   \                     ??SPI_Init_5:
   \   0000E5 B600                  LD        A, S:?b12
   \   0000E7 A102                  CP        A, #0x2
   \   0000E9 2713                  JREQ      L:??SPI_Init_6
   \   0000EB 3D00                  TNZ       S:?b12
   \   0000ED 270F                  JREQ      L:??SPI_Init_6
   \   0000EF AE0051                LDW       X, #0x51
   \   0000F2 BF00                  LDW       S:?w1, X
   \   0000F4 5F                    CLRW      X
   \   0000F5 BF00                  LDW       S:?w0, X
   \   0000F7 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   0000FA 8D000000              CALLF     assert_failed
     82              assert_param(IS_SPI_CRC_POLYNOMIAL_OK(CRCPolynomial));
   \                     ??SPI_Init_6:
   \   0000FE B600                  LD        A, S:?b11
   \   000100 A101                  CP        A, #0x1
   \   000102 240F                  JRNC      L:??SPI_Init_7
   \   000104 AE0052                LDW       X, #0x52
   \   000107 BF00                  LDW       S:?w1, X
   \   000109 5F                    CLRW      X
   \   00010A BF00                  LDW       S:?w0, X
   \   00010C AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00010F 8D000000              CALLF     assert_failed
     83          
     84              /* Frame Format, BaudRate, Clock Polarity and Phase configuration */
     85              SPI->CR1 = (uint8_t)((uint8_t)((uint8_t)FirstBit | BaudRatePrescaler) |
     86                              (uint8_t)((uint8_t)ClockPolarity | ClockPhase));
   \                     ??SPI_Init_7:
   \   000113 B600                  LD        A, S:?b13
   \   000115 BA00                  OR        A, S:?b14
   \   000117 88                    PUSH      A
   \   000118 B600                  LD        A, S:?b8
   \   00011A BA00                  OR        A, S:?b15
   \   00011C B700                  LD        S:?b1, A
   \   00011E 84                    POP       A
   \   00011F BA00                  OR        A, S:?b1
   \   000121 C75200                LD        L:0x5200, A
     87          
     88              /* Data direction configuration: BDM, BDOE and RXONLY bits */
     89              SPI->CR2 = (uint8_t)((uint8_t)(Data_Direction) | (uint8_t)(Slave_Management));
   \   000124 B600                  LD        A, S:?b12
   \   000126 BA00                  OR        A, S:?b10
   \   000128 C75201                LD        L:0x5201, A
     90          
     91              if (Mode == SPI_MODE_MASTER)
   \   00012B B600                  LD        A, S:?b9
   \   00012D A104                  CP        A, #0x4
   \   00012F 2606                  JRNE      L:??SPI_Init_8
     92              {
     93                  SPI->CR2 |= (uint8_t)SPI_CR2_SSI;
   \   000131 72105201              BSET      L:0x5201, #0x0
   \   000135 2004                  JRA       L:??SPI_Init_9
     94              }
     95              else
     96              {
     97                  SPI->CR2 &= (uint8_t)~(SPI_CR2_SSI);
   \                     ??SPI_Init_8:
   \   000137 72115201              BRES      L:0x5201, #0x0
     98              }
     99          
    100              /* Master/Slave mode configuration */
    101              SPI->CR1 |= (uint8_t)(Mode);
   \                     ??SPI_Init_9:
   \   00013B B600                  LD        A, S:?b9
   \   00013D CA5200                OR        A, L:0x5200
   \   000140 C75200                LD        L:0x5200, A
    102          
    103              /* CRC configuration */
    104              SPI->CRCPR = (uint8_t)CRCPolynomial;
   \   000143 B600                  LD        A, S:?b11
   \   000145 C75205                LD        L:0x5205, A
    105          }
   \   000148 AC000000              JPF       L:?epilogue_l2_l3
    106          
    107          /**
    108            * @brief  Enables or disables the SPI peripheral.
    109            * @param  NewState New state of the SPI peripheral.
    110            *         This parameter can be: ENABLE or DISABLE
    111            * @retval None
    112            */

   \                                 In section .far_func.text, align 1, keep-with-next
    113          void SPI_Cmd(FunctionalState NewState)
    114          {
   \                     SPI_Cmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    115              /* Check function parameters */
    116              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??SPI_Cmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??SPI_Cmd_0
   \   00000F AE0074                LDW       X, #0x74
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    117          
    118              if (NewState != DISABLE)
   \                     ??SPI_Cmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??SPI_Cmd_1
    119              {
    120                  SPI->CR1 |= SPI_CR1_SPE; /* Enable the SPI peripheral*/
   \   000022 721C5200              BSET      L:0x5200, #0x6
   \   000026 2004                  JRA       L:??SPI_Cmd_2
    121              }
    122              else
    123              {
    124                  SPI->CR1 &= (uint8_t)(~SPI_CR1_SPE); /* Disable the SPI peripheral*/
   \                     ??SPI_Cmd_1:
   \   000028 721D5200              BRES      L:0x5200, #0x6
    125              }
    126          }
   \                     ??SPI_Cmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    127          
    128          /**
    129            * @brief  Enables or disables the specified interrupts.
    130            * @param  SPI_IT Specifies the SPI interrupts sources to be enabled or disabled.
    131            * @param  NewState: The new state of the specified SPI interrupts.
    132            *         This parameter can be: ENABLE or DISABLE.
    133            * @retval None
    134            */

   \                                 In section .far_func.text, align 1
    135          void SPI_ITConfig(SPI_IT_TypeDef SPI_IT, FunctionalState NewState)
    136          {
   \                     SPI_ITConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
    137              uint8_t itpos = 0;
   \   000009 3F00                  CLR       S:?b0
    138              /* Check function parameters */
    139              assert_param(IS_SPI_CONFIG_IT_OK(SPI_IT));
   \   00000B B600                  LD        A, S:?b8
   \   00000D A117                  CP        A, #0x17
   \   00000F 2721                  JREQ      L:??SPI_ITConfig_0
   \   000011 B600                  LD        A, S:?b8
   \   000013 A106                  CP        A, #0x6
   \   000015 271B                  JREQ      L:??SPI_ITConfig_0
   \   000017 B600                  LD        A, S:?b8
   \   000019 A105                  CP        A, #0x5
   \   00001B 2715                  JREQ      L:??SPI_ITConfig_0
   \   00001D B600                  LD        A, S:?b8
   \   00001F A134                  CP        A, #0x34
   \   000021 270F                  JREQ      L:??SPI_ITConfig_0
   \   000023 AE008B                LDW       X, #0x8b
   \   000026 BF00                  LDW       S:?w1, X
   \   000028 5F                    CLRW      X
   \   000029 BF00                  LDW       S:?w0, X
   \   00002B AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00002E 8D000000              CALLF     assert_failed
    140              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??SPI_ITConfig_0:
   \   000032 3D00                  TNZ       S:?b9
   \   000034 2715                  JREQ      L:??SPI_ITConfig_1
   \   000036 B600                  LD        A, S:?b9
   \   000038 A101                  CP        A, #0x1
   \   00003A 270F                  JREQ      L:??SPI_ITConfig_1
   \   00003C AE008C                LDW       X, #0x8c
   \   00003F BF00                  LDW       S:?w1, X
   \   000041 5F                    CLRW      X
   \   000042 BF00                  LDW       S:?w0, X
   \   000044 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000047 8D000000              CALLF     assert_failed
    141          
    142              /* Get the SPI IT index */
    143              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)SPI_IT & (uint8_t)0x0F));
   \                     ??SPI_ITConfig_1:
   \   00004B B600                  LD        A, S:?b8
   \   00004D A40F                  AND       A, #0xf
   \   00004F 5F                    CLRW      X
   \   000050 5C                    INCW      X
   \   000051 8D000000              CALLF     L:?sll16_x_x_a
   \   000055 41                    EXG       A, XL
   \   000056 B700                  LD        S:?b0, A
   \   000058 41                    EXG       A, XL
    144          
    145              if (NewState != DISABLE)
   \   000059 3D00                  TNZ       S:?b9
   \   00005B 270C                  JREQ      L:??SPI_ITConfig_2
    146              {
    147                  SPI->ICR |= itpos; /* Enable interrupt*/
   \   00005D B600                  LD        A, S:?b0
   \   00005F CA5202                OR        A, L:0x5202
   \   000062 C75202                LD        L:0x5202, A
   \   000065 AC000000              JPF       L:?epilogue_w4
    148              }
    149              else
    150              {
    151                  SPI->ICR &= (uint8_t)(~itpos); /* Disable interrupt*/
   \                     ??SPI_ITConfig_2:
   \   000069 3300                  CPL       S:?b0
   \   00006B B600                  LD        A, S:?b0
   \   00006D C45202                AND       A, L:0x5202
   \   000070 C75202                LD        L:0x5202, A
    152              }
    153          }
   \   000073 AC000000              JPF       L:?epilogue_w4
    154          /**
    155            * @brief  Transmits a Data through the SPI peripheral.
    156            * @param  Data : Byte to be transmitted.
    157            * @retval None
    158            */

   \                                 In section .far_func.text, align 1
    159          void SPI_SendData(uint8_t Data)
    160          {
    161              SPI->DR = Data; /* Write in the DR register the data to be sent*/
   \                     SPI_SendData:
   \   000000 C75204                LD        L:0x5204, A
    162          }
   \   000003 87                    RETF
    163          
    164          /**
    165            * @brief  Returns the most recent received data by the SPI peripheral.
    166            * @param  None
    167            * @retval The value of the received data.
    168            */

   \                                 In section .far_func.text, align 1
    169          uint8_t SPI_ReceiveData(void)
    170          {
    171              return ((uint8_t)SPI->DR); /* Return the data in the DR register*/
   \                     SPI_ReceiveData:
   \   000000 C65204                LD        A, L:0x5204
   \   000003 87                    RETF
    172          }
    173          
    174          /**
    175            * @brief  Configures internally by software the NSS pin.
    176            * @param  NewState Indicates the new state of the SPI Software slave management.
    177            *         This parameter can be: ENABLE or DISABLE.
    178            * @retval None
    179            */

   \                                 In section .far_func.text, align 1
    180          void SPI_NSSInternalSoftwareCmd(FunctionalState NewState)
    181          {
   \                     SPI_NSSInternalSoftwareCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    182              /* Check function parameters */
    183              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??SPI_NSSInternalSoftwareCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??SPI_NSSInternalSoftwareCmd_0
   \   00000F AE00B7                LDW       X, #0xb7
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    184          
    185              if (NewState != DISABLE)
   \                     ??SPI_NSSInternalSoftwareCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??SPI_NSSInternalSoftwareCmd_1
    186              {
    187                  SPI->CR2 |= SPI_CR2_SSI; /* Set NSS pin internally by software*/
   \   000022 72105201              BSET      L:0x5201, #0x0
   \   000026 2004                  JRA       L:??SPI_NSSInternalSoftwareCmd_2
    188              }
    189              else
    190              {
    191                  SPI->CR2 &= (uint8_t)(~SPI_CR2_SSI); /* Reset NSS pin internally by software*/
   \                     ??SPI_NSSInternalSoftwareCmd_1:
   \   000028 72115201              BRES      L:0x5201, #0x0
    192              }
    193          }
   \                     ??SPI_NSSInternalSoftwareCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    194          
    195          /**
    196            * @brief  Enables the transmit of the CRC value.
    197            * @param  None
    198            * @retval None
    199            */

   \                                 In section .far_func.text, align 1
    200          void SPI_TransmitCRC(void)
    201          {
    202              SPI->CR2 |= SPI_CR2_CRCNEXT; /* Enable the CRC transmission*/
   \                     SPI_TransmitCRC:
   \   000000 72185201              BSET      L:0x5201, #0x4
    203          }
   \   000004 87                    RETF
    204          
    205          /**
    206            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    207            * @param  NewState Indicates the new state of the SPI CRC value calculation.
    208            *         This parameter can be: ENABLE or DISABLE.
    209            * @retval None
    210            */

   \                                 In section .far_func.text, align 1, keep-with-next
    211          void SPI_CalculateCRCCmd(FunctionalState NewState)
    212          {
   \                     SPI_CalculateCRCCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    213              /* Check function parameters */
    214              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??SPI_CalculateCRCCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??SPI_CalculateCRCCmd_0
   \   00000F AE00D6                LDW       X, #0xd6
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    215          
    216              if (NewState != DISABLE)
   \                     ??SPI_CalculateCRCCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??SPI_CalculateCRCCmd_1
    217              {
    218                  SPI->CR2 |= SPI_CR2_CRCEN; /* Enable the CRC calculation*/
   \   000022 721A5201              BSET      L:0x5201, #0x5
   \   000026 2004                  JRA       L:??SPI_CalculateCRCCmd_2
    219              }
    220              else
    221              {
    222                  SPI->CR2 &= (uint8_t)(~SPI_CR2_CRCEN); /* Disable the CRC calculation*/
   \                     ??SPI_CalculateCRCCmd_1:
   \   000028 721B5201              BRES      L:0x5201, #0x5
    223              }
    224          }
   \                     ??SPI_CalculateCRCCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    225          
    226          /**
    227            * @brief  Returns the transmit or the receive CRC register value.
    228            * @param  SPI_CRC Specifies the CRC register to be read.
    229            * @retval The selected CRC register value.
    230            */

   \                                 In section .far_func.text, align 1
    231          uint8_t SPI_GetCRC(SPI_CRC_TypeDef SPI_CRC)
    232          {
   \                     SPI_GetCRC:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    233              uint8_t crcreg = 0;
   \   000005 3F00                  CLR       S:?b0
    234          
    235              /* Check function parameters */
    236              assert_param(IS_SPI_CRC_OK(SPI_CRC));
   \   000007 B600                  LD        A, S:?b8
   \   000009 A101                  CP        A, #0x1
   \   00000B 2713                  JREQ      L:??SPI_GetCRC_0
   \   00000D 3D00                  TNZ       S:?b8
   \   00000F 270F                  JREQ      L:??SPI_GetCRC_0
   \   000011 AE00EC                LDW       X, #0xec
   \   000014 BF00                  LDW       S:?w1, X
   \   000016 5F                    CLRW      X
   \   000017 BF00                  LDW       S:?w0, X
   \   000019 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001C 8D000000              CALLF     assert_failed
    237          
    238              if (SPI_CRC != SPI_CRC_RX)
   \                     ??SPI_GetCRC_0:
   \   000020 3D00                  TNZ       S:?b8
   \   000022 2707                  JREQ      L:??SPI_GetCRC_1
    239              {
    240                  crcreg = SPI->TXCRCR;  /* Get the Tx CRC register*/
   \   000024 C65207                LD        A, L:0x5207
   \   000027 B700                  LD        S:?b0, A
   \   000029 2005                  JRA       L:??SPI_GetCRC_2
    241              }
    242              else
    243              {
    244                  crcreg = SPI->RXCRCR; /* Get the Rx CRC register*/
   \                     ??SPI_GetCRC_1:
   \   00002B C65206                LD        A, L:0x5206
   \   00002E B700                  LD        S:?b0, A
    245              }
    246          
    247              /* Return the selected CRC register status*/
    248              return crcreg;
   \                     ??SPI_GetCRC_2:
   \   000030 B600                  LD        A, S:?b0
   \   000032 320000                POP       S:?b8
   \   000035 87                    RETF
    249          }
    250          
    251          /**
    252            * @brief  Reset the Rx CRCR and Tx CRCR registers.
    253            * @param  None
    254            * @retval None
    255            */

   \                                 In section .far_func.text, align 1
    256          void SPI_ResetCRC(void)
    257          {
    258              /* Rx CRCR & Tx CRCR registers are reset when CRCEN (hardware calculation)
    259                 bit in SPI_CR2 is written to 1 (enable) */
    260              SPI_CalculateCRCCmd(ENABLE);
   \                     SPI_ResetCRC:
   \   000000 A601                  LD        A, #0x1
   \   000002 8D000000              CALLF     SPI_CalculateCRCCmd
    261          
    262              /* Previous function disable the SPI */
    263              SPI_Cmd(ENABLE);
   \   000006 A601                  LD        A, #0x1
   \   000008 AC000000              JPF       SPI_Cmd
    264          }
    265          
    266          /**
    267            * @brief  Returns the CRC Polynomial register value.
    268            * @param  None
    269            * @retval The CRC Polynomial register value.
    270            */

   \                                 In section .far_func.text, align 1
    271          uint8_t SPI_GetCRCPolynomial(void)
    272          {
    273              return SPI->CRCPR; /* Return the CRC polynomial register */
   \                     SPI_GetCRCPolynomial:
   \   000000 C65205                LD        A, L:0x5205
   \   000003 87                    RETF
    274          }
    275          
    276          /**
    277            * @brief  Selects the data transfer direction in bi-directional mode.
    278            * @param  SPI_Direction Specifies the data transfer direction in bi-directional mode.
    279            * @retval None
    280            */

   \                                 In section .far_func.text, align 1
    281          void SPI_BiDirectionalLineConfig(SPI_Direction_TypeDef SPI_Direction)
    282          {
   \                     SPI_BiDirectionalLineConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    283              /* Check function parameters */
    284              assert_param(IS_SPI_DIRECTION_OK(SPI_Direction));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??SPI_BiDirectionalLineConfig_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??SPI_BiDirectionalLineConfig_0
   \   00000F AE011C                LDW       X, #0x11c
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    285          
    286              if (SPI_Direction != SPI_DIRECTION_RX)
   \                     ??SPI_BiDirectionalLineConfig_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??SPI_BiDirectionalLineConfig_1
    287              {
    288                  SPI->CR2 |= SPI_CR2_BDOE; /* Set the Tx only mode*/
   \   000022 721C5201              BSET      L:0x5201, #0x6
   \   000026 2004                  JRA       L:??SPI_BiDirectionalLineConfig_2
    289              }
    290              else
    291              {
    292                  SPI->CR2 &= (uint8_t)(~SPI_CR2_BDOE); /* Set the Rx only mode*/
   \                     ??SPI_BiDirectionalLineConfig_1:
   \   000028 721D5201              BRES      L:0x5201, #0x6
    293              }
    294          }
   \                     ??SPI_BiDirectionalLineConfig_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    295          
    296          /**
    297            * @brief  Checks whether the specified SPI flag is set or not.
    298            * @param  SPI_FLAG : Specifies the flag to check.
    299            *         This parameter can be any of the @ref SPI_FLAG_TypeDef enumeration.
    300            * @retval FlagStatus : Indicates the state of SPI_FLAG.
    301            *         This parameter can be any of the @ref FlagStatus enumeration.
    302            */
    303          

   \                                 In section .far_func.text, align 1
    304          FlagStatus SPI_GetFlagStatus(SPI_Flag_TypeDef SPI_FLAG)
    305          {
   \                     SPI_GetFlagStatus:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    306              FlagStatus status = RESET;
   \   000005 3F00                  CLR       S:?b0
    307              /* Check parameters */
    308              assert_param(IS_SPI_FLAGS_OK(SPI_FLAG));
   \   000007 B600                  LD        A, S:?b8
   \   000009 A140                  CP        A, #0x40
   \   00000B 2733                  JREQ      L:??SPI_GetFlagStatus_0
   \   00000D B600                  LD        A, S:?b8
   \   00000F A120                  CP        A, #0x20
   \   000011 272D                  JREQ      L:??SPI_GetFlagStatus_0
   \   000013 B600                  LD        A, S:?b8
   \   000015 A110                  CP        A, #0x10
   \   000017 2727                  JREQ      L:??SPI_GetFlagStatus_0
   \   000019 B600                  LD        A, S:?b8
   \   00001B A108                  CP        A, #0x8
   \   00001D 2721                  JREQ      L:??SPI_GetFlagStatus_0
   \   00001F B600                  LD        A, S:?b8
   \   000021 A102                  CP        A, #0x2
   \   000023 271B                  JREQ      L:??SPI_GetFlagStatus_0
   \   000025 B600                  LD        A, S:?b8
   \   000027 A101                  CP        A, #0x1
   \   000029 2715                  JREQ      L:??SPI_GetFlagStatus_0
   \   00002B B600                  LD        A, S:?b8
   \   00002D A180                  CP        A, #0x80
   \   00002F 270F                  JREQ      L:??SPI_GetFlagStatus_0
   \   000031 AE0134                LDW       X, #0x134
   \   000034 BF00                  LDW       S:?w1, X
   \   000036 5F                    CLRW      X
   \   000037 BF00                  LDW       S:?w0, X
   \   000039 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00003C 8D000000              CALLF     assert_failed
    309          
    310              /* Check the status of the specified SPI flag */
    311              if ((SPI->SR & (uint8_t)SPI_FLAG) != (uint8_t)RESET)
   \                     ??SPI_GetFlagStatus_0:
   \   000040 B600                  LD        A, S:?b8
   \   000042 C45203                AND       A, L:0x5203
   \   000045 A100                  CP        A, #0x0
   \   000047 2706                  JREQ      L:??SPI_GetFlagStatus_1
    312              {
    313                  status = SET; /* SPI_FLAG is set */
   \   000049 35010000              MOV       S:?b0, #0x1
   \   00004D 2002                  JRA       L:??SPI_GetFlagStatus_2
    314              }
    315              else
    316              {
    317                  status = RESET; /* SPI_FLAG is reset*/
   \                     ??SPI_GetFlagStatus_1:
   \   00004F 3F00                  CLR       S:?b0
    318              }
    319          
    320              /* Return the SPI_FLAG status */
    321              return status;
   \                     ??SPI_GetFlagStatus_2:
   \   000051 B600                  LD        A, S:?b0
   \   000053 320000                POP       S:?b8
   \   000056 87                    RETF
    322          }
    323          
    324          /**
    325            * @brief  Clears the SPI flags.
    326            * @param  SPI_FLAG : Specifies the flag to clear.
    327            *         This parameter can be one of the following values:
    328            *         - SPI_FLAG_CRCERR
    329            *         - SPI_FLAG_WKUP
    330            * @note   - OVR (OverRun Error) interrupt pending bit is cleared by software
    331            *         sequence:
    332            *         a read operation to SPI_DR register (SPI_ReceiveData()) followed by
    333            *         a read operation to SPI_SR register (SPI_GetFlagStatus()).
    334            *         - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
    335            *         a read/write operation to SPI_SR register (SPI_GetFlagStatus()) followed by
    336            *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
    337            * @retval None
    338            */

   \                                 In section .far_func.text, align 1
    339          void SPI_ClearFlag(SPI_Flag_TypeDef SPI_FLAG)
    340          {
   \                     SPI_ClearFlag:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    341              assert_param(IS_SPI_CLEAR_FLAGS_OK(SPI_FLAG));
   \   000005 B600                  LD        A, S:?b8
   \   000007 A110                  CP        A, #0x10
   \   000009 2715                  JREQ      L:??SPI_ClearFlag_0
   \   00000B B600                  LD        A, S:?b8
   \   00000D A108                  CP        A, #0x8
   \   00000F 270F                  JREQ      L:??SPI_ClearFlag_0
   \   000011 AE0155                LDW       X, #0x155
   \   000014 BF00                  LDW       S:?w1, X
   \   000016 5F                    CLRW      X
   \   000017 BF00                  LDW       S:?w0, X
   \   000019 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001C 8D000000              CALLF     assert_failed
    342              /* Clear the flag bit */
    343              SPI->SR = (uint8_t)(~SPI_FLAG);
   \                     ??SPI_ClearFlag_0:
   \   000020 3300                  CPL       S:?b8
   \   000022 B600                  LD        A, S:?b8
   \   000024 C75203                LD        L:0x5203, A
    344          }
   \   000027 320000                POP       S:?b8
   \   00002A 87                    RETF
    345          
    346          /**
    347            * @brief  Checks whether the specified interrupt has occurred or not.
    348            * @param  SPI_IT: Specifies the SPI interrupt pending bit to check.
    349            *         This parameter can be one of the following values:
    350            *         - SPI_IT_CRCERR
    351            *         - SPI_IT_WKUP
    352            *         - SPI_IT_OVR
    353            *         - SPI_IT_MODF
    354            *         - SPI_IT_RXNE
    355            *         - SPI_IT_TXE
    356            * @retval ITStatus : Indicates the state of the SPI_IT.
    357            *         This parameter can be any of the @ref ITStatus enumeration.
    358            */

   \                                 In section .far_func.text, align 1
    359          ITStatus SPI_GetITStatus(SPI_IT_TypeDef SPI_IT)
    360          {
   \                     SPI_GetITStatus:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    361              ITStatus pendingbitstatus = RESET;
   \   000005 3F00                  CLR       S:?b2
    362              uint8_t itpos = 0;
   \   000007 3F00                  CLR       S:?b0
    363              uint8_t itmask1 = 0;
   \   000009 3F00                  CLR       S:?b3
    364              uint8_t itmask2 = 0;
   \   00000B 3F00                  CLR       S:?b1
    365              uint8_t enablestatus = 0;
   \   00000D 3F00                  CLR       S:?b4
    366              assert_param(IS_SPI_GET_IT_OK(SPI_IT));
   \   00000F B600                  LD        A, S:?b8
   \   000011 A165                  CP        A, #0x65
   \   000013 272D                  JREQ      L:??SPI_GetITStatus_0
   \   000015 B600                  LD        A, S:?b8
   \   000017 A155                  CP        A, #0x55
   \   000019 2727                  JREQ      L:??SPI_GetITStatus_0
   \   00001B B600                  LD        A, S:?b8
   \   00001D A145                  CP        A, #0x45
   \   00001F 2721                  JREQ      L:??SPI_GetITStatus_0
   \   000021 B600                  LD        A, S:?b8
   \   000023 A134                  CP        A, #0x34
   \   000025 271B                  JREQ      L:??SPI_GetITStatus_0
   \   000027 B600                  LD        A, S:?b8
   \   000029 A117                  CP        A, #0x17
   \   00002B 2715                  JREQ      L:??SPI_GetITStatus_0
   \   00002D B600                  LD        A, S:?b8
   \   00002F A106                  CP        A, #0x6
   \   000031 270F                  JREQ      L:??SPI_GetITStatus_0
   \   000033 AE016E                LDW       X, #0x16e
   \   000036 BF00                  LDW       S:?w1, X
   \   000038 5F                    CLRW      X
   \   000039 BF00                  LDW       S:?w0, X
   \   00003B AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00003E 8D000000              CALLF     assert_failed
    367              /* Get the SPI IT index */
    368              itpos = (uint8_t)((uint8_t)1 << ((uint8_t)SPI_IT & (uint8_t)0x0F));
   \                     ??SPI_GetITStatus_0:
   \   000042 B600                  LD        A, S:?b8
   \   000044 A40F                  AND       A, #0xf
   \   000046 5F                    CLRW      X
   \   000047 5C                    INCW      X
   \   000048 8D000000              CALLF     L:?sll16_x_x_a
   \   00004C 41                    EXG       A, XL
   \   00004D B700                  LD        S:?b0, A
   \   00004F 41                    EXG       A, XL
    369          
    370              /* Get the SPI IT mask */
    371              itmask1 = (uint8_t)((uint8_t)SPI_IT >> (uint8_t)4);
   \   000050 B600                  LD        A, S:?b8
   \   000052 4E                    SWAP      A
   \   000053 A40F                  AND       A, #0xf
   \   000055 B700                  LD        S:?b3, A
    372              /* Set the IT mask */
    373              itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \   000057 5F                    CLRW      X
   \   000058 5C                    INCW      X
   \   000059 B600                  LD        A, S:?b3
   \   00005B 8D000000              CALLF     L:?sll16_x_x_a
   \   00005F 41                    EXG       A, XL
   \   000060 B700                  LD        S:?b1, A
   \   000062 41                    EXG       A, XL
    374              /* Get the SPI_ITPENDINGBIT enable bit status */
    375              enablestatus = (uint8_t)((uint8_t)SPI->SR & itmask2);
   \   000063 B600                  LD        A, S:?b1
   \   000065 C45203                AND       A, L:0x5203
   \   000068 B700                  LD        S:?b4, A
    376              /* Check the status of the specified SPI interrupt */
    377              if (((SPI->ICR & itpos) != RESET) && enablestatus)
   \   00006A B600                  LD        A, S:?b0
   \   00006C C45202                AND       A, L:0x5202
   \   00006F A100                  CP        A, #0x0
   \   000071 270A                  JREQ      L:??SPI_GetITStatus_1
   \   000073 3D00                  TNZ       S:?b4
   \   000075 2706                  JREQ      L:??SPI_GetITStatus_1
    378              {
    379                  /* SPI_ITPENDINGBIT is set */
    380                  pendingbitstatus = SET;
   \   000077 35010000              MOV       S:?b2, #0x1
   \   00007B 2002                  JRA       L:??SPI_GetITStatus_2
    381              }
    382              else
    383              {
    384                  /* SPI_ITPENDINGBIT is reset */
    385                  pendingbitstatus = RESET;
   \                     ??SPI_GetITStatus_1:
   \   00007D 3F00                  CLR       S:?b2
    386              }
    387              /* Return the SPI_ITPENDINGBIT status */
    388              return  pendingbitstatus;
   \                     ??SPI_GetITStatus_2:
   \   00007F B600                  LD        A, S:?b2
   \   000081 320000                POP       S:?b8
   \   000084 87                    RETF
    389          }
    390          /**
    391            * @brief  Clears the interrupt pending bits.
    392            * @param  SPI_IT: Specifies the interrupt pending bit to clear.
    393            *         This parameter can be one of the following values:
    394            *         - SPI_IT_CRCERR
    395            *         - SPI_IT_WKUP
    396            * @note   - OVR (OverRun Error) interrupt pending bit is cleared by software sequence:
    397            *         a read operation to SPI_DR register (SPI_ReceiveData()) followed by
    398            *         a read operation to SPI_SR register (SPI_GetITStatus()).
    399            *         - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
    400            *         a read/write operation to SPI_SR register (SPI_GetITStatus()) followed by
    401            *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
    402            * @retval None
    403            */

   \                                 In section .far_func.text, align 1
    404          void SPI_ClearITPendingBit(SPI_IT_TypeDef SPI_IT)
    405          {
   \                     SPI_ClearITPendingBit:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    406              uint8_t itpos = 0;
   \   000005 3F00                  CLR       S:?b0
    407              assert_param(IS_SPI_CLEAR_IT_OK(SPI_IT));
   \   000007 B600                  LD        A, S:?b8
   \   000009 A145                  CP        A, #0x45
   \   00000B 2715                  JREQ      L:??SPI_ClearITPendingBit_0
   \   00000D B600                  LD        A, S:?b8
   \   00000F A134                  CP        A, #0x34
   \   000011 270F                  JREQ      L:??SPI_ClearITPendingBit_0
   \   000013 AE0197                LDW       X, #0x197
   \   000016 BF00                  LDW       S:?w1, X
   \   000018 5F                    CLRW      X
   \   000019 BF00                  LDW       S:?w0, X
   \   00001B AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001E 8D000000              CALLF     assert_failed
    408          
    409              /* Clear  SPI_IT_CRCERR or SPI_IT_WKUP interrupt pending bits */
    410          
    411              /* Get the SPI pending bit index */
    412              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)(SPI_IT & (uint8_t)0xF0) >> 4));
   \                     ??SPI_ClearITPendingBit_0:
   \   000022 B600                  LD        A, S:?b8
   \   000024 4E                    SWAP      A
   \   000025 A40F                  AND       A, #0xf
   \   000027 5F                    CLRW      X
   \   000028 5C                    INCW      X
   \   000029 8D000000              CALLF     L:?sll16_x_x_a
   \   00002D 41                    EXG       A, XL
   \   00002E B700                  LD        S:?b0, A
   \   000030 41                    EXG       A, XL
    413              /* Clear the pending bit */
    414              SPI->SR = (uint8_t)(~itpos);
   \   000031 3300                  CPL       S:?b0
   \   000033 B600                  LD        A, S:?b0
   \   000035 C75203                LD        L:0x5203, A
    415          
    416          }
   \   000038 320000                POP       S:?b8
   \   00003B 87                    RETF

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "D:\\\\Project\\\\STM8S_StdP...">`:
   \   000000 443A5C50726F          DC8 44H, 3AH, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \   000008 63745C53544D          DC8 63H, 74H, 5CH, 53H, 54H, 4DH, 38H, 53H
   \   000010 5F5374645065          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \   000018 70685F4C6962          DC8 70H, 68H, 5FH, 4CH, 69H, 62H, 5FH, 56H
   \   000020 322E312E305C          DC8 32H, 2EH, 31H, 2EH, 30H, 5CH, 4CH, 69H
   \   000028 627261726965          DC8 62H, 72H, 61H, 72H, 69H, 65H, 73H, 5CH
   \   000030 53544D38535F          DC8 53H, 54H, 4DH, 38H, 53H, 5FH, 53H, 74H
   \   000038 645065726970          DC8 64H, 50H, 65H, 72H, 69H, 70H, 68H, 5FH
   \   000040 447269766572          DC8 44H, 72H, 69H, 76H, 65H, 72H, 5CH, 73H
   \   000048 72635C73746D          DC8 72H, 63H, 5CH, 73H, 74H, 6DH, 38H, 73H
   \   000050 5F7370692E63          DC8 5FH, 73H, 70H, 69H, 2EH, 63H, 0
    417          /**
    418            * @}
    419            */
    420            
    421          /**
    422            * @}
    423            */
    424            
    425          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     SPI_DeInit                                 21
     SPI_Init                                  332
     SPI_Cmd                                    48
     SPI_ITConfig                              119
     SPI_SendData                                4
     SPI_ReceiveData                             4
     SPI_NSSInternalSoftwareCmd                 48
     SPI_TransmitCRC                             5
     SPI_CalculateCRCCmd                        48
     SPI_GetCRC                                 54
     SPI_ResetCRC                               12
     SPI_GetCRCPolynomial                        4
     SPI_BiDirectionalLineConfig                48
     SPI_GetFlagStatus                          87
     SPI_ClearFlag                              43
     SPI_GetITStatus                           133
     SPI_ClearITPendingBit                      60
     ?<Constant "D:\\Project\\STM8S_StdP...">   87

 
 1 070 bytes in section .far_func.text
    87 bytes in section .near.rodata
 
 1 070 bytes of CODE  memory
    87 bytes of CONST memory

Errors: none
Warnings: none
