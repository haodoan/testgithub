###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             24/Jan/2015  12:33:02 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_St #
#                    dPeriph_Driver\src\stm8s_clk.c                           #
#    Command line =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_St #
#                    dPeriph_Driver\src\stm8s_clk.c -e -Ol --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_cross_call --debug --code_model medium              #
#                    --data_model medium -o D:\Project\STM8S_StdPeriph_Lib_V2 #
#                    .1.0\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S208\Ob #
#                    j\ --dlib_config "C:\Program Files\IAR Systems\Embedded  #
#                    Workbench 6.0\stm8\LIB\dlstm8mmn.h" -D                   #
#                    USE_STM8_128_EVAL -D STM8S003 -lC                        #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\ -lb                 #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\ -I                  #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\ -I                             #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\..\..\Libraries\STM8S_StdPeriph #
#                    _Driver\inc\ -I D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Pr #
#                    oject\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Utilities #
#                    \STM8S_EVAL\ -I D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Pr #
#                    oject\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Utilities #
#                    \STM8S_EVAL\STM8S-128_EVAL\ -I                           #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\..\..\Utilities\STM8S_EVAL\Comm #
#                    on\ --vregs 16                                           #
#    List file    =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\stm8s_clk.lst        #
#    Object file  =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\Obj\stm8s_clk.o           #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_StdPeriph_Driver\src\stm8s_clk.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_clk.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the CLK peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          
     24          #include "stm8s_clk.h"
     25          
     26          /** @addtogroup STM8S_StdPeriph_Driver
     27            * @{
     28            */
     29          /* Private typedef -----------------------------------------------------------*/
     30          /* Private define ------------------------------------------------------------*/
     31          /* Private macro -------------------------------------------------------------*/
     32          /* Private variables ---------------------------------------------------------*/
     33          /* Private function prototypes -----------------------------------------------*/
     34          
     35          /* Private Constants ---------------------------------------------------------*/
     36          
     37          /**
     38            * @addtogroup CLK_Private_Constants
     39            * @{
     40            */
     41          

   \                                 In section .near.rodata, align 1
     42          CONST uint8_t HSIDivFactor[4] = {1, 2, 4, 8}; /*!< Holds the different HSI Divider factors */
   \                     HSIDivFactor:
   \   000000 01020408              DC8 1, 2, 4, 8

   \                                 In section .near.rodata, align 1
     43          CONST uint8_t CLKPrescTable[8] = {1, 2, 4, 8, 10, 16, 20, 40}; /*!< Holds the different CLK prescaler values */
   \                     CLKPrescTable:
   \   000000 010204080A10          DC8 1, 2, 4, 8, 10, 16, 20, 40
     44          
     45          /**
     46            * @}
     47            */
     48          
     49          /* Public functions ----------------------------------------------------------*/
     50          /**
     51            * @addtogroup CLK_Public_Functions
     52            * @{
     53            */
     54          
     55          /**
     56            * @brief  Deinitializes the CLK peripheral registers to their default reset
     57            * values.
     58            * @param  None
     59            * @retval None
     60            * @par Warning:
     61            * Resetting the CCOR register: \n
     62            * When the CCOEN bit is set, the reset of the CCOR register require
     63            * two consecutive write instructions in order to reset first the CCOEN bit
     64            * and the second one is to reset the CCOSEL bits.
     65            */

   \                                 In section .far_func.text, align 1
     66          void CLK_DeInit(void)
     67          {
     68          
     69              CLK->ICKR = CLK_ICKR_RESET_VALUE;
   \                     CLK_DeInit:
   \   000000 350150C0              MOV       L:0x50c0, #0x1
     70              CLK->ECKR = CLK_ECKR_RESET_VALUE;
   \   000004 350050C1              MOV       L:0x50c1, #0x0
     71              CLK->SWR  = CLK_SWR_RESET_VALUE;
   \   000008 35E150C4              MOV       L:0x50c4, #0xe1
     72              CLK->SWCR = CLK_SWCR_RESET_VALUE;
   \   00000C 350050C5              MOV       L:0x50c5, #0x0
     73              CLK->CKDIVR = CLK_CKDIVR_RESET_VALUE;
   \   000010 351850C6              MOV       L:0x50c6, #0x18
     74              CLK->PCKENR1 = CLK_PCKENR1_RESET_VALUE;
   \   000014 35FF50C7              MOV       L:0x50c7, #0xff
     75              CLK->PCKENR2 = CLK_PCKENR2_RESET_VALUE;
   \   000018 35FF50CA              MOV       L:0x50ca, #0xff
     76              CLK->CSSR = CLK_CSSR_RESET_VALUE;
   \   00001C 350050C8              MOV       L:0x50c8, #0x0
     77              CLK->CCOR = CLK_CCOR_RESET_VALUE;
   \   000020 350050C9              MOV       L:0x50c9, #0x0
     78              while ((CLK->CCOR & CLK_CCOR_CCOEN)!= 0)
   \                     ??CLK_DeInit_0:
   \   000024 720050C9FB            BTJT      L:0x50c9, #0x0, L:??CLK_DeInit_0
     79              {}
     80              CLK->CCOR = CLK_CCOR_RESET_VALUE;
   \   000029 350050C9              MOV       L:0x50c9, #0x0
     81              CLK->HSITRIMR = CLK_HSITRIMR_RESET_VALUE;
   \   00002D 350050CC              MOV       L:0x50cc, #0x0
     82              CLK->SWIMCCR = CLK_SWIMCCR_RESET_VALUE;
   \   000031 350050CD              MOV       L:0x50cd, #0x0
     83          
     84          }
   \   000035 87                    RETF
     85          
     86          /**
     87            * @brief   Configures the High Speed Internal oscillator (HSI).
     88            * @par Full description:
     89            * If CLK_FastHaltWakeup is enabled, HSI oscillator is automatically
     90            * switched-on (HSIEN=1) and selected as next clock master
     91            * (CKM=SWI=HSI) when resuming from HALT/ActiveHalt modes.\n
     92            * @param   NewState this parameter is the Wake-up Mode state.
     93            * @retval None
     94            */

   \                                 In section .far_func.text, align 1
     95          void CLK_FastHaltWakeUpCmd(FunctionalState NewState)
     96          {
   \                     CLK_FastHaltWakeUpCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
     97          
     98              /* check the parameters */
     99              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??CLK_FastHaltWakeUpCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??CLK_FastHaltWakeUpCmd_0
   \   00000F AE0063                LDW       X, #0x63
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    100          
    101              if (NewState != DISABLE)
   \                     ??CLK_FastHaltWakeUpCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??CLK_FastHaltWakeUpCmd_1
    102              {
    103                  /* Set FHWU bit (HSI oscillator is automatically switched-on) */
    104                  CLK->ICKR |= CLK_ICKR_FHWU;
   \   000022 721450C0              BSET      L:0x50c0, #0x2
   \   000026 2004                  JRA       L:??CLK_FastHaltWakeUpCmd_2
    105              }
    106              else  /* FastHaltWakeup = DISABLE */
    107              {
    108                  /* Reset FHWU bit */
    109                  CLK->ICKR &= (uint8_t)(~CLK_ICKR_FHWU);
   \                     ??CLK_FastHaltWakeUpCmd_1:
   \   000028 721550C0              BRES      L:0x50c0, #0x2
    110              }
    111          
    112          }
   \                     ??CLK_FastHaltWakeUpCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    113          
    114          /**
    115            * @brief  Enable or Disable the External High Speed oscillator (HSE).
    116            * @param   NewState new state of HSEEN, value accepted ENABLE, DISABLE.
    117            * @retval None
    118            */

   \                                 In section .far_func.text, align 1
    119          void CLK_HSECmd(FunctionalState NewState)
    120          {
   \                     CLK_HSECmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    121          
    122              /* Check the parameters */
    123              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??CLK_HSECmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??CLK_HSECmd_0
   \   00000F AE007B                LDW       X, #0x7b
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    124          
    125              if (NewState != DISABLE)
   \                     ??CLK_HSECmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??CLK_HSECmd_1
    126              {
    127                  /* Set HSEEN bit */
    128                  CLK->ECKR |= CLK_ECKR_HSEEN;
   \   000022 721050C1              BSET      L:0x50c1, #0x0
   \   000026 2004                  JRA       L:??CLK_HSECmd_2
    129              }
    130              else
    131              {
    132                  /* Reset HSEEN bit */
    133                  CLK->ECKR &= (uint8_t)(~CLK_ECKR_HSEEN);
   \                     ??CLK_HSECmd_1:
   \   000028 721150C1              BRES      L:0x50c1, #0x0
    134              }
    135          
    136          }
   \                     ??CLK_HSECmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    137          
    138          /**
    139            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    140            * @param   NewState new state of HSIEN, value accepted ENABLE, DISABLE.
    141            * @retval None
    142            */

   \                                 In section .far_func.text, align 1
    143          void CLK_HSICmd(FunctionalState NewState)
    144          {
   \                     CLK_HSICmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    145          
    146              /* Check the parameters */
    147              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??CLK_HSICmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??CLK_HSICmd_0
   \   00000F AE0093                LDW       X, #0x93
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    148          
    149              if (NewState != DISABLE)
   \                     ??CLK_HSICmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??CLK_HSICmd_1
    150              {
    151                  /* Set HSIEN bit */
    152                  CLK->ICKR |= CLK_ICKR_HSIEN;
   \   000022 721050C0              BSET      L:0x50c0, #0x0
   \   000026 2004                  JRA       L:??CLK_HSICmd_2
    153              }
    154              else
    155              {
    156                  /* Reset HSIEN bit */
    157                  CLK->ICKR &= (uint8_t)(~CLK_ICKR_HSIEN);
   \                     ??CLK_HSICmd_1:
   \   000028 721150C0              BRES      L:0x50c0, #0x0
    158              }
    159          
    160          }
   \                     ??CLK_HSICmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    161          
    162          /**
    163            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    164            * @param    NewState new state of LSIEN, value accepted ENABLE, DISABLE.
    165            * @retval None
    166            */

   \                                 In section .far_func.text, align 1
    167          void CLK_LSICmd(FunctionalState NewState)
    168          {
   \                     CLK_LSICmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    169          
    170              /* Check the parameters */
    171              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??CLK_LSICmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??CLK_LSICmd_0
   \   00000F AE00AB                LDW       X, #0xab
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    172          
    173              if (NewState != DISABLE)
   \                     ??CLK_LSICmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??CLK_LSICmd_1
    174              {
    175                  /* Set LSIEN bit */
    176                  CLK->ICKR |= CLK_ICKR_LSIEN;
   \   000022 721650C0              BSET      L:0x50c0, #0x3
   \   000026 2004                  JRA       L:??CLK_LSICmd_2
    177              }
    178              else
    179              {
    180                  /* Reset LSIEN bit */
    181                  CLK->ICKR &= (uint8_t)(~CLK_ICKR_LSIEN);
   \                     ??CLK_LSICmd_1:
   \   000028 721750C0              BRES      L:0x50c0, #0x3
    182              }
    183          
    184          }
   \                     ??CLK_LSICmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    185          
    186          /**
    187            * @brief  Enables or disablle the Configurable Clock Output (CCO).
    188            * @param   NewState : New state of CCEN bit (CCO register).
    189            * This parameter can be any of the @ref FunctionalState enumeration.
    190            * @retval None
    191            */

   \                                 In section .far_func.text, align 1
    192          void CLK_CCOCmd(FunctionalState NewState)
    193          {
   \                     CLK_CCOCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    194          
    195              /* Check the parameters */
    196              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??CLK_CCOCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??CLK_CCOCmd_0
   \   00000F AE00C4                LDW       X, #0xc4
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    197          
    198              if (NewState != DISABLE)
   \                     ??CLK_CCOCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??CLK_CCOCmd_1
    199              {
    200                  /* Set CCOEN bit */
    201                  CLK->CCOR |= CLK_CCOR_CCOEN;
   \   000022 721050C9              BSET      L:0x50c9, #0x0
   \   000026 2004                  JRA       L:??CLK_CCOCmd_2
    202              }
    203              else
    204              {
    205                  /* Reset CCOEN bit */
    206                  CLK->CCOR &= (uint8_t)(~CLK_CCOR_CCOEN);
   \                     ??CLK_CCOCmd_1:
   \   000028 721150C9              BRES      L:0x50c9, #0x0
    207              }
    208          
    209          }
   \                     ??CLK_CCOCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    210          
    211          /**
    212            * @brief  Starts or Stops manually the clock switch execution.
    213            * @par Full description:
    214            * NewState parameter set the SWEN.
    215            * @param   NewState new state of SWEN, value accepted ENABLE, DISABLE.
    216            * @retval None
    217            */

   \                                 In section .far_func.text, align 1
    218          void CLK_ClockSwitchCmd(FunctionalState NewState)
    219          {
   \                     CLK_ClockSwitchCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    220          
    221              /* Check the parameters */
    222              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??CLK_ClockSwitchCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??CLK_ClockSwitchCmd_0
   \   00000F AE00DE                LDW       X, #0xde
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    223          
    224              if (NewState != DISABLE )
   \                     ??CLK_ClockSwitchCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??CLK_ClockSwitchCmd_1
    225              {
    226                  /* Enable the Clock Switch */
    227                  CLK->SWCR |= CLK_SWCR_SWEN;
   \   000022 721250C5              BSET      L:0x50c5, #0x1
   \   000026 2004                  JRA       L:??CLK_ClockSwitchCmd_2
    228              }
    229              else
    230              {
    231                  /* Disable the Clock Switch */
    232                  CLK->SWCR &= (uint8_t)(~CLK_SWCR_SWEN);
   \                     ??CLK_ClockSwitchCmd_1:
   \   000028 721350C5              BRES      L:0x50c5, #0x1
    233              }
    234          
    235          }
   \                     ??CLK_ClockSwitchCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    236          
    237          /**
    238            * @brief  Configures the slow active halt wake up
    239            * @param   NewState: specifies the Slow Active Halt wake up state.
    240            * can be set of the following values:
    241            * - DISABLE: Slow Active Halt mode disabled;
    242            * - ENABLE:  Slow Active Halt mode enabled.
    243            * @retval None
    244            */

   \                                 In section .far_func.text, align 1
    245          void CLK_SlowActiveHaltWakeUpCmd(FunctionalState NewState)
    246          {
   \                     CLK_SlowActiveHaltWakeUpCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    247          
    248              /* check the parameters */
    249              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??CLK_SlowActiveHaltWakeUpCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??CLK_SlowActiveHaltWakeUpCmd_0
   \   00000F AE00F9                LDW       X, #0xf9
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    250          
    251              if (NewState != DISABLE)
   \                     ??CLK_SlowActiveHaltWakeUpCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??CLK_SlowActiveHaltWakeUpCmd_1
    252              {
    253                  /* Set S_ACTHALT bit */
    254                  CLK->ICKR |= CLK_ICKR_SWUAH;
   \   000022 721A50C0              BSET      L:0x50c0, #0x5
   \   000026 2004                  JRA       L:??CLK_SlowActiveHaltWakeUpCmd_2
    255              }
    256              else
    257              {
    258                  /* Reset S_ACTHALT bit */
    259                  CLK->ICKR &= (uint8_t)(~CLK_ICKR_SWUAH);
   \                     ??CLK_SlowActiveHaltWakeUpCmd_1:
   \   000028 721B50C0              BRES      L:0x50c0, #0x5
    260              }
    261          
    262          }
   \                     ??CLK_SlowActiveHaltWakeUpCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    263          
    264          /**
    265            * @brief   Enables or disables the specified peripheral CLK.
    266            * @param   CLK_Peripheral : This parameter specifies the peripheral clock to gate.
    267            * This parameter can be any of the  @ref CLK_Peripheral_TypeDef enumeration.
    268            * @param   NewState : New state of specified peripheral clock.
    269            * This parameter can be any of the @ref FunctionalState enumeration.
    270            * @retval None
    271            */

   \                                 In section .far_func.text, align 1
    272          void CLK_PeripheralClockConfig(CLK_Peripheral_TypeDef CLK_Peripheral, FunctionalState NewState)
    273          {
   \                     CLK_PeripheralClockConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
    274          
    275              /* Check the parameters */
    276              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000009 3D00                  TNZ       S:?b9
   \   00000B 2715                  JREQ      L:??CLK_PeripheralClockConfig_0
   \   00000D B600                  LD        A, S:?b9
   \   00000F A101                  CP        A, #0x1
   \   000011 270F                  JREQ      L:??CLK_PeripheralClockConfig_0
   \   000013 AE0114                LDW       X, #0x114
   \   000016 BF00                  LDW       S:?w1, X
   \   000018 5F                    CLRW      X
   \   000019 BF00                  LDW       S:?w0, X
   \   00001B AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001E 8D000000              CALLF     assert_failed
    277              assert_param(IS_CLK_PERIPHERAL_OK(CLK_Peripheral));
   \                     ??CLK_PeripheralClockConfig_0:
   \   000022 3D00                  TNZ       S:?b8
   \   000024 275D                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   000026 B600                  LD        A, S:?b8
   \   000028 A101                  CP        A, #0x1
   \   00002A 2757                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   00002C B600                  LD        A, S:?b8
   \   00002E A103                  CP        A, #0x3
   \   000030 2751                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   000032 B600                  LD        A, S:?b8
   \   000034 A103                  CP        A, #0x3
   \   000036 274B                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   000038 B600                  LD        A, S:?b8
   \   00003A A103                  CP        A, #0x3
   \   00003C 2745                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   00003E B600                  LD        A, S:?b8
   \   000040 A104                  CP        A, #0x4
   \   000042 273F                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   000044 B600                  LD        A, S:?b8
   \   000046 A105                  CP        A, #0x5
   \   000048 2739                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   00004A B600                  LD        A, S:?b8
   \   00004C A105                  CP        A, #0x5
   \   00004E 2733                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   000050 B600                  LD        A, S:?b8
   \   000052 A104                  CP        A, #0x4
   \   000054 272D                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   000056 B600                  LD        A, S:?b8
   \   000058 A106                  CP        A, #0x6
   \   00005A 2727                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   00005C B600                  LD        A, S:?b8
   \   00005E A107                  CP        A, #0x7
   \   000060 2721                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   000062 B600                  LD        A, S:?b8
   \   000064 A117                  CP        A, #0x17
   \   000066 271B                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   000068 B600                  LD        A, S:?b8
   \   00006A A113                  CP        A, #0x13
   \   00006C 2715                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   00006E B600                  LD        A, S:?b8
   \   000070 A112                  CP        A, #0x12
   \   000072 270F                  JREQ      L:??CLK_PeripheralClockConfig_1
   \   000074 AE0115                LDW       X, #0x115
   \   000077 BF00                  LDW       S:?w1, X
   \   000079 5F                    CLRW      X
   \   00007A BF00                  LDW       S:?w0, X
   \   00007C AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00007F 8D000000              CALLF     assert_failed
    278          
    279              if (((uint8_t)CLK_Peripheral & (uint8_t)0x10) == 0x00)
   \                     ??CLK_PeripheralClockConfig_1:
   \   000083 B600                  LD        A, S:?b8
   \   000085 A410                  AND       A, #0x10
   \   000087 A100                  CP        A, #0x0
   \   000089 262F                  JRNE      L:??CLK_PeripheralClockConfig_2
    280              {
    281                  if (NewState != DISABLE)
   \   00008B 3D00                  TNZ       S:?b9
   \   00008D 2715                  JREQ      L:??CLK_PeripheralClockConfig_3
    282                  {
    283                      /* Enable the peripheral Clock */
    284                      CLK->PCKENR1 |= (uint8_t)((uint8_t)1 << ((uint8_t)CLK_Peripheral & (uint8_t)0x0F));
   \   00008F B600                  LD        A, S:?b8
   \   000091 A40F                  AND       A, #0xf
   \   000093 5F                    CLRW      X
   \   000094 5C                    INCW      X
   \   000095 8D000000              CALLF     L:?sll16_x_x_a
   \   000099 9F                    LD        A, XL
   \   00009A CA50C7                OR        A, L:0x50c7
   \   00009D C750C7                LD        L:0x50c7, A
   \   0000A0 AC000000              JPF       L:?epilogue_w4
    285                  }
    286                  else
    287                  {
    288                      /* Disable the peripheral Clock */
    289                      CLK->PCKENR1 &= (uint8_t)(~(uint8_t)(((uint8_t)1 << ((uint8_t)CLK_Peripheral & (uint8_t)0x0F))));
   \                     ??CLK_PeripheralClockConfig_3:
   \   0000A4 B600                  LD        A, S:?b8
   \   0000A6 A40F                  AND       A, #0xf
   \   0000A8 5F                    CLRW      X
   \   0000A9 5C                    INCW      X
   \   0000AA 8D000000              CALLF     L:?sll16_x_x_a
   \   0000AE 9F                    LD        A, XL
   \   0000AF 43                    CPL       A
   \   0000B0 C450C7                AND       A, L:0x50c7
   \   0000B3 C750C7                LD        L:0x50c7, A
   \   0000B6 AC000000              JPF       L:?epilogue_w4
    290                  }
    291              }
    292              else
    293              {
    294                  if (NewState != DISABLE)
   \                     ??CLK_PeripheralClockConfig_2:
   \   0000BA 3D00                  TNZ       S:?b9
   \   0000BC 2715                  JREQ      L:??CLK_PeripheralClockConfig_4
    295                  {
    296                      /* Enable the peripheral Clock */
    297                      CLK->PCKENR2 |= (uint8_t)((uint8_t)1 << ((uint8_t)CLK_Peripheral & (uint8_t)0x0F));
   \   0000BE B600                  LD        A, S:?b8
   \   0000C0 A40F                  AND       A, #0xf
   \   0000C2 5F                    CLRW      X
   \   0000C3 5C                    INCW      X
   \   0000C4 8D000000              CALLF     L:?sll16_x_x_a
   \   0000C8 9F                    LD        A, XL
   \   0000C9 CA50CA                OR        A, L:0x50ca
   \   0000CC C750CA                LD        L:0x50ca, A
   \   0000CF AC000000              JPF       L:?epilogue_w4
    298                  }
    299                  else
    300                  {
    301                      /* Disable the peripheral Clock */
    302                      CLK->PCKENR2 &= (uint8_t)(~(uint8_t)(((uint8_t)1 << ((uint8_t)CLK_Peripheral & (uint8_t)0x0F))));
   \                     ??CLK_PeripheralClockConfig_4:
   \   0000D3 B600                  LD        A, S:?b8
   \   0000D5 A40F                  AND       A, #0xf
   \   0000D7 5F                    CLRW      X
   \   0000D8 5C                    INCW      X
   \   0000D9 8D000000              CALLF     L:?sll16_x_x_a
   \   0000DD 9F                    LD        A, XL
   \   0000DE 43                    CPL       A
   \   0000DF C450CA                AND       A, L:0x50ca
   \   0000E2 C750CA                LD        L:0x50ca, A
    303                  }
    304              }
    305          
    306          }
   \   0000E5 AC000000              JPF       L:?epilogue_w4
    307          
    308          /**
    309            * @brief  configures the Switch from one clock to another
    310            * @param   CLK_SwitchMode select the clock switch mode.
    311            * It can be set of the values of @ref CLK_SwitchMode_TypeDef
    312            * @param   CLK_NewClock choice of the future clock.
    313            * It can be set of the values of @ref CLK_Source_TypeDef
    314            * @param   NewState Enable or Disable the Clock Switch interrupt.
    315            * @param   CLK_CurrentClockState current clock to switch OFF or to keep ON.
    316            * It can be set of the values of @ref CLK_CurrentClockState_TypeDef
    317            * @retval ErrorStatus this shows the clock switch status (ERROR/SUCCESS).
    318            */

   \                                 In section .far_func.text, align 1
    319          ErrorStatus CLK_ClockSwitchConfig(CLK_SwitchMode_TypeDef CLK_SwitchMode, CLK_Source_TypeDef CLK_NewClock, FunctionalState ITState, CLK_CurrentClockState_TypeDef CLK_CurrentClockState)
    320          {
   \                     CLK_ClockSwitchConfig:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_w6
   \   000008 B700                  LD        S:?b10, A
   \   00000A 450000                MOV       S:?b11, S:?b0
   \   00000D 450000                MOV       S:?b12, S:?b1
   \   000010 450000                MOV       S:?b13, S:?b2
    321          
    322              CLK_Source_TypeDef clock_master;
    323              uint16_t DownCounter = CLK_TIMEOUT;
   \   000013 AE0491                LDW       X, #0x491
   \   000016 BF00                  LDW       S:?w4, X
    324              ErrorStatus Swif = ERROR;
   \   000018 3F00                  CLR       S:?b0
    325          
    326              /* Check the parameters */
    327              assert_param(IS_CLK_SOURCE_OK(CLK_NewClock));
   \   00001A B600                  LD        A, S:?b11
   \   00001C A1E1                  CP        A, #0xe1
   \   00001E 271B                  JREQ      L:??CLK_ClockSwitchConfig_0
   \   000020 B600                  LD        A, S:?b11
   \   000022 A1D2                  CP        A, #0xd2
   \   000024 2715                  JREQ      L:??CLK_ClockSwitchConfig_0
   \   000026 B600                  LD        A, S:?b11
   \   000028 A1B4                  CP        A, #0xb4
   \   00002A 270F                  JREQ      L:??CLK_ClockSwitchConfig_0
   \   00002C AE0147                LDW       X, #0x147
   \   00002F BF00                  LDW       S:?w1, X
   \   000031 5F                    CLRW      X
   \   000032 BF00                  LDW       S:?w0, X
   \   000034 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000037 8D000000              CALLF     assert_failed
    328              assert_param(IS_CLK_SWITCHMODE_OK(CLK_SwitchMode));
   \                     ??CLK_ClockSwitchConfig_0:
   \   00003B 3D00                  TNZ       S:?b10
   \   00003D 2715                  JREQ      L:??CLK_ClockSwitchConfig_1
   \   00003F B600                  LD        A, S:?b10
   \   000041 A101                  CP        A, #0x1
   \   000043 270F                  JREQ      L:??CLK_ClockSwitchConfig_1
   \   000045 AE0148                LDW       X, #0x148
   \   000048 BF00                  LDW       S:?w1, X
   \   00004A 5F                    CLRW      X
   \   00004B BF00                  LDW       S:?w0, X
   \   00004D AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000050 8D000000              CALLF     assert_failed
    329              assert_param(IS_FUNCTIONALSTATE_OK(ITState));
   \                     ??CLK_ClockSwitchConfig_1:
   \   000054 3D00                  TNZ       S:?b12
   \   000056 2715                  JREQ      L:??CLK_ClockSwitchConfig_2
   \   000058 B600                  LD        A, S:?b12
   \   00005A A101                  CP        A, #0x1
   \   00005C 270F                  JREQ      L:??CLK_ClockSwitchConfig_2
   \   00005E AE0149                LDW       X, #0x149
   \   000061 BF00                  LDW       S:?w1, X
   \   000063 5F                    CLRW      X
   \   000064 BF00                  LDW       S:?w0, X
   \   000066 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000069 8D000000              CALLF     assert_failed
    330              assert_param(IS_CLK_CURRENTCLOCKSTATE_OK(CLK_CurrentClockState));
   \                     ??CLK_ClockSwitchConfig_2:
   \   00006D 3D00                  TNZ       S:?b13
   \   00006F 2715                  JREQ      L:??CLK_ClockSwitchConfig_3
   \   000071 B600                  LD        A, S:?b13
   \   000073 A101                  CP        A, #0x1
   \   000075 270F                  JREQ      L:??CLK_ClockSwitchConfig_3
   \   000077 AE014A                LDW       X, #0x14a
   \   00007A BF00                  LDW       S:?w1, X
   \   00007C 5F                    CLRW      X
   \   00007D BF00                  LDW       S:?w0, X
   \   00007F AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000082 8D000000              CALLF     assert_failed
    331          
    332              /* Current clock master saving */
    333              clock_master = (CLK_Source_TypeDef)CLK->CMSR;
   \                     ??CLK_ClockSwitchConfig_3:
   \   000086 C650C3                LD        A, L:0x50c3
   \   000089 B700                  LD        S:?b1, A
    334          
    335              /* Automatic switch mode management */
    336              if (CLK_SwitchMode == CLK_SWITCHMODE_AUTO)
   \   00008B B600                  LD        A, S:?b10
   \   00008D A101                  CP        A, #0x1
   \   00008F 2637                  JRNE      L:??CLK_ClockSwitchConfig_4
    337              {
    338          
    339                  /* Enables Clock switch */
    340                  CLK->SWCR |= CLK_SWCR_SWEN;
   \   000091 721250C5              BSET      L:0x50c5, #0x1
    341          
    342                  /* Enables or Disables Switch interrupt */
    343                  if (ITState != DISABLE)
   \   000095 3D00                  TNZ       S:?b12
   \   000097 2706                  JREQ      L:??CLK_ClockSwitchConfig_5
    344                  {
    345                      CLK->SWCR |= CLK_SWCR_SWIEN;
   \   000099 721450C5              BSET      L:0x50c5, #0x2
   \   00009D 2004                  JRA       L:??CLK_ClockSwitchConfig_6
    346                  }
    347                  else
    348                  {
    349                      CLK->SWCR &= (uint8_t)(~CLK_SWCR_SWIEN);
   \                     ??CLK_ClockSwitchConfig_5:
   \   00009F 721550C5              BRES      L:0x50c5, #0x2
    350                  }
    351          
    352                  /* Selection of the target clock source */
    353                  CLK->SWR = (uint8_t)CLK_NewClock;
   \                     ??CLK_ClockSwitchConfig_6:
   \   0000A3 B600                  LD        A, S:?b11
   \   0000A5 C750C4                LD        L:0x50c4, A
   \   0000A8 2005                  JRA       L:??CLK_ClockSwitchConfig_7
    354          
    355                  while ((((CLK->SWCR & CLK_SWCR_SWBSY) != 0 )&& (DownCounter != 0)))
    356                  {
    357                      DownCounter--;
   \                     ??CLK_ClockSwitchConfig_8:
   \   0000AA BE00                  LDW       X, S:?w4
   \   0000AC 5A                    DECW      X
   \   0000AD BF00                  LDW       S:?w4, X
    358                  }
   \                     ??CLK_ClockSwitchConfig_7:
   \   0000AF 720150C505            BTJF      L:0x50c5, #0x0, L:??CLK_ClockSwitchConfig_9
   \   0000B4 BE00                  LDW       X, S:?w4
   \   0000B6 5D                    TNZW      X
   \   0000B7 26F1                  JRNE      L:??CLK_ClockSwitchConfig_8
    359          
    360                  if (DownCounter != 0)
   \                     ??CLK_ClockSwitchConfig_9:
   \   0000B9 BE00                  LDW       X, S:?w4
   \   0000BB 5D                    TNZW      X
   \   0000BC 2706                  JREQ      L:??CLK_ClockSwitchConfig_10
    361                  {
    362                      Swif = SUCCESS;
   \   0000BE 35010000              MOV       S:?b0, #0x1
   \   0000C2 201B                  JRA       L:??CLK_ClockSwitchConfig_11
    363                  }
    364                  else
    365                  {
    366                      Swif = ERROR;
   \                     ??CLK_ClockSwitchConfig_10:
   \   0000C4 3F00                  CLR       S:?b0
   \   0000C6 2017                  JRA       L:??CLK_ClockSwitchConfig_11
    367                  }
    368          
    369              }
    370              else /* CLK_SwitchMode == CLK_SWITCHMODE_MANUAL */
    371              {
    372          
    373                  /* Enables or Disables Switch interrupt  if required  */
    374                  if (ITState != DISABLE)
   \                     ??CLK_ClockSwitchConfig_4:
   \   0000C8 3D00                  TNZ       S:?b12
   \   0000CA 2706                  JREQ      L:??CLK_ClockSwitchConfig_12
    375                  {
    376                      CLK->SWCR |= CLK_SWCR_SWIEN;
   \   0000CC 721450C5              BSET      L:0x50c5, #0x2
   \   0000D0 2004                  JRA       L:??CLK_ClockSwitchConfig_13
    377                  }
    378                  else
    379                  {
    380                      CLK->SWCR &= (uint8_t)(~CLK_SWCR_SWIEN);
   \                     ??CLK_ClockSwitchConfig_12:
   \   0000D2 721550C5              BRES      L:0x50c5, #0x2
    381                  }
    382          
    383                  /* Selection of the target clock source */
    384                  CLK->SWR = (uint8_t)CLK_NewClock;
   \                     ??CLK_ClockSwitchConfig_13:
   \   0000D6 B600                  LD        A, S:?b11
   \   0000D8 C750C4                LD        L:0x50c4, A
    385          
    386                  /* In manual mode, there is no risk to be stuck in a loop, value returned
    387                    is then always SUCCESS */
    388                  Swif = SUCCESS;
   \   0000DB 35010000              MOV       S:?b0, #0x1
    389          
    390              }
    391          
    392              /* Switch OFF current clock if required */
    393              if ((CLK_CurrentClockState == CLK_CURRENTCLOCKSTATE_DISABLE) && ( clock_master == CLK_SOURCE_HSI))
   \                     ??CLK_ClockSwitchConfig_11:
   \   0000DF 3D00                  TNZ       S:?b13
   \   0000E1 260C                  JRNE      L:??CLK_ClockSwitchConfig_14
   \   0000E3 B600                  LD        A, S:?b1
   \   0000E5 A1E1                  CP        A, #0xe1
   \   0000E7 2606                  JRNE      L:??CLK_ClockSwitchConfig_14
    394              {
    395                  CLK->ICKR &= (uint8_t)(~CLK_ICKR_HSIEN);
   \   0000E9 721150C0              BRES      L:0x50c0, #0x0
   \   0000ED 201E                  JRA       L:??CLK_ClockSwitchConfig_15
    396              }
    397              else if ((CLK_CurrentClockState == CLK_CURRENTCLOCKSTATE_DISABLE) && ( clock_master == CLK_SOURCE_LSI))
   \                     ??CLK_ClockSwitchConfig_14:
   \   0000EF 3D00                  TNZ       S:?b13
   \   0000F1 260C                  JRNE      L:??CLK_ClockSwitchConfig_16
   \   0000F3 B600                  LD        A, S:?b1
   \   0000F5 A1D2                  CP        A, #0xd2
   \   0000F7 2606                  JRNE      L:??CLK_ClockSwitchConfig_16
    398              {
    399                  CLK->ICKR &= (uint8_t)(~CLK_ICKR_LSIEN);
   \   0000F9 721750C0              BRES      L:0x50c0, #0x3
   \   0000FD 200E                  JRA       L:??CLK_ClockSwitchConfig_15
    400              }
    401              else if ((CLK_CurrentClockState == CLK_CURRENTCLOCKSTATE_DISABLE) && ( clock_master == CLK_SOURCE_HSE))
   \                     ??CLK_ClockSwitchConfig_16:
   \   0000FF 3D00                  TNZ       S:?b13
   \   000101 260A                  JRNE      L:??CLK_ClockSwitchConfig_15
   \   000103 B600                  LD        A, S:?b1
   \   000105 A1B4                  CP        A, #0xb4
   \   000107 2604                  JRNE      L:??CLK_ClockSwitchConfig_15
    402              {
    403                  CLK->ECKR &= (uint8_t)(~CLK_ECKR_HSEEN);
   \   000109 721150C1              BRES      L:0x50c1, #0x0
    404              }
    405          
    406              return(Swif);
   \                     ??CLK_ClockSwitchConfig_15:
   \   00010D B600                  LD        A, S:?b0
   \   00010F AC000000              JPF       L:?epilogue_l2_w6
    407          
    408          }
    409          
    410          /**
    411            * @brief  Configures the HSI clock dividers.
    412            * @param   HSIPrescaler : Specifies the HSI clock divider to apply.
    413            * This parameter can be any of the @ref CLK_Prescaler_TypeDef enumeration.
    414            * @retval None
    415            */

   \                                 In section .far_func.text, align 1
    416          void CLK_HSIPrescalerConfig(CLK_Prescaler_TypeDef HSIPrescaler)
    417          {
   \                     CLK_HSIPrescalerConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    418          
    419              /* check the parameters */
    420              assert_param(IS_CLK_HSIPRESCALER_OK(HSIPrescaler));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2721                  JREQ      L:??CLK_HSIPrescalerConfig_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A108                  CP        A, #0x8
   \   00000D 271B                  JREQ      L:??CLK_HSIPrescalerConfig_0
   \   00000F B600                  LD        A, S:?b8
   \   000011 A110                  CP        A, #0x10
   \   000013 2715                  JREQ      L:??CLK_HSIPrescalerConfig_0
   \   000015 B600                  LD        A, S:?b8
   \   000017 A118                  CP        A, #0x18
   \   000019 270F                  JREQ      L:??CLK_HSIPrescalerConfig_0
   \   00001B AE01A4                LDW       X, #0x1a4
   \   00001E BF00                  LDW       S:?w1, X
   \   000020 5F                    CLRW      X
   \   000021 BF00                  LDW       S:?w0, X
   \   000023 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000026 8D000000              CALLF     assert_failed
    421          
    422              /* Clear High speed internal clock prescaler */
    423              CLK->CKDIVR &= (uint8_t)(~CLK_CKDIVR_HSIDIV);
   \                     ??CLK_HSIPrescalerConfig_0:
   \   00002A C650C6                LD        A, L:0x50c6
   \   00002D A4E7                  AND       A, #0xe7
   \   00002F C750C6                LD        L:0x50c6, A
    424          
    425              /* Set High speed internal clock prescaler */
    426              CLK->CKDIVR |= (uint8_t)HSIPrescaler;
   \   000032 B600                  LD        A, S:?b8
   \   000034 CA50C6                OR        A, L:0x50c6
   \   000037 C750C6                LD        L:0x50c6, A
    427          
    428          }
   \   00003A 320000                POP       S:?b8
   \   00003D 87                    RETF
    429          
    430          /**
    431            * @brief  Output the selected clock on a dedicated I/O pin.
    432            * @param   CLK_CCO : Specifies the clock source.
    433            * This parameter can be any of the  @ref CLK_Output_TypeDef enumeration.
    434            * @retval None
    435            * @par Required preconditions:
    436            * The dedicated I/O pin must be set at 1 in the corresponding Px_CR1 register \n
    437            * to be set as input with pull-up or push-pull output.
    438            */

   \                                 In section .far_func.text, align 1
    439          void CLK_CCOConfig(CLK_Output_TypeDef CLK_CCO)
    440          {
   \                     CLK_CCOConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    441          
    442              /* check the parameters */
    443              assert_param(IS_CLK_OUTPUT_OK(CLK_CCO));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2757                  JREQ      L:??CLK_CCOConfig_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A104                  CP        A, #0x4
   \   00000D 2751                  JREQ      L:??CLK_CCOConfig_0
   \   00000F B600                  LD        A, S:?b8
   \   000011 A102                  CP        A, #0x2
   \   000013 274B                  JREQ      L:??CLK_CCOConfig_0
   \   000015 B600                  LD        A, S:?b8
   \   000017 A108                  CP        A, #0x8
   \   000019 2745                  JREQ      L:??CLK_CCOConfig_0
   \   00001B B600                  LD        A, S:?b8
   \   00001D A10A                  CP        A, #0xa
   \   00001F 273F                  JREQ      L:??CLK_CCOConfig_0
   \   000021 B600                  LD        A, S:?b8
   \   000023 A10C                  CP        A, #0xc
   \   000025 2739                  JREQ      L:??CLK_CCOConfig_0
   \   000027 B600                  LD        A, S:?b8
   \   000029 A10E                  CP        A, #0xe
   \   00002B 2733                  JREQ      L:??CLK_CCOConfig_0
   \   00002D B600                  LD        A, S:?b8
   \   00002F A110                  CP        A, #0x10
   \   000031 272D                  JREQ      L:??CLK_CCOConfig_0
   \   000033 B600                  LD        A, S:?b8
   \   000035 A112                  CP        A, #0x12
   \   000037 2727                  JREQ      L:??CLK_CCOConfig_0
   \   000039 B600                  LD        A, S:?b8
   \   00003B A114                  CP        A, #0x14
   \   00003D 2721                  JREQ      L:??CLK_CCOConfig_0
   \   00003F B600                  LD        A, S:?b8
   \   000041 A116                  CP        A, #0x16
   \   000043 271B                  JREQ      L:??CLK_CCOConfig_0
   \   000045 B600                  LD        A, S:?b8
   \   000047 A118                  CP        A, #0x18
   \   000049 2715                  JREQ      L:??CLK_CCOConfig_0
   \   00004B B600                  LD        A, S:?b8
   \   00004D A11A                  CP        A, #0x1a
   \   00004F 270F                  JREQ      L:??CLK_CCOConfig_0
   \   000051 AE01BB                LDW       X, #0x1bb
   \   000054 BF00                  LDW       S:?w1, X
   \   000056 5F                    CLRW      X
   \   000057 BF00                  LDW       S:?w0, X
   \   000059 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00005C 8D000000              CALLF     assert_failed
    444          
    445              /* Clears of the CCO type bits part */
    446              CLK->CCOR &= (uint8_t)(~CLK_CCOR_CCOSEL);
   \                     ??CLK_CCOConfig_0:
   \   000060 C650C9                LD        A, L:0x50c9
   \   000063 A4E1                  AND       A, #0xe1
   \   000065 C750C9                LD        L:0x50c9, A
    447          
    448              /* Selects the source provided on cco_ck output */
    449              CLK->CCOR |= (uint8_t)CLK_CCO;
   \   000068 B600                  LD        A, S:?b8
   \   00006A CA50C9                OR        A, L:0x50c9
   \   00006D C750C9                LD        L:0x50c9, A
    450          
    451              /* Enable the clock output */
    452              CLK->CCOR |= CLK_CCOR_CCOEN;
   \   000070 721050C9              BSET      L:0x50c9, #0x0
    453          
    454          }
   \   000074 320000                POP       S:?b8
   \   000077 87                    RETF
    455          
    456          /**
    457            * @brief   Enables or disables the specified CLK interrupts.
    458            * @param   CLK_IT This parameter specifies the interrupt sources.
    459            * It can be one of the values of @ref CLK_IT_TypeDef.
    460            * @param   NewState New state of the Interrupt.
    461            * Value accepted ENABLE, DISABLE.
    462            * @retval None
    463            */

   \                                 In section .far_func.text, align 1
    464          void CLK_ITConfig(CLK_IT_TypeDef CLK_IT, FunctionalState NewState)
    465          {
   \                     CLK_ITConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
    466          
    467              /* check the parameters */
    468              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000009 3D00                  TNZ       S:?b9
   \   00000B 2715                  JREQ      L:??CLK_ITConfig_0
   \   00000D B600                  LD        A, S:?b9
   \   00000F A101                  CP        A, #0x1
   \   000011 270F                  JREQ      L:??CLK_ITConfig_0
   \   000013 AE01D4                LDW       X, #0x1d4
   \   000016 BF00                  LDW       S:?w1, X
   \   000018 5F                    CLRW      X
   \   000019 BF00                  LDW       S:?w0, X
   \   00001B AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001E 8D000000              CALLF     assert_failed
    469              assert_param(IS_CLK_IT_OK(CLK_IT));
   \                     ??CLK_ITConfig_0:
   \   000022 B600                  LD        A, S:?b8
   \   000024 A10C                  CP        A, #0xc
   \   000026 2715                  JREQ      L:??CLK_ITConfig_1
   \   000028 B600                  LD        A, S:?b8
   \   00002A A11C                  CP        A, #0x1c
   \   00002C 270F                  JREQ      L:??CLK_ITConfig_1
   \   00002E AE01D5                LDW       X, #0x1d5
   \   000031 BF00                  LDW       S:?w1, X
   \   000033 5F                    CLRW      X
   \   000034 BF00                  LDW       S:?w0, X
   \   000036 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000039 8D000000              CALLF     assert_failed
    470          
    471              if (NewState != DISABLE)
   \                     ??CLK_ITConfig_1:
   \   00003D 3D00                  TNZ       S:?b9
   \   00003F 271A                  JREQ      L:??CLK_ITConfig_2
    472              {
    473                  switch (CLK_IT)
   \   000041 B600                  LD        A, S:?b8
   \   000043 A00C                  SUB       A, #0xc
   \   000045 270C                  JREQ      L:??CLK_ITConfig_3
   \   000047 A010                  SUB       A, #0x10
   \   000049 2626                  JRNE      L:??CLK_ITConfig_4
    474                  {
    475                  case CLK_IT_SWIF: /* Enable the clock switch interrupt */
    476                      CLK->SWCR |= CLK_SWCR_SWIEN;
   \   00004B 721450C5              BSET      L:0x50c5, #0x2
    477                      break;
   \   00004F AC000000              JPF       L:?epilogue_w4
    478                  case CLK_IT_CSSD: /* Enable the clock security system detection interrupt */
    479                      CLK->CSSR |= CLK_CSSR_CSSDIE;
   \                     ??CLK_ITConfig_3:
   \   000053 721450C8              BSET      L:0x50c8, #0x2
    480                      break;
   \   000057 AC000000              JPF       L:?epilogue_w4
    481                  default:
    482                      break;
    483                  }
    484              }
    485              else  /*(NewState == DISABLE)*/
    486              {
    487                  switch (CLK_IT)
   \                     ??CLK_ITConfig_2:
   \   00005B B600                  LD        A, S:?b8
   \   00005D A00C                  SUB       A, #0xc
   \   00005F 270C                  JREQ      L:??CLK_ITConfig_5
   \   000061 A010                  SUB       A, #0x10
   \   000063 260C                  JRNE      L:??CLK_ITConfig_4
    488                  {
    489                  case CLK_IT_SWIF: /* Disable the clock switch interrupt */
    490                      CLK->SWCR  &= (uint8_t)(~CLK_SWCR_SWIEN);
   \   000065 721550C5              BRES      L:0x50c5, #0x2
    491                      break;
   \   000069 AC000000              JPF       L:?epilogue_w4
    492                  case CLK_IT_CSSD: /* Disable the clock security system detection interrupt */
    493                      CLK->CSSR &= (uint8_t)(~CLK_CSSR_CSSDIE);
   \                     ??CLK_ITConfig_5:
   \   00006D 721550C8              BRES      L:0x50c8, #0x2
    494                      break;
    495                  default:
    496                      break;
    497                  }
    498              }
    499          
    500          }
   \                     ??CLK_ITConfig_4:
   \   000071 AC000000              JPF       L:?epilogue_w4
    501          
    502          /**
    503            * @brief  Configures the HSI and CPU clock dividers.
    504            * @param   ClockPrescaler Specifies the HSI or CPU clock divider to apply.
    505            * @retval None
    506            */

   \                                 In section .far_func.text, align 1
    507          void CLK_SYSCLKConfig(CLK_Prescaler_TypeDef CLK_Prescaler)
    508          {
   \                     CLK_SYSCLKConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    509          
    510              /* check the parameters */
    511              assert_param(IS_CLK_PRESCALER_OK(CLK_Prescaler));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2751                  JREQ      L:??CLK_SYSCLKConfig_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A108                  CP        A, #0x8
   \   00000D 274B                  JREQ      L:??CLK_SYSCLKConfig_0
   \   00000F B600                  LD        A, S:?b8
   \   000011 A110                  CP        A, #0x10
   \   000013 2745                  JREQ      L:??CLK_SYSCLKConfig_0
   \   000015 B600                  LD        A, S:?b8
   \   000017 A118                  CP        A, #0x18
   \   000019 273F                  JREQ      L:??CLK_SYSCLKConfig_0
   \   00001B B600                  LD        A, S:?b8
   \   00001D A180                  CP        A, #0x80
   \   00001F 2739                  JREQ      L:??CLK_SYSCLKConfig_0
   \   000021 B600                  LD        A, S:?b8
   \   000023 A181                  CP        A, #0x81
   \   000025 2733                  JREQ      L:??CLK_SYSCLKConfig_0
   \   000027 B600                  LD        A, S:?b8
   \   000029 A182                  CP        A, #0x82
   \   00002B 272D                  JREQ      L:??CLK_SYSCLKConfig_0
   \   00002D B600                  LD        A, S:?b8
   \   00002F A183                  CP        A, #0x83
   \   000031 2727                  JREQ      L:??CLK_SYSCLKConfig_0
   \   000033 B600                  LD        A, S:?b8
   \   000035 A184                  CP        A, #0x84
   \   000037 2721                  JREQ      L:??CLK_SYSCLKConfig_0
   \   000039 B600                  LD        A, S:?b8
   \   00003B A185                  CP        A, #0x85
   \   00003D 271B                  JREQ      L:??CLK_SYSCLKConfig_0
   \   00003F B600                  LD        A, S:?b8
   \   000041 A186                  CP        A, #0x86
   \   000043 2715                  JREQ      L:??CLK_SYSCLKConfig_0
   \   000045 B600                  LD        A, S:?b8
   \   000047 A187                  CP        A, #0x87
   \   000049 270F                  JREQ      L:??CLK_SYSCLKConfig_0
   \   00004B AE01FF                LDW       X, #0x1ff
   \   00004E BF00                  LDW       S:?w1, X
   \   000050 5F                    CLRW      X
   \   000051 BF00                  LDW       S:?w0, X
   \   000053 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000056 8D000000              CALLF     assert_failed
    512          
    513              if (((uint8_t)CLK_Prescaler & (uint8_t)0x80) == 0x00) /* Bit7 = 0 means HSI divider */
   \                     ??CLK_SYSCLKConfig_0:
   \   00005A B600                  LD        A, S:?b8
   \   00005C A480                  AND       A, #0x80
   \   00005E A100                  CP        A, #0x0
   \   000060 2614                  JRNE      L:??CLK_SYSCLKConfig_1
    514              {
    515                  CLK->CKDIVR &= (uint8_t)(~CLK_CKDIVR_HSIDIV);
   \   000062 C650C6                LD        A, L:0x50c6
   \   000065 A4E7                  AND       A, #0xe7
   \   000067 C750C6                LD        L:0x50c6, A
    516                  CLK->CKDIVR |= (uint8_t)((uint8_t)CLK_Prescaler & (uint8_t)CLK_CKDIVR_HSIDIV);
   \   00006A B600                  LD        A, S:?b8
   \   00006C A418                  AND       A, #0x18
   \   00006E CA50C6                OR        A, L:0x50c6
   \   000071 C750C6                LD        L:0x50c6, A
   \   000074 2012                  JRA       L:??CLK_SYSCLKConfig_2
    517              }
    518              else /* Bit7 = 1 means CPU divider */
    519              {
    520                  CLK->CKDIVR &= (uint8_t)(~CLK_CKDIVR_CPUDIV);
   \                     ??CLK_SYSCLKConfig_1:
   \   000076 C650C6                LD        A, L:0x50c6
   \   000079 A4F8                  AND       A, #0xf8
   \   00007B C750C6                LD        L:0x50c6, A
    521                  CLK->CKDIVR |= (uint8_t)((uint8_t)CLK_Prescaler & (uint8_t)CLK_CKDIVR_CPUDIV);
   \   00007E B600                  LD        A, S:?b8
   \   000080 A407                  AND       A, #0x7
   \   000082 CA50C6                OR        A, L:0x50c6
   \   000085 C750C6                LD        L:0x50c6, A
    522              }
    523          
    524          }
   \                     ??CLK_SYSCLKConfig_2:
   \   000088 320000                POP       S:?b8
   \   00008B 87                    RETF
    525          /**
    526            * @brief  Configures the SWIM clock frequency on the fly.
    527            * @param   CLK_SWIMDivider Specifies the SWIM clock divider to apply.
    528            * can be one of the value of @ref CLK_SWIMDivider_TypeDef
    529            * @retval None
    530            */

   \                                 In section .far_func.text, align 1
    531          void CLK_SWIMConfig(CLK_SWIMDivider_TypeDef CLK_SWIMDivider)
    532          {
   \                     CLK_SWIMConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    533          
    534              /* check the parameters */
    535              assert_param(IS_CLK_SWIMDIVIDER_OK(CLK_SWIMDivider));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??CLK_SWIMConfig_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??CLK_SWIMConfig_0
   \   00000F AE0217                LDW       X, #0x217
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    536          
    537              if (CLK_SWIMDivider != CLK_SWIMDIVIDER_2)
   \                     ??CLK_SWIMConfig_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??CLK_SWIMConfig_1
    538              {
    539                  /* SWIM clock is not divided by 2 */
    540                  CLK->SWIMCCR |= CLK_SWIMCCR_SWIMDIV;
   \   000022 721050CD              BSET      L:0x50cd, #0x0
   \   000026 2004                  JRA       L:??CLK_SWIMConfig_2
    541              }
    542              else /* CLK_SWIMDivider == CLK_SWIMDIVIDER_2 */
    543              {
    544                  /* SWIM clock is divided by 2 */
    545                  CLK->SWIMCCR &= (uint8_t)(~CLK_SWIMCCR_SWIMDIV);
   \                     ??CLK_SWIMConfig_1:
   \   000028 721150CD              BRES      L:0x50cd, #0x0
    546              }
    547          
    548          }
   \                     ??CLK_SWIMConfig_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    549          
    550          /**
    551            * @brief  Enables the Clock Security System.
    552            * @par Full description:
    553            * once CSS is enabled it cannot be disabled until the next reset.
    554            * @param  None
    555            * @retval None
    556            */

   \                                 In section .far_func.text, align 1
    557          void CLK_ClockSecuritySystemEnable(void)
    558          {
    559              /* Set CSSEN bit */
    560              CLK->CSSR |= CLK_CSSR_CSSEN;
   \                     CLK_ClockSecuritySystemEnable:
   \   000000 721050C8              BSET      L:0x50c8, #0x0
    561          }
   \   000004 87                    RETF
    562          
    563          /**
    564            * @brief  Returns the clock source used as system clock.
    565            * @param  None
    566            * @retval  Clock source used.
    567            * can be one of the values of @ref CLK_Source_TypeDef
    568            */

   \                                 In section .far_func.text, align 1
    569          CLK_Source_TypeDef CLK_GetSYSCLKSource(void)
    570          {
    571              return((CLK_Source_TypeDef)CLK->CMSR);
   \                     CLK_GetSYSCLKSource:
   \   000000 C650C3                LD        A, L:0x50c3
   \   000003 87                    RETF
    572          }
    573          
    574          /**
    575            * @brief  This function returns the frequencies of different on chip clocks.
    576            * @param  None
    577            * @retval the master clock frequency
    578            */

   \                                 In section .far_func.text, align 1
    579          uint32_t CLK_GetClockFreq(void)
    580          {
    581          
    582              uint32_t clockfrequency = 0;
   \                     CLK_GetClockFreq:
   \   000000 5F                    CLRW      X
   \   000001 BF00                  LDW       S:?w1, X
   \   000003 BF00                  LDW       S:?w0, X
    583              CLK_Source_TypeDef clocksource = CLK_SOURCE_HSI;
   \   000005 35E10000              MOV       S:?b6, #0xe1
    584              uint8_t tmp = 0, presc = 0;
   \   000009 3F00                  CLR       S:?b5
   \   00000B 3F00                  CLR       S:?b4
    585          
    586              /* Get CLK source. */
    587              clocksource = (CLK_Source_TypeDef)CLK->CMSR;
   \   00000D C650C3                LD        A, L:0x50c3
   \   000010 B700                  LD        S:?b6, A
    588          
    589              if (clocksource == CLK_SOURCE_HSI)
   \   000012 B600                  LD        A, S:?b6
   \   000014 A1E1                  CP        A, #0xe1
   \   000016 262B                  JRNE      L:??CLK_GetClockFreq_0
    590              {
    591                  tmp = (uint8_t)(CLK->CKDIVR & CLK_CKDIVR_HSIDIV);
   \   000018 C650C6                LD        A, L:0x50c6
   \   00001B A418                  AND       A, #0x18
   \   00001D B700                  LD        S:?b5, A
    592                  tmp = (uint8_t)(tmp >> 3);
   \   00001F B600                  LD        A, S:?b5
   \   000021 44                    SRL       A
   \   000022 44                    SRL       A
   \   000023 44                    SRL       A
   \   000024 B700                  LD        S:?b5, A
    593                  presc = HSIDivFactor[tmp];
   \   000026 5F                    CLRW      X
   \   000027 41                    EXG       A, XL
   \   000028 B600                  LD        A, S:?b5
   \   00002A 41                    EXG       A, XL
   \   00002B D60000                LD        A, (L:HSIDivFactor,X)
   \   00002E B700                  LD        S:?b4, A
    594                  clockfrequency = HSI_VALUE / presc;
   \   000030 5F                    CLRW      X
   \   000031 41                    EXG       A, XL
   \   000032 B600                  LD        A, S:?b4
   \   000034 41                    EXG       A, XL
   \   000035 BF00                  LDW       S:?w3, X
   \   000037 5F                    CLRW      X
   \   000038 BF00                  LDW       S:?w2, X
   \   00003A 8D000000              CALLF     L:?udiv32_l0_dl_l1
   \   00003E 00F42400              DC32      0xf42400
   \   000042 87                    RETF
    595              }
    596              else if ( clocksource == CLK_SOURCE_LSI)
   \                     ??CLK_GetClockFreq_0:
   \   000043 B600                  LD        A, S:?b6
   \   000045 A1D2                  CP        A, #0xd2
   \   000047 260A                  JRNE      L:??CLK_GetClockFreq_1
    597              {
    598                  clockfrequency = LSI_VALUE;
   \   000049 AEF400                LDW       X, #0xf400
   \   00004C BF00                  LDW       S:?w1, X
   \   00004E 5F                    CLRW      X
   \   00004F 5C                    INCW      X
   \   000050 BF00                  LDW       S:?w0, X
   \   000052 87                    RETF
    599              }
    600              else
    601              {
    602                  clockfrequency = HSE_VALUE;
   \                     ??CLK_GetClockFreq_1:
   \   000053 AE2400                LDW       X, #0x2400
   \   000056 BF00                  LDW       S:?w1, X
   \   000058 AE00F4                LDW       X, #0xf4
   \   00005B BF00                  LDW       S:?w0, X
    603              }
    604          
    605              return((uint32_t)clockfrequency);
   \   00005D 87                    RETF
    606          
    607          }
    608          
    609          /**
    610            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    611            * @par Full description:
    612            * @param   CLK_HSICalibrationValue calibration trimming value.
    613            * can be one of the values of @ref CLK_HSITrimValue_TypeDef
    614            * @retval None
    615            */

   \                                 In section .far_func.text, align 1
    616          void CLK_AdjustHSICalibrationValue(CLK_HSITrimValue_TypeDef CLK_HSICalibrationValue)
    617          {
   \                     CLK_AdjustHSICalibrationValue:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    618          
    619              /* check the parameters */
    620              assert_param(IS_CLK_HSITRIMVALUE_OK(CLK_HSICalibrationValue));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2739                  JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 2733                  JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   00000F B600                  LD        A, S:?b8
   \   000011 A102                  CP        A, #0x2
   \   000013 272D                  JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   000015 B600                  LD        A, S:?b8
   \   000017 A103                  CP        A, #0x3
   \   000019 2727                  JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   00001B B600                  LD        A, S:?b8
   \   00001D A104                  CP        A, #0x4
   \   00001F 2721                  JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   000021 B600                  LD        A, S:?b8
   \   000023 A105                  CP        A, #0x5
   \   000025 271B                  JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   000027 B600                  LD        A, S:?b8
   \   000029 A106                  CP        A, #0x6
   \   00002B 2715                  JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   00002D B600                  LD        A, S:?b8
   \   00002F A107                  CP        A, #0x7
   \   000031 270F                  JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   000033 AE026C                LDW       X, #0x26c
   \   000036 BF00                  LDW       S:?w1, X
   \   000038 5F                    CLRW      X
   \   000039 BF00                  LDW       S:?w0, X
   \   00003B AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00003E 8D000000              CALLF     assert_failed
    621          
    622              /* Store the new value */
    623              CLK->HSITRIMR = (uint8_t)( (uint8_t)(CLK->HSITRIMR & (uint8_t)(~CLK_HSITRIMR_HSITRIM))|((uint8_t)CLK_HSICalibrationValue));
   \                     ??CLK_AdjustHSICalibrationValue_0:
   \   000042 C650CC                LD        A, L:0x50cc
   \   000045 A4F8                  AND       A, #0xf8
   \   000047 BA00                  OR        A, S:?b8
   \   000049 C750CC                LD        L:0x50cc, A
    624          
    625          }
   \   00004C 320000                POP       S:?b8
   \   00004F 87                    RETF
    626          
    627          /**
    628            * @brief  Reset the SWBSY flag (SWICR Reister)
    629            * @par Full description:
    630            * This function reset SWBSY flag in order to reset clock switch operations (target
    631            * oscillator is broken, stabilization is longing too much, etc.).  If at the same time \n
    632            * software attempts to set SWEN and clear SWBSY, SWBSY action takes precedence.
    633            * @param  None
    634            * @retval None
    635            */

   \                                 In section .far_func.text, align 1
    636          void CLK_SYSCLKEmergencyClear(void)
    637          {
    638              CLK->SWCR &= (uint8_t)(~CLK_SWCR_SWBSY);
   \                     CLK_SYSCLKEmergencyClear:
   \   000000 721150C5              BRES      L:0x50c5, #0x0
    639          }
   \   000004 87                    RETF
    640          
    641          /**
    642            * @brief  Checks whether the specified CLK flag is set or not.
    643            * @par Full description:
    644            * @param   CLK_FLAG Flag to check.
    645            * can be one of the values of @ref CLK_Flag_TypeDef
    646            * @retval FlagStatus, status of the checked flag
    647            */

   \                                 In section .far_func.text, align 1
    648          FlagStatus CLK_GetFlagStatus(CLK_Flag_TypeDef CLK_FLAG)
    649          {
   \                     CLK_GetFlagStatus:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    650          
    651              uint16_t statusreg = 0;
   \   000006 5F                    CLRW      X
    652              uint8_t tmpreg = 0;
   \   000007 3F00                  CLR       S:?b0
    653              FlagStatus bitstatus = RESET;
   \   000009 4F                    CLR       A
    654          
    655              /* check the parameters */
    656              assert_param(IS_CLK_FLAG_OK(CLK_FLAG));
   \   00000A 90BE00                LDW       Y, S:?w4
   \   00000D 90A30110              CPW       Y, #0x110
   \   000011 2747                  JREQ      L:??CLK_GetFlagStatus_0
   \   000013 BE00                  LDW       X, S:?w4
   \   000015 A30102                CPW       X, #0x102
   \   000018 2740                  JREQ      L:??CLK_GetFlagStatus_0
   \   00001A BE00                  LDW       X, S:?w4
   \   00001C A30202                CPW       X, #0x202
   \   00001F 2739                  JREQ      L:??CLK_GetFlagStatus_0
   \   000021 BE00                  LDW       X, S:?w4
   \   000023 A30308                CPW       X, #0x308
   \   000026 2732                  JREQ      L:??CLK_GetFlagStatus_0
   \   000028 BE00                  LDW       X, S:?w4
   \   00002A A30301                CPW       X, #0x301
   \   00002D 272B                  JREQ      L:??CLK_GetFlagStatus_0
   \   00002F BE00                  LDW       X, S:?w4
   \   000031 A30408                CPW       X, #0x408
   \   000034 2724                  JREQ      L:??CLK_GetFlagStatus_0
   \   000036 BE00                  LDW       X, S:?w4
   \   000038 A30402                CPW       X, #0x402
   \   00003B 271D                  JREQ      L:??CLK_GetFlagStatus_0
   \   00003D BE00                  LDW       X, S:?w4
   \   00003F A30504                CPW       X, #0x504
   \   000042 2716                  JREQ      L:??CLK_GetFlagStatus_0
   \   000044 BE00                  LDW       X, S:?w4
   \   000046 A30502                CPW       X, #0x502
   \   000049 270F                  JREQ      L:??CLK_GetFlagStatus_0
   \   00004B AE0290                LDW       X, #0x290
   \   00004E BF00                  LDW       S:?w1, X
   \   000050 5F                    CLRW      X
   \   000051 BF00                  LDW       S:?w0, X
   \   000053 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000056 8D000000              CALLF     assert_failed
    657          
    658              /* Get the CLK register index */
    659              statusreg = (uint16_t)((uint16_t)CLK_FLAG & (uint16_t)0xFF00);
   \                     ??CLK_GetFlagStatus_0:
   \   00005A BE00                  LDW       X, S:?w4
   \   00005C 02                    RLWA      X, A
   \   00005D A4FF                  AND       A, #0xff
   \   00005F 02                    RLWA      X, A
   \   000060 A400                  AND       A, #0x0
   \   000062 02                    RLWA      X, A
    660          
    661          
    662              if (statusreg == 0x0100) /* The flag to check is in ICKRregister */
   \   000063 A30100                CPW       X, #0x100
   \   000066 2607                  JRNE      L:??CLK_GetFlagStatus_1
    663              {
    664                  tmpreg = CLK->ICKR;
   \   000068 C650C0                LD        A, L:0x50c0
   \   00006B B700                  LD        S:?b0, A
   \   00006D 2029                  JRA       L:??CLK_GetFlagStatus_2
    665              }
    666              else if (statusreg == 0x0200) /* The flag to check is in ECKRregister */
   \                     ??CLK_GetFlagStatus_1:
   \   00006F A30200                CPW       X, #0x200
   \   000072 2607                  JRNE      L:??CLK_GetFlagStatus_3
    667              {
    668                  tmpreg = CLK->ECKR;
   \   000074 C650C1                LD        A, L:0x50c1
   \   000077 B700                  LD        S:?b0, A
   \   000079 201D                  JRA       L:??CLK_GetFlagStatus_2
    669              }
    670              else if (statusreg == 0x0300) /* The flag to check is in SWIC register */
   \                     ??CLK_GetFlagStatus_3:
   \   00007B A30300                CPW       X, #0x300
   \   00007E 2607                  JRNE      L:??CLK_GetFlagStatus_4
    671              {
    672                  tmpreg = CLK->SWCR;
   \   000080 C650C5                LD        A, L:0x50c5
   \   000083 B700                  LD        S:?b0, A
   \   000085 2011                  JRA       L:??CLK_GetFlagStatus_2
    673              }
    674              else if (statusreg == 0x0400) /* The flag to check is in CSS register */
   \                     ??CLK_GetFlagStatus_4:
   \   000087 A30400                CPW       X, #0x400
   \   00008A 2607                  JRNE      L:??CLK_GetFlagStatus_5
    675              {
    676                  tmpreg = CLK->CSSR;
   \   00008C C650C8                LD        A, L:0x50c8
   \   00008F B700                  LD        S:?b0, A
   \   000091 2005                  JRA       L:??CLK_GetFlagStatus_2
    677              }
    678              else /* The flag to check is in CCO register */
    679              {
    680                  tmpreg = CLK->CCOR;
   \                     ??CLK_GetFlagStatus_5:
   \   000093 C650C9                LD        A, L:0x50c9
   \   000096 B700                  LD        S:?b0, A
    681              }
    682          
    683              if ((tmpreg & (uint8_t)CLK_FLAG) != (uint8_t)RESET)
   \                     ??CLK_GetFlagStatus_2:
   \   000098 B600                  LD        A, S:?b9
   \   00009A B400                  AND       A, S:?b0
   \   00009C A100                  CP        A, #0x0
   \   00009E 2706                  JREQ      L:??CLK_GetFlagStatus_6
    684              {
    685                  bitstatus = SET;
   \   0000A0 A601                  LD        A, #0x1
   \   0000A2 AC000000              JPF       L:?epilogue_w4
    686              }
    687              else
    688              {
    689                  bitstatus = RESET;
   \                     ??CLK_GetFlagStatus_6:
   \   0000A6 4F                    CLR       A
    690              }
    691          
    692              /* Return the flag status */
    693              return((FlagStatus)bitstatus);
   \   0000A7 AC000000              JPF       L:?epilogue_w4
    694          
    695          }
    696          
    697          /**
    698            * @brief  Checks whether the specified CLK interrupt has is enabled or not.
    699            * @param   CLK_IT specifies the CLK interrupt.
    700            * can be one of the values of @ref CLK_IT_TypeDef
    701            * @retval ITStatus, new state of CLK_IT (SET or RESET).
    702            */

   \                                 In section .far_func.text, align 1
    703          ITStatus CLK_GetITStatus(CLK_IT_TypeDef CLK_IT)
    704          {
   \                     CLK_GetITStatus:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    705          
    706              ITStatus bitstatus = RESET;
   \   000005 3F00                  CLR       S:?b0
    707          
    708              /* check the parameters */
    709              assert_param(IS_CLK_IT_OK(CLK_IT));
   \   000007 B600                  LD        A, S:?b8
   \   000009 A10C                  CP        A, #0xc
   \   00000B 2715                  JREQ      L:??CLK_GetITStatus_0
   \   00000D B600                  LD        A, S:?b8
   \   00000F A11C                  CP        A, #0x1c
   \   000011 270F                  JREQ      L:??CLK_GetITStatus_0
   \   000013 AE02C5                LDW       X, #0x2c5
   \   000016 BF00                  LDW       S:?w1, X
   \   000018 5F                    CLRW      X
   \   000019 BF00                  LDW       S:?w0, X
   \   00001B AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001E 8D000000              CALLF     assert_failed
    710          
    711              if (CLK_IT == CLK_IT_SWIF)
   \                     ??CLK_GetITStatus_0:
   \   000022 B600                  LD        A, S:?b8
   \   000024 A11C                  CP        A, #0x1c
   \   000026 2613                  JRNE      L:??CLK_GetITStatus_1
    712              {
    713                  /* Check the status of the clock switch interrupt */
    714                  if ((CLK->SWCR & (uint8_t)CLK_IT) == (uint8_t)0x0C)
   \   000028 B600                  LD        A, S:?b8
   \   00002A C450C5                AND       A, L:0x50c5
   \   00002D A10C                  CP        A, #0xc
   \   00002F 2606                  JRNE      L:??CLK_GetITStatus_2
    715                  {
    716                      bitstatus = SET;
   \   000031 35010000              MOV       S:?b0, #0x1
   \   000035 2015                  JRA       L:??CLK_GetITStatus_3
    717                  }
    718                  else
    719                  {
    720                      bitstatus = RESET;
   \                     ??CLK_GetITStatus_2:
   \   000037 3F00                  CLR       S:?b0
   \   000039 2011                  JRA       L:??CLK_GetITStatus_3
    721                  }
    722              }
    723              else /* CLK_IT == CLK_IT_CSSDIE */
    724              {
    725                  /* Check the status of the security system detection interrupt */
    726                  if ((CLK->CSSR & (uint8_t)CLK_IT) == (uint8_t)0x0C)
   \                     ??CLK_GetITStatus_1:
   \   00003B B600                  LD        A, S:?b8
   \   00003D C450C8                AND       A, L:0x50c8
   \   000040 A10C                  CP        A, #0xc
   \   000042 2606                  JRNE      L:??CLK_GetITStatus_4
    727                  {
    728                      bitstatus = SET;
   \   000044 35010000              MOV       S:?b0, #0x1
   \   000048 2002                  JRA       L:??CLK_GetITStatus_3
    729                  }
    730                  else
    731                  {
    732                      bitstatus = RESET;
   \                     ??CLK_GetITStatus_4:
   \   00004A 3F00                  CLR       S:?b0
    733                  }
    734              }
    735          
    736              /* Return the CLK_IT status */
    737              return bitstatus;
   \                     ??CLK_GetITStatus_3:
   \   00004C B600                  LD        A, S:?b0
   \   00004E 320000                POP       S:?b8
   \   000051 87                    RETF
    738          
    739          }
    740          
    741          /**
    742            * @brief  Clears the CLKs interrupt pending bits.
    743            * @param   CLK_IT specifies the interrupt pending bits.
    744            * can be one of the values of @ref CLK_IT_TypeDef
    745            * @retval None
    746            */

   \                                 In section .far_func.text, align 1
    747          void CLK_ClearITPendingBit(CLK_IT_TypeDef CLK_IT)
    748          {
   \                     CLK_ClearITPendingBit:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    749          
    750              /* check the parameters */
    751              assert_param(IS_CLK_IT_OK(CLK_IT));
   \   000005 B600                  LD        A, S:?b8
   \   000007 A10C                  CP        A, #0xc
   \   000009 2715                  JREQ      L:??CLK_ClearITPendingBit_0
   \   00000B B600                  LD        A, S:?b8
   \   00000D A11C                  CP        A, #0x1c
   \   00000F 270F                  JREQ      L:??CLK_ClearITPendingBit_0
   \   000011 AE02EF                LDW       X, #0x2ef
   \   000014 BF00                  LDW       S:?w1, X
   \   000016 5F                    CLRW      X
   \   000017 BF00                  LDW       S:?w0, X
   \   000019 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001C 8D000000              CALLF     assert_failed
    752          
    753              if (CLK_IT == (uint8_t)CLK_IT_CSSD)
   \                     ??CLK_ClearITPendingBit_0:
   \   000020 B600                  LD        A, S:?b8
   \   000022 A10C                  CP        A, #0xc
   \   000024 2606                  JRNE      L:??CLK_ClearITPendingBit_1
    754              {
    755                  /* Clear the status of the security system detection interrupt */
    756                  CLK->CSSR &= (uint8_t)(~CLK_CSSR_CSSD);
   \   000026 721750C8              BRES      L:0x50c8, #0x3
   \   00002A 2004                  JRA       L:??CLK_ClearITPendingBit_2
    757              }
    758              else /* CLK_PendingBit == (uint8_t)CLK_IT_SWIF */
    759              {
    760                  /* Clear the status of the clock switch interrupt */
    761                  CLK->SWCR &= (uint8_t)(~CLK_SWCR_SWIF);
   \                     ??CLK_ClearITPendingBit_1:
   \   00002C 721750C5              BRES      L:0x50c5, #0x3
    762              }
    763          
    764          }
   \                     ??CLK_ClearITPendingBit_2:
   \   000030 320000                POP       S:?b8
   \   000033 87                    RETF

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "D:\\\\Project\\\\STM8S_StdP...">`:
   \   000000 443A5C50726F          DC8 44H, 3AH, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \   000008 63745C53544D          DC8 63H, 74H, 5CH, 53H, 54H, 4DH, 38H, 53H
   \   000010 5F5374645065          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \   000018 70685F4C6962          DC8 70H, 68H, 5FH, 4CH, 69H, 62H, 5FH, 56H
   \   000020 322E312E305C          DC8 32H, 2EH, 31H, 2EH, 30H, 5CH, 4CH, 69H
   \   000028 627261726965          DC8 62H, 72H, 61H, 72H, 69H, 65H, 73H, 5CH
   \   000030 53544D38535F          DC8 53H, 54H, 4DH, 38H, 53H, 5FH, 53H, 74H
   \   000038 645065726970          DC8 64H, 50H, 65H, 72H, 69H, 70H, 68H, 5FH
   \   000040 447269766572          DC8 44H, 72H, 69H, 76H, 65H, 72H, 5CH, 73H
   \   000048 72635C73746D          DC8 72H, 63H, 5CH, 73H, 74H, 6DH, 38H, 73H
   \   000050 5F636C6B2E63          DC8 5FH, 63H, 6CH, 6BH, 2EH, 63H, 0
    765          /**
    766            * @}
    767            */
    768            
    769          /**
    770            * @}
    771            */
    772            
    773          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     HSIDivFactor                                4
     CLKPrescTable                               8
     CLK_DeInit                                 54
     CLK_FastHaltWakeUpCmd                      48
     CLK_HSECmd                                 48
     CLK_HSICmd                                 48
     CLK_LSICmd                                 48
     CLK_CCOCmd                                 48
     CLK_ClockSwitchCmd                         48
     CLK_SlowActiveHaltWakeUpCmd                48
     CLK_PeripheralClockConfig                 233
     CLK_ClockSwitchConfig                     275
     CLK_HSIPrescalerConfig                     62
     CLK_CCOConfig                             120
     CLK_ITConfig                              117
     CLK_SYSCLKConfig                          140
     CLK_SWIMConfig                             48
     CLK_ClockSecuritySystemEnable               5
     CLK_GetSYSCLKSource                         4
     CLK_GetClockFreq                           94
     CLK_AdjustHSICalibrationValue              80
     CLK_SYSCLKEmergencyClear                    5
     CLK_GetFlagStatus                         171
     CLK_GetITStatus                            82
     CLK_ClearITPendingBit                      52
     ?<Constant "D:\\Project\\STM8S_StdP...">   87

 
 1 878 bytes in section .far_func.text
    99 bytes in section .near.rodata
 
 1 878 bytes of CODE  memory
    99 bytes of CONST memory

Errors: none
Warnings: none
