###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             24/Jan/2015  12:33:13 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_St #
#                    dPeriph_Driver\src\stm8s_flash.c                         #
#    Command line =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_St #
#                    dPeriph_Driver\src\stm8s_flash.c -e -Ol --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_cross_call --debug --code_model medium              #
#                    --data_model medium -o D:\Project\STM8S_StdPeriph_Lib_V2 #
#                    .1.0\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S208\Ob #
#                    j\ --dlib_config "C:\Program Files\IAR Systems\Embedded  #
#                    Workbench 6.0\stm8\LIB\dlstm8mmn.h" -D                   #
#                    USE_STM8_128_EVAL -D STM8S003 -lC                        #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\ -lb                 #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\ -I                  #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\ -I                             #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\..\..\Libraries\STM8S_StdPeriph #
#                    _Driver\inc\ -I D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Pr #
#                    oject\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Utilities #
#                    \STM8S_EVAL\ -I D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Pr #
#                    oject\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Utilities #
#                    \STM8S_EVAL\STM8S-128_EVAL\ -I                           #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\..\..\Utilities\STM8S_EVAL\Comm #
#                    on\ --vregs 16                                           #
#    List file    =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\stm8s_flash.lst      #
#    Object file  =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\Obj\stm8s_flash.o         #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_StdPeriph_Driver\src\stm8s_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_flash.c
      4            * @author  MCD Application Team
      5          	* @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the FLASH peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_flash.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28          /**
     29          @code
     30           This driver provides functions to configure and program the Flash memory of all
     31           STM8S devices.
     32          
     33           It includes as well functions that can be either executed from RAM or not, and
     34           other functions that must be executed from RAM otherwise useless.
     35          
     36           The table below lists the functions that can be executed from RAM.
     37          
     38           +--------------------------------------------------------------------------------|
     39           |   Functions prototypes      |    RAM execution            |     Comments       |
     40           ---------------------------------------------------------------------------------|
     41           |                             | Mandatory in case of block  | Can be executed    |
     42           | FLASH_WaitForLastOperation  | Operation:                  | from Flash in case |
     43           |                             | - Block programming         | of byte and word   |
     44           |                             | - Block erase               | Operations         |
     45           |--------------------------------------------------------------------------------|
     46           | FLASH_ProgramBlock          |       Exclusively           | useless from Flash |
     47           |--------------------------------------------------------------------------------|
     48           | FLASH_EraseBlock            |       Exclusively           | useless from Flash |
     49           |--------------------------------------------------------------------------------|
     50          
     51           To be able to execute functions from RAM several steps have to be followed.
     52           These steps may differ from one toolchain to another.
     53           A detailed description is available below within this driver.
     54           You can also refer to the FLASH examples provided within the
     55           STM8S_StdPeriph_Lib package.
     56          
     57          @endcode
     58          */
     59          
     60          
     61          /* Private typedef -----------------------------------------------------------*/
     62          /* Private define ------------------------------------------------------------*/
     63          #define FLASH_CLEAR_BYTE ((uint8_t)0x00)
     64          #define FLASH_SET_BYTE  ((uint8_t)0xFF)
     65          #define OPERATION_TIMEOUT  ((uint32_t)0xFFFFF)
     66          /* Private macro -------------------------------------------------------------*/
     67          /* Private variables ---------------------------------------------------------*/
     68          /* Private function prototypes -----------------------------------------------*/
     69          /* Private Constants ---------------------------------------------------------*/
     70          
     71          /** @addtogroup FLASH_Public_functions
     72            * @{
     73            */
     74          
     75          /**
     76            * @brief   Unlocks the program or data EEPROM memory
     77            * @param  FLASH_MemType : Memory type to unlock
     78            *         This parameter can be a value of @ref FLASH_MemType_TypeDef
     79            * @retval None
     80            */

   \                                 In section .far_func.text, align 1
     81          void FLASH_Unlock(FLASH_MemType_TypeDef FLASH_MemType)
     82          {
   \                     FLASH_Unlock:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
     83              /* Check parameter */
     84              assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   000005 B600                  LD        A, S:?b8
   \   000007 A1FD                  CP        A, #0xfd
   \   000009 2715                  JREQ      L:??FLASH_Unlock_0
   \   00000B B600                  LD        A, S:?b8
   \   00000D A1F7                  CP        A, #0xf7
   \   00000F 270F                  JREQ      L:??FLASH_Unlock_0
   \   000011 AE0054                LDW       X, #0x54
   \   000014 BF00                  LDW       S:?w1, X
   \   000016 5F                    CLRW      X
   \   000017 BF00                  LDW       S:?w0, X
   \   000019 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001C 8D000000              CALLF     assert_failed
     85          
     86              /* Unlock program memory */
     87              if (FLASH_MemType == FLASH_MEMTYPE_PROG)
   \                     ??FLASH_Unlock_0:
   \   000020 B600                  LD        A, S:?b8
   \   000022 A1FD                  CP        A, #0xfd
   \   000024 260A                  JRNE      L:??FLASH_Unlock_1
     88              {
     89                  FLASH->PUKR = FLASH_RASS_KEY1;
   \   000026 35565062              MOV       L:0x5062, #0x56
     90                  FLASH->PUKR = FLASH_RASS_KEY2;
   \   00002A 35AE5062              MOV       L:0x5062, #0xae
   \   00002E 2008                  JRA       L:??FLASH_Unlock_2
     91              }
     92              /* Unlock data memory */
     93              else
     94              {
     95                  FLASH->DUKR = FLASH_RASS_KEY2; /* Warning: keys are reversed on data memory !!! */
   \                     ??FLASH_Unlock_1:
   \   000030 35AE5064              MOV       L:0x5064, #0xae
     96                  FLASH->DUKR = FLASH_RASS_KEY1;
   \   000034 35565064              MOV       L:0x5064, #0x56
     97              }
     98          }
   \                     ??FLASH_Unlock_2:
   \   000038 320000                POP       S:?b8
   \   00003B 87                    RETF
     99          
    100          /**
    101            * @brief   Locks the program or data EEPROM memory
    102            * @param  FLASH_MemType : Memory type
    103            *         This parameter can be a value of @ref FLASH_MemType_TypeDef
    104            * @retval None
    105            */

   \                                 In section .far_func.text, align 1
    106          void FLASH_Lock(FLASH_MemType_TypeDef FLASH_MemType)
    107          {
   \                     FLASH_Lock:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    108              /* Check parameter */
    109              assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   000005 B600                  LD        A, S:?b8
   \   000007 A1FD                  CP        A, #0xfd
   \   000009 2715                  JREQ      L:??FLASH_Lock_0
   \   00000B B600                  LD        A, S:?b8
   \   00000D A1F7                  CP        A, #0xf7
   \   00000F 270F                  JREQ      L:??FLASH_Lock_0
   \   000011 AE006D                LDW       X, #0x6d
   \   000014 BF00                  LDW       S:?w1, X
   \   000016 5F                    CLRW      X
   \   000017 BF00                  LDW       S:?w0, X
   \   000019 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001C 8D000000              CALLF     assert_failed
    110          
    111            /* Lock memory */
    112            FLASH->IAPSR &= (uint8_t)FLASH_MemType;
   \                     ??FLASH_Lock_0:
   \   000020 B600                  LD        A, S:?b8
   \   000022 C4505F                AND       A, L:0x505f
   \   000025 C7505F                LD        L:0x505f, A
    113          }
   \   000028 320000                POP       S:?b8
   \   00002B 87                    RETF
    114          
    115          /**
    116            * @brief   Deinitializes the FLASH registers to their default reset values.
    117            * @param  None
    118            * @retval None
    119            */

   \                                 In section .far_func.text, align 1
    120          void FLASH_DeInit(void)
    121          {
    122              FLASH->CR1 = FLASH_CR1_RESET_VALUE;
   \                     FLASH_DeInit:
   \   000000 3500505A              MOV       L:0x505a, #0x0
    123              FLASH->CR2 = FLASH_CR2_RESET_VALUE;
   \   000004 3500505B              MOV       L:0x505b, #0x0
    124              FLASH->NCR2 = FLASH_NCR2_RESET_VALUE;
   \   000008 35FF505C              MOV       L:0x505c, #0xff
    125              FLASH->IAPSR &= (uint8_t)(~FLASH_IAPSR_DUL);
   \   00000C 7217505F              BRES      L:0x505f, #0x3
    126              FLASH->IAPSR &= (uint8_t)(~FLASH_IAPSR_PUL);
   \   000010 7213505F              BRES      L:0x505f, #0x1
    127              (void) FLASH->IAPSR; /* Reading of this register causes the clearing of status flags */
   \   000014 C6505F                LD        A, L:0x505f
    128          }
   \   000017 87                    RETF
    129          
    130          /**
    131            * @brief   Enables or Disables the Flash interrupt mode
    132            * @param  NewState : The new state of the flash interrupt mode
    133            *         This parameter can be a value of @ref FunctionalState enumeration.
    134            * @retval None
    135            */

   \                                 In section .far_func.text, align 1
    136          void FLASH_ITConfig(FunctionalState NewState)
    137          {
   \                     FLASH_ITConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    138                /* Check parameter */
    139            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??FLASH_ITConfig_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??FLASH_ITConfig_0
   \   00000F AE008B                LDW       X, #0x8b
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    140            
    141              if (NewState != DISABLE)
   \                     ??FLASH_ITConfig_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??FLASH_ITConfig_1
    142              {
    143                  FLASH->CR1 |= FLASH_CR1_IE; /* Enables the interrupt sources */
   \   000022 7212505A              BSET      L:0x505a, #0x1
   \   000026 2004                  JRA       L:??FLASH_ITConfig_2
    144              }
    145              else
    146              {
    147                  FLASH->CR1 &= (uint8_t)(~FLASH_CR1_IE); /* Disables the interrupt sources */
   \                     ??FLASH_ITConfig_1:
   \   000028 7213505A              BRES      L:0x505a, #0x1
    148              }
    149          }
   \                     ??FLASH_ITConfig_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    150          
    151          /**
    152            * @brief   Erases one byte in the program or data EEPROM memory
    153            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    154            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    155            * @param  Address : Address of the byte to erase
    156            * @retval None
    157            */

   \                                 In section .far_func.text, align 1
    158          void FLASH_EraseByte(uint32_t Address)
    159          {
   \                     FLASH_EraseByte:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?mov_l2_l0
    160              /* Check parameter */
    161              assert_param(IS_FLASH_ADDRESS_OK(Address));
   \   000008 AE8000                LDW       X, #0x8000
   \   00000B BF00                  LDW       S:?w3, X
   \   00000D 58                    SLLW      X
   \   00000E BF00                  LDW       S:?w2, X
   \   000010 8D000000              CALLF     L:?mov_l0_l2
   \   000014 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   000018 BE00                  LDW       X, S:?w0
   \   00001A A30000                CPW       X, #0x0
   \   00001D 2605                  JRNE      L:??FLASH_EraseByte_0
   \   00001F BE00                  LDW       X, S:?w1
   \   000021 A32000                CPW       X, #0x2000
   \                     ??FLASH_EraseByte_0:
   \   000024 252D                  JRC       L:??FLASH_EraseByte_1
   \   000026 AE4000                LDW       X, #0x4000
   \   000029 BF00                  LDW       S:?w3, X
   \   00002B 5F                    CLRW      X
   \   00002C BF00                  LDW       S:?w2, X
   \   00002E 8D000000              CALLF     L:?mov_l0_l2
   \   000032 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   000036 BE00                  LDW       X, S:?w0
   \   000038 A30000                CPW       X, #0x0
   \   00003B 2605                  JRNE      L:??FLASH_EraseByte_2
   \   00003D BE00                  LDW       X, S:?w1
   \   00003F A30280                CPW       X, #0x280
   \                     ??FLASH_EraseByte_2:
   \   000042 250F                  JRC       L:??FLASH_EraseByte_1
   \   000044 AE00A1                LDW       X, #0xa1
   \   000047 BF00                  LDW       S:?w1, X
   \   000049 5F                    CLRW      X
   \   00004A BF00                  LDW       S:?w0, X
   \   00004C AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00004F 8D000000              CALLF     assert_failed
    162              
    163              /* Erase byte */
    164             *(PointerAttr uint8_t*) (uint16_t)Address = FLASH_CLEAR_BYTE; 
   \                     ??FLASH_EraseByte_1:
   \   000053 4F                    CLR       A
   \   000054 92C700                LD        [S:?w5.w], A
    165          
    166          }
   \   000057 AC000000              JPF       L:?epilogue_l2
    167          
    168          /**
    169            * @brief   Programs one byte in program or data EEPROM memory
    170            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    171            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    172            * @param  Address : Address where the byte will be programmed
    173            * @param  Data : Value to be programmed
    174            * @retval None
    175            */

   \                                 In section .far_func.text, align 1
    176          void FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    177          {
   \                     FLASH_ProgramByte:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 3B0000                PUSH      S:?b12
   \   000007 8D000000              CALLF     L:?mov_l2_l0
   \   00000B B700                  LD        S:?b12, A
    178              /* Check parameters */
    179              assert_param(IS_FLASH_ADDRESS_OK(Address));
   \   00000D AE8000                LDW       X, #0x8000
   \   000010 BF00                  LDW       S:?w3, X
   \   000012 58                    SLLW      X
   \   000013 BF00                  LDW       S:?w2, X
   \   000015 8D000000              CALLF     L:?mov_l0_l2
   \   000019 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   00001D BE00                  LDW       X, S:?w0
   \   00001F A30000                CPW       X, #0x0
   \   000022 2605                  JRNE      L:??FLASH_ProgramByte_0
   \   000024 BE00                  LDW       X, S:?w1
   \   000026 A32000                CPW       X, #0x2000
   \                     ??FLASH_ProgramByte_0:
   \   000029 252D                  JRC       L:??FLASH_ProgramByte_1
   \   00002B AE4000                LDW       X, #0x4000
   \   00002E BF00                  LDW       S:?w3, X
   \   000030 5F                    CLRW      X
   \   000031 BF00                  LDW       S:?w2, X
   \   000033 8D000000              CALLF     L:?mov_l0_l2
   \   000037 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   00003B BE00                  LDW       X, S:?w0
   \   00003D A30000                CPW       X, #0x0
   \   000040 2605                  JRNE      L:??FLASH_ProgramByte_2
   \   000042 BE00                  LDW       X, S:?w1
   \   000044 A30280                CPW       X, #0x280
   \                     ??FLASH_ProgramByte_2:
   \   000047 250F                  JRC       L:??FLASH_ProgramByte_1
   \   000049 AE00B3                LDW       X, #0xb3
   \   00004C BF00                  LDW       S:?w1, X
   \   00004E 5F                    CLRW      X
   \   00004F BF00                  LDW       S:?w0, X
   \   000051 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000054 8D000000              CALLF     assert_failed
    180              *(PointerAttr uint8_t*) (uint16_t)Address = Data;
   \                     ??FLASH_ProgramByte_1:
   \   000058 B600                  LD        A, S:?b12
   \   00005A 92C700                LD        [S:?w5.w], A
    181          }
   \   00005D 320000                POP       S:?b12
   \   000060 AC000000              JPF       L:?epilogue_l2
    182          
    183          /**
    184            * @brief   Reads any byte from flash memory
    185            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    186            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    187            * @param  Address : Address to read
    188            * @retval Value of the byte
    189            */

   \                                 In section .far_func.text, align 1
    190          uint8_t FLASH_ReadByte(uint32_t Address)
    191          {
   \                     FLASH_ReadByte:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?mov_l2_l0
    192              /* Check parameter */
    193              assert_param(IS_FLASH_ADDRESS_OK(Address));
   \   000008 AE8000                LDW       X, #0x8000
   \   00000B BF00                  LDW       S:?w3, X
   \   00000D 58                    SLLW      X
   \   00000E BF00                  LDW       S:?w2, X
   \   000010 8D000000              CALLF     L:?mov_l0_l2
   \   000014 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   000018 BE00                  LDW       X, S:?w0
   \   00001A A30000                CPW       X, #0x0
   \   00001D 2605                  JRNE      L:??FLASH_ReadByte_0
   \   00001F BE00                  LDW       X, S:?w1
   \   000021 A32000                CPW       X, #0x2000
   \                     ??FLASH_ReadByte_0:
   \   000024 252D                  JRC       L:??FLASH_ReadByte_1
   \   000026 AE4000                LDW       X, #0x4000
   \   000029 BF00                  LDW       S:?w3, X
   \   00002B 5F                    CLRW      X
   \   00002C BF00                  LDW       S:?w2, X
   \   00002E 8D000000              CALLF     L:?mov_l0_l2
   \   000032 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   000036 BE00                  LDW       X, S:?w0
   \   000038 A30000                CPW       X, #0x0
   \   00003B 2605                  JRNE      L:??FLASH_ReadByte_2
   \   00003D BE00                  LDW       X, S:?w1
   \   00003F A30280                CPW       X, #0x280
   \                     ??FLASH_ReadByte_2:
   \   000042 250F                  JRC       L:??FLASH_ReadByte_1
   \   000044 AE00C1                LDW       X, #0xc1
   \   000047 BF00                  LDW       S:?w1, X
   \   000049 5F                    CLRW      X
   \   00004A BF00                  LDW       S:?w0, X
   \   00004C AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00004F 8D000000              CALLF     assert_failed
    194              
    195              /* Read byte */
    196              return(*(PointerAttr uint8_t *) (uint16_t)Address); 
   \                     ??FLASH_ReadByte_1:
   \   000053 BE00                  LDW       X, S:?w5
   \   000055 F6                    LD        A, (X)
   \   000056 AC000000              JPF       L:?epilogue_l2
    197          
    198          }
    199          /**
    200            * @brief   Programs one word (4 bytes) in program or data EEPROM memory
    201            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    202            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    203            * @param  Address : The address where the data will be programmed
    204            * @param  Data : Value to be programmed
    205            * @retval None
    206            */

   \                                 In section .far_func.text, align 1
    207          void FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    208          {
   \                     FLASH_ProgramWord:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l1
   \   000008 8D000000              CALLF     L:?mov_l2_l0
    209              /* Check parameters */
    210              assert_param(IS_FLASH_ADDRESS_OK(Address));
   \   00000C AE8000                LDW       X, #0x8000
   \   00000F BF00                  LDW       S:?w3, X
   \   000011 58                    SLLW      X
   \   000012 BF00                  LDW       S:?w2, X
   \   000014 8D000000              CALLF     L:?mov_l0_l2
   \   000018 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   00001C BE00                  LDW       X, S:?w0
   \   00001E A30000                CPW       X, #0x0
   \   000021 2605                  JRNE      L:??FLASH_ProgramWord_0
   \   000023 BE00                  LDW       X, S:?w1
   \   000025 A32000                CPW       X, #0x2000
   \                     ??FLASH_ProgramWord_0:
   \   000028 252D                  JRC       L:??FLASH_ProgramWord_1
   \   00002A AE4000                LDW       X, #0x4000
   \   00002D BF00                  LDW       S:?w3, X
   \   00002F 5F                    CLRW      X
   \   000030 BF00                  LDW       S:?w2, X
   \   000032 8D000000              CALLF     L:?mov_l0_l2
   \   000036 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   00003A BE00                  LDW       X, S:?w0
   \   00003C A30000                CPW       X, #0x0
   \   00003F 2605                  JRNE      L:??FLASH_ProgramWord_2
   \   000041 BE00                  LDW       X, S:?w1
   \   000043 A30280                CPW       X, #0x280
   \                     ??FLASH_ProgramWord_2:
   \   000046 250F                  JRC       L:??FLASH_ProgramWord_1
   \   000048 AE00D2                LDW       X, #0xd2
   \   00004B BF00                  LDW       S:?w1, X
   \   00004D 5F                    CLRW      X
   \   00004E BF00                  LDW       S:?w0, X
   \   000050 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000053 8D000000              CALLF     assert_failed
    211          
    212              /* Enable Word Write Once */
    213              FLASH->CR2 |= FLASH_CR2_WPRG;
   \                     ??FLASH_ProgramWord_1:
   \   000057 721C505B              BSET      L:0x505b, #0x6
    214              FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NWPRG);
   \   00005B 721D505C              BRES      L:0x505c, #0x6
    215          
    216              /* Write one byte - from lowest address*/
    217              *((PointerAttr uint8_t*)(uint16_t)Address)       = *((uint8_t*)(&Data));
   \   00005F 7B01                  LD        A, (0x1,SP)
   \   000061 92C700                LD        [S:?w5.w], A
    218              /* Write one byte*/
    219              *(((PointerAttr uint8_t*)(uint16_t)Address) + 1) = *((uint8_t*)(&Data)+1); 
   \   000064 BE00                  LDW       X, S:?w5
   \   000066 5C                    INCW      X
   \   000067 7B02                  LD        A, (0x2,SP)
   \   000069 F7                    LD        (X), A
    220              /* Write one byte*/    
    221              *(((PointerAttr uint8_t*)(uint16_t)Address) + 2) = *((uint8_t*)(&Data)+2); 
   \   00006A BE00                  LDW       X, S:?w5
   \   00006C 1C0002                ADDW      X, #0x2
   \   00006F 7B03                  LD        A, (0x3,SP)
   \   000071 F7                    LD        (X), A
    222              /* Write one byte - from higher address*/
    223              *(((PointerAttr uint8_t*)(uint16_t)Address) + 3) = *((uint8_t*)(&Data)+3); 
   \   000072 BE00                  LDW       X, S:?w5
   \   000074 1C0003                ADDW      X, #0x3
   \   000077 7B04                  LD        A, (0x4,SP)
   \   000079 F7                    LD        (X), A
    224          }
   \   00007A 5B04                  ADD       SP, #0x4
   \   00007C AC000000              JPF       L:?epilogue_l2
    225          
    226          /**
    227            * @brief   Programs option byte
    228            * @param  Address : option byte address to program
    229            * @param  Data : Value to write
    230            * @retval None
    231            */

   \                                 In section .far_func.text, align 1
    232          void FLASH_ProgramOptionByte(uint16_t Address, uint8_t Data)
    233          {
   \                     FLASH_ProgramOptionByte:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 BF00                  LDW       S:?w4, X
   \   000009 B700                  LD        S:?b10, A
    234              /* Check parameter */
    235              assert_param(IS_OPTION_BYTE_ADDRESS_OK(Address));
   \   00000B BE00                  LDW       X, S:?w4
   \   00000D 1D4800                SUBW      X, #0x4800
   \   000010 A30080                CPW       X, #0x80
   \   000013 250F                  JRC       L:??FLASH_ProgramOptionByte_0
   \   000015 AE00EB                LDW       X, #0xeb
   \   000018 BF00                  LDW       S:?w1, X
   \   00001A 5F                    CLRW      X
   \   00001B BF00                  LDW       S:?w0, X
   \   00001D AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000020 8D000000              CALLF     assert_failed
    236          
    237              /* Enable write access to option bytes */
    238              FLASH->CR2 |= FLASH_CR2_OPT;
   \                     ??FLASH_ProgramOptionByte_0:
   \   000024 721E505B              BSET      L:0x505b, #0x7
    239              FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NOPT);
   \   000028 721F505C              BRES      L:0x505c, #0x7
    240          
    241              /* check if the option byte to program is ROP*/
    242              if (Address == 0x4800)
   \   00002C BE00                  LDW       X, S:?w4
   \   00002E A34800                CPW       X, #0x4800
   \   000031 2607                  JRNE      L:??FLASH_ProgramOptionByte_1
    243              {
    244                 /* Program option byte*/
    245                 *((NEAR uint8_t*)Address) = Data;
   \   000033 B600                  LD        A, S:?b10
   \   000035 92C700                LD        [S:?w4.w], A
   \   000038 200D                  JRA       L:??FLASH_ProgramOptionByte_2
    246              }
    247              else
    248              {
    249                 /* Program option byte and his complement */
    250                 *((NEAR uint8_t*)Address) = Data;
   \                     ??FLASH_ProgramOptionByte_1:
   \   00003A B600                  LD        A, S:?b10
   \   00003C 92C700                LD        [S:?w4.w], A
    251                 *((NEAR uint8_t*)((uint16_t)(Address + 1))) = (uint8_t)(~Data);
   \   00003F BE00                  LDW       X, S:?w4
   \   000041 5C                    INCW      X
   \   000042 3300                  CPL       S:?b10
   \   000044 B600                  LD        A, S:?b10
   \   000046 F7                    LD        (X), A
    252              }
    253              FLASH_WaitForLastOperation(FLASH_MEMTYPE_PROG);
   \                     ??FLASH_ProgramOptionByte_2:
   \   000047 A6FD                  LD        A, #0xfd
   \   000049 8D000000              CALLF     FLASH_WaitForLastOperation
    254          
    255              /* Disable write access to option bytes */
    256              FLASH->CR2 &= (uint8_t)(~FLASH_CR2_OPT);
   \   00004D 721F505B              BRES      L:0x505b, #0x7
    257              FLASH->NCR2 |= FLASH_NCR2_NOPT;
   \   000051 721E505C              BSET      L:0x505c, #0x7
    258          }
   \   000055 320000                POP       S:?b10
   \   000058 AC000000              JPF       L:?epilogue_w4
    259          
    260          /**
    261            * @brief   Erases option byte
    262            * @param  Address : Option byte address to erase
    263            * @retval None
    264            */

   \                                 In section .far_func.text, align 1
    265          void FLASH_EraseOptionByte(uint16_t Address)
    266          {
   \                     FLASH_EraseOptionByte:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    267              /* Check parameter */
    268              assert_param(IS_OPTION_BYTE_ADDRESS_OK(Address));
   \   000006 BE00                  LDW       X, S:?w4
   \   000008 1D4800                SUBW      X, #0x4800
   \   00000B A30080                CPW       X, #0x80
   \   00000E 250F                  JRC       L:??FLASH_EraseOptionByte_0
   \   000010 AE010C                LDW       X, #0x10c
   \   000013 BF00                  LDW       S:?w1, X
   \   000015 5F                    CLRW      X
   \   000016 BF00                  LDW       S:?w0, X
   \   000018 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001B 8D000000              CALLF     assert_failed
    269          
    270              /* Enable write access to option bytes */
    271              FLASH->CR2 |= FLASH_CR2_OPT;
   \                     ??FLASH_EraseOptionByte_0:
   \   00001F 721E505B              BSET      L:0x505b, #0x7
    272              FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NOPT);
   \   000023 721F505C              BRES      L:0x505c, #0x7
    273          
    274               /* check if the option byte to erase is ROP */
    275               if (Address == 0x4800)
   \   000027 BE00                  LDW       X, S:?w4
   \   000029 A34800                CPW       X, #0x4800
   \   00002C 2606                  JRNE      L:??FLASH_EraseOptionByte_1
    276              {
    277                 /* Erase option byte */
    278                 *((NEAR uint8_t*)Address) = FLASH_CLEAR_BYTE;
   \   00002E 4F                    CLR       A
   \   00002F 92C700                LD        [S:?w4.w], A
   \   000032 200A                  JRA       L:??FLASH_EraseOptionByte_2
    279              }
    280              else
    281              {
    282                 /* Erase option byte and his complement */
    283                 *((NEAR uint8_t*)Address) = FLASH_CLEAR_BYTE;
   \                     ??FLASH_EraseOptionByte_1:
   \   000034 4F                    CLR       A
   \   000035 92C700                LD        [S:?w4.w], A
    284                 *((NEAR uint8_t*)((uint16_t)(Address + (uint16_t)1 ))) = FLASH_SET_BYTE;
   \   000038 BE00                  LDW       X, S:?w4
   \   00003A 5C                    INCW      X
   \   00003B A6FF                  LD        A, #0xff
   \   00003D F7                    LD        (X), A
    285              }
    286              FLASH_WaitForLastOperation(FLASH_MEMTYPE_PROG);
   \                     ??FLASH_EraseOptionByte_2:
   \   00003E A6FD                  LD        A, #0xfd
   \   000040 8D000000              CALLF     FLASH_WaitForLastOperation
    287          
    288              /* Disable write access to option bytes */
    289              FLASH->CR2 &= (uint8_t)(~FLASH_CR2_OPT);
   \   000044 721F505B              BRES      L:0x505b, #0x7
    290              FLASH->NCR2 |= FLASH_NCR2_NOPT;
   \   000048 721E505C              BSET      L:0x505c, #0x7
    291          }
   \   00004C AC000000              JPF       L:?epilogue_w4
    292          /**
    293            * @brief   Reads one option byte
    294            * @param  Address  option byte address to read.
    295            * @retval Option byte read value + its complement
    296            */

   \                                 In section .far_func.text, align 1
    297          uint16_t FLASH_ReadOptionByte(uint16_t Address)
    298          {
   \                     FLASH_ReadOptionByte:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    299              uint8_t value_optbyte, value_optbyte_complement = 0;
   \   000006 3F00                  CLR       S:?b0
    300              uint16_t res_value = 0;
   \   000008 905F                  CLRW      Y
    301          
    302              /* Check parameter */
    303              assert_param(IS_OPTION_BYTE_ADDRESS_OK(Address));
   \   00000A BE00                  LDW       X, S:?w4
   \   00000C 1D4800                SUBW      X, #0x4800
   \   00000F A30080                CPW       X, #0x80
   \   000012 250F                  JRC       L:??FLASH_ReadOptionByte_0
   \   000014 AE012F                LDW       X, #0x12f
   \   000017 BF00                  LDW       S:?w1, X
   \   000019 5F                    CLRW      X
   \   00001A BF00                  LDW       S:?w0, X
   \   00001C AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001F 8D000000              CALLF     assert_failed
    304          
    305          
    306              value_optbyte = *((NEAR uint8_t*)Address); /* Read option byte */
   \                     ??FLASH_ReadOptionByte_0:
   \   000023 92C600                LD        A, [S:?w4.w]
   \   000026 B700                  LD        S:?b1, A
    307              value_optbyte_complement = *(((NEAR uint8_t*)Address) + 1); /* Read option byte complement */
   \   000028 BE00                  LDW       X, S:?w4
   \   00002A 5C                    INCW      X
   \   00002B F6                    LD        A, (X)
   \   00002C B700                  LD        S:?b0, A
    308          
    309              /* Read-out protection option byte */
    310              if (Address == 0x4800)	 
   \   00002E BE00                  LDW       X, S:?w4
   \   000030 A34800                CPW       X, #0x4800
   \   000033 2609                  JRNE      L:??FLASH_ReadOptionByte_1
    311              {
    312                  res_value =	 value_optbyte;
   \   000035 5F                    CLRW      X
   \   000036 41                    EXG       A, XL
   \   000037 B600                  LD        A, S:?b1
   \   000039 41                    EXG       A, XL
   \   00003A 9093                  LDW       Y, X
   \   00003C 2028                  JRA       L:??FLASH_ReadOptionByte_2
    313              }
    314              else
    315              {
    316                  if (value_optbyte == (uint8_t)(~value_optbyte_complement))
   \                     ??FLASH_ReadOptionByte_1:
   \   00003E B600                  LD        A, S:?b0
   \   000040 43                    CPL       A
   \   000041 B100                  CP        A, S:?b1
   \   000043 261C                  JRNE      L:??FLASH_ReadOptionByte_3
    317                  {
    318                      res_value = (uint16_t)((uint16_t)value_optbyte << 8);
   \   000045 5F                    CLRW      X
   \   000046 41                    EXG       A, XL
   \   000047 B600                  LD        A, S:?b1
   \   000049 41                    EXG       A, XL
   \   00004A 4F                    CLR       A
   \   00004B 02                    RLWA      X, A
   \   00004C 9093                  LDW       Y, X
    319                      res_value = res_value | (uint16_t)value_optbyte_complement;
   \   00004E 5F                    CLRW      X
   \   00004F 41                    EXG       A, XL
   \   000050 B600                  LD        A, S:?b0
   \   000052 41                    EXG       A, XL
   \   000053 BF00                  LDW       S:?w0, X
   \   000055 93                    LDW       X, Y
   \   000056 01                    RRWA      X, A
   \   000057 BA00                  OR        A, S:?b1
   \   000059 01                    RRWA      X, A
   \   00005A BA00                  OR        A, S:?b0
   \   00005C 01                    RRWA      X, A
   \   00005D 9093                  LDW       Y, X
   \   00005F 2005                  JRA       L:??FLASH_ReadOptionByte_2
    320                  }
    321                  else
    322                  {
    323                      res_value = FLASH_OPTIONBYTE_ERROR;
   \                     ??FLASH_ReadOptionByte_3:
   \   000061 AE5555                LDW       X, #0x5555
   \   000064 9093                  LDW       Y, X
    324                  }
    325              }
    326              return(res_value);
   \                     ??FLASH_ReadOptionByte_2:
   \   000066 93                    LDW       X, Y
   \   000067 AC000000              JPF       L:?epilogue_w4
    327          }
    328          
    329          /**
    330            * @brief   Select the Flash behaviour in low power mode
    331            * @param  FLASH_LPMode Low power mode selection
    332            *         This parameter can be any of the @ref FLASH_LPMode_TypeDef values.
    333            * @retval None
    334            */

   \                                 In section .far_func.text, align 1
    335          void FLASH_SetLowPowerMode(FLASH_LPMode_TypeDef FLASH_LPMode)
    336          {
   \                     FLASH_SetLowPowerMode:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    337              /* Check parameter */
    338              assert_param(IS_FLASH_LOW_POWER_MODE_OK(FLASH_LPMode));
   \   000005 B600                  LD        A, S:?b8
   \   000007 A104                  CP        A, #0x4
   \   000009 271F                  JREQ      L:??FLASH_SetLowPowerMode_0
   \   00000B B600                  LD        A, S:?b8
   \   00000D A108                  CP        A, #0x8
   \   00000F 2719                  JREQ      L:??FLASH_SetLowPowerMode_0
   \   000011 3D00                  TNZ       S:?b8
   \   000013 2715                  JREQ      L:??FLASH_SetLowPowerMode_0
   \   000015 B600                  LD        A, S:?b8
   \   000017 A10C                  CP        A, #0xc
   \   000019 270F                  JREQ      L:??FLASH_SetLowPowerMode_0
   \   00001B AE0152                LDW       X, #0x152
   \   00001E BF00                  LDW       S:?w1, X
   \   000020 5F                    CLRW      X
   \   000021 BF00                  LDW       S:?w0, X
   \   000023 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000026 8D000000              CALLF     assert_failed
    339          
    340              /* Clears the two bits */
    341              FLASH->CR1 &= (uint8_t)(~(FLASH_CR1_HALT | FLASH_CR1_AHALT)); 
   \                     ??FLASH_SetLowPowerMode_0:
   \   00002A C6505A                LD        A, L:0x505a
   \   00002D A4F3                  AND       A, #0xf3
   \   00002F C7505A                LD        L:0x505a, A
    342              
    343              /* Sets the new mode */
    344              FLASH->CR1 |= (uint8_t)FLASH_LPMode; 
   \   000032 B600                  LD        A, S:?b8
   \   000034 CA505A                OR        A, L:0x505a
   \   000037 C7505A                LD        L:0x505a, A
    345          }
   \   00003A 320000                POP       S:?b8
   \   00003D 87                    RETF
    346          
    347          /**
    348            * @brief   Sets the fixed programming time
    349            * @param  FLASH_ProgTime Indicates the programming time to be fixed
    350            *         This parameter can be any of the @ref FLASH_ProgramTime_TypeDef values.
    351            * @retval None
    352            */

   \                                 In section .far_func.text, align 1
    353          void FLASH_SetProgrammingTime(FLASH_ProgramTime_TypeDef FLASH_ProgTime)
    354          {
   \                     FLASH_SetProgrammingTime:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    355              /* Check parameter */
    356              assert_param(IS_FLASH_PROGRAM_TIME_OK(FLASH_ProgTime));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??FLASH_SetProgrammingTime_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??FLASH_SetProgrammingTime_0
   \   00000F AE0164                LDW       X, #0x164
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    357          
    358              FLASH->CR1 &= (uint8_t)(~FLASH_CR1_FIX);
   \                     ??FLASH_SetProgrammingTime_0:
   \   00001E 7211505A              BRES      L:0x505a, #0x0
    359              FLASH->CR1 |= (uint8_t)FLASH_ProgTime;
   \   000022 B600                  LD        A, S:?b8
   \   000024 CA505A                OR        A, L:0x505a
   \   000027 C7505A                LD        L:0x505a, A
    360          }
   \   00002A 320000                POP       S:?b8
   \   00002D 87                    RETF
    361          
    362          /**
    363            * @brief  Returns the Flash behaviour type in low power mode
    364            * @param  None
    365            * @retval FLASH_LPMode_TypeDef Flash behaviour type in low power mode
    366            */

   \                                 In section .far_func.text, align 1
    367          FLASH_LPMode_TypeDef FLASH_GetLowPowerMode(void)
    368          {
    369              return((FLASH_LPMode_TypeDef)(FLASH->CR1 & (uint8_t)(FLASH_CR1_HALT | FLASH_CR1_AHALT)));
   \                     FLASH_GetLowPowerMode:
   \   000000 C6505A                LD        A, L:0x505a
   \   000003 A40C                  AND       A, #0xc
   \   000005 87                    RETF
    370          }
    371          
    372          /**
    373            * @brief  Returns the fixed programming time
    374            * @param  None
    375            * @retval FLASH_ProgramTime_TypeDef Fixed programming time value
    376            */

   \                                 In section .far_func.text, align 1
    377          FLASH_ProgramTime_TypeDef FLASH_GetProgrammingTime(void)
    378          {
    379              return((FLASH_ProgramTime_TypeDef)(FLASH->CR1 & FLASH_CR1_FIX));
   \                     FLASH_GetProgrammingTime:
   \   000000 C6505A                LD        A, L:0x505a
   \   000003 A401                  AND       A, #0x1
   \   000005 87                    RETF
    380          }
    381          
    382          /**
    383            * @brief  Returns the Boot memory size in bytes
    384            * @param  None
    385            * @retval Boot memory size in bytes
    386            */

   \                                 In section .far_func.text, align 1
    387          uint32_t FLASH_GetBootSize(void)
    388          {
   \                     FLASH_GetBootSize:
   \   000000 8D000000              CALLF     L:?push_l2
    389              uint32_t temp = 0;
   \   000004 5F                    CLRW      X
   \   000005 BF00                  LDW       S:?w5, X
   \   000007 BF00                  LDW       S:?w4, X
    390          
    391              /* Calculates the number of bytes */
    392              temp = (uint32_t)((uint32_t)FLASH->FPR * (uint32_t)512);
   \   000009 C6505D                LD        A, L:0x505d
   \   00000C 5F                    CLRW      X
   \   00000D 97                    LD        XL, A
   \   00000E BF00                  LDW       S:?w1, X
   \   000010 5F                    CLRW      X
   \   000011 BF00                  LDW       S:?w0, X
   \   000013 AE0200                LDW       X, #0x200
   \   000016 BF00                  LDW       S:?w3, X
   \   000018 5F                    CLRW      X
   \   000019 BF00                  LDW       S:?w2, X
   \   00001B 8D000000              CALLF     L:?mul32_l0_l0_l1
   \   00001F 8D000000              CALLF     L:?mov_l2_l0
    393          
    394              /* Correction because size of 127.5 kb doesn't exist */
    395              if (FLASH->FPR == 0xFF)
   \   000023 C6505D                LD        A, L:0x505d
   \   000026 A1FF                  CP        A, #0xff
   \   000028 2614                  JRNE      L:??FLASH_GetBootSize_0
    396              {
    397                  temp += 512;
   \   00002A AE0200                LDW       X, #0x200
   \   00002D BF00                  LDW       S:?w3, X
   \   00002F 5F                    CLRW      X
   \   000030 BF00                  LDW       S:?w2, X
   \   000032 8D000000              CALLF     L:?mov_l0_l2
   \   000036 8D000000              CALLF     L:?add32_l0_l0_l1
   \   00003A 8D000000              CALLF     L:?mov_l2_l0
    398              }
    399          
    400              /* Return value */
    401              return(temp);
   \                     ??FLASH_GetBootSize_0:
   \   00003E 8D000000              CALLF     L:?mov_l0_l2
   \   000042 AC000000              JPF       L:?epilogue_l2
    402          }
    403          
    404          /**
    405            * @brief  Checks whether the specified SPI flag is set or not.
    406            * @param  FLASH_FLAG : Specifies the flag to check.
    407            *         This parameter can be any of the @ref FLASH_Flag_TypeDef enumeration.
    408            * @retval FlagStatus : Indicates the state of FLASH_FLAG.
    409            *         This parameter can be any of the @ref FlagStatus enumeration.
    410            * @note   This function can clear the EOP, WR_PG_DIS flags in the IAPSR register.
    411            */

   \                                 In section .far_func.text, align 1
    412          FlagStatus FLASH_GetFlagStatus(FLASH_Flag_TypeDef FLASH_FLAG)
    413          {
   \                     FLASH_GetFlagStatus:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    414              FlagStatus status = RESET;
   \   000005 3F00                  CLR       S:?b0
    415              /* Check parameters */
    416              assert_param(IS_FLASH_FLAGS_OK(FLASH_FLAG));
   \   000007 B600                  LD        A, S:?b8
   \   000009 A108                  CP        A, #0x8
   \   00000B 2721                  JREQ      L:??FLASH_GetFlagStatus_0
   \   00000D B600                  LD        A, S:?b8
   \   00000F A104                  CP        A, #0x4
   \   000011 271B                  JREQ      L:??FLASH_GetFlagStatus_0
   \   000013 B600                  LD        A, S:?b8
   \   000015 A102                  CP        A, #0x2
   \   000017 2715                  JREQ      L:??FLASH_GetFlagStatus_0
   \   000019 B600                  LD        A, S:?b8
   \   00001B A101                  CP        A, #0x1
   \   00001D 270F                  JREQ      L:??FLASH_GetFlagStatus_0
   \   00001F AE01A0                LDW       X, #0x1a0
   \   000022 BF00                  LDW       S:?w1, X
   \   000024 5F                    CLRW      X
   \   000025 BF00                  LDW       S:?w0, X
   \   000027 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00002A 8D000000              CALLF     assert_failed
    417          
    418              /* Check the status of the specified FLASH flag */
    419              if ((FLASH->IAPSR & (uint8_t)FLASH_FLAG) != (uint8_t)RESET)
   \                     ??FLASH_GetFlagStatus_0:
   \   00002E B600                  LD        A, S:?b8
   \   000030 C4505F                AND       A, L:0x505f
   \   000033 A100                  CP        A, #0x0
   \   000035 2706                  JREQ      L:??FLASH_GetFlagStatus_1
    420              {
    421                  status = SET; /* FLASH_FLAG is set */
   \   000037 35010000              MOV       S:?b0, #0x1
   \   00003B 2002                  JRA       L:??FLASH_GetFlagStatus_2
    422              }
    423              else
    424              {
    425                  status = RESET; /* FLASH_FLAG is reset*/
   \                     ??FLASH_GetFlagStatus_1:
   \   00003D 3F00                  CLR       S:?b0
    426              }
    427          
    428              /* Return the FLASH_FLAG status */
    429              return status;
   \                     ??FLASH_GetFlagStatus_2:
   \   00003F B600                  LD        A, S:?b0
   \   000041 320000                POP       S:?b8
   \   000044 87                    RETF
    430          }
    431          
    432          /**
    433          @code
    434           All the functions defined below must be executed from RAM exclusively, except
    435           for the FLASH_WaitForLastOperation function which can be executed from Flash.
    436          
    437           Steps of the execution from RAM differs from one toolchain to another:
    438           - For Cosmic Compiler:
    439              1- Define a segment FLASH_CODE by the mean of " #pragma section (FLASH_CODE)".
    440              This segment is defined in the stm8s_flash.c file.
    441            2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8s.h file,
    442              or define it in Cosmic compiler preprocessor to enable the FLASH_CODE segment
    443             definition.
    444            3- In STVD Select Project\Settings\Linker\Category "input" and in the RAM section
    445              add the FLASH_CODE segment with "-ic" options.
    446            4- In main.c file call the _fctcpy() function with first segment character as 
    447              parameter "_fctcpy('F');" to load the declared moveable code segment
    448              (FLASH_CODE) in RAM before execution.
    449            5- By default the _fctcpy function is packaged in the Cosmic machine library,
    450              so the function prototype "int _fctcopy(char name);" must be added in main.c
    451              file.
    452          
    453            - For Raisonance Compiler
    454             1- Use the inram keyword in the function declaration to specify that it can be
    455              executed from RAM.
    456              This is done within the stm8s_flash.c file, and it's conditioned by 
    457              RAM_EXECUTION definition.
    458             2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8s.h file, or 
    459             define it in Raisonance compiler preprocessor to enable the access for the 
    460             inram functions.
    461             3- An inram function code is copied from Flash to RAM by the C startup code. 
    462             In some applications, the RAM area where the code was initially stored may be
    463             erased or corrupted, so it may be desirable to perform the copy again. 
    464             Depending on the application memory model, the memcpy() or fmemcpy() functions
    465             should be used to perform the copy.
    466                 In case your project uses the SMALL memory model (code smaller than 64K),
    467                 memcpy()function is recommended to perform the copy
    468                 In case your project uses the LARGE memory model, functions can be 
    469                everywhenre in the 24-bits address space (not limited to the first 64KB of
    470                code), In this case, the use of memcpy() function will not be appropriate,
    471                you need to use the specific fmemcpy() function (which copies objects with
    472                24-bit addresses).
    473                - The linker automatically defines 2 symbols for each inram function:
    474                      __address__functionname is a symbol that holds the Flash address 
    475                     where the given function code is stored.
    476                      __size__functionname is a symbol that holds the function size in bytes.
    477               And we already have the function address (which is itself a pointer)
    478            4- In main.c file these two steps should be performed for each inram function:
    479                Import the "__address__functionname" and "__size__functionname" symbols
    480                 as global variables:
    481                   extern int __address__functionname; // Symbol holding the flash address
    482                   extern int __size__functionname;    // Symbol holding the function size
    483                In case of SMALL memory model use, Call the memcpy() function to copy the
    484                inram function to the RAM destination address:
    485                          memcpy(functionname, // RAM destination address
    486                                (void*)&__address__functionname, // Flash source address
    487                                (int)&__size__functionname); // Code size of the function
    488                In case of LARGE memory model use, call the fmemcpy() function to copy 
    489               the inram function to the RAM destination address:
    490                           memcpy(functionname, // RAM destination address
    491                                (void @far*)&__address__functionname, // Flash source address
    492                                (int)&__size__functionname); // Code size of the function
    493          
    494           - For IAR Compiler:
    495              1- Use the __ramfunc keyword in the function declaration to specify that it 
    496              can be executed from RAM..
    497              This is done within the stm8s_flash.c file, and it's conditioned by 
    498              RAM_EXECUTION definition.
    499              2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8s.h file, or 
    500             define it in IAR compiler preprocessor to enable the access for the 
    501             __ramfunc functions.
    502           
    503           The FLASH examples given within the STM8S_StdPeriph_Lib package, details all 
    504           the steps described above.
    505          
    506          @endcode
    507          */
    508          
    509          /**
    510            * @brief
    511            *******************************************************************************
    512            *                         Execution from RAM enable
    513            *******************************************************************************
    514            *
    515            * To enable execution from RAM you can either uncomment the following define 
    516            * in the stm8s.h file or define it in your toolchain compiler preprocessor
    517            * - #define RAM_EXECUTION  (1) 
    518            */
    519            
    520          #if defined (_COSMIC_) && defined (RAM_EXECUTION)
    521           #pragma section (FLASH_CODE)
    522          #endif  /* _COSMIC_ && RAM_EXECUTION */
    523          /**
    524            * @brief  Wait for a Flash operation to complete.
    525            * @note   The call and execution of this function must be done from RAM in case
    526            *         of Block operation, otherwise it can be executed from Flash
    527            * @param  FLASH_MemType : Memory type
    528            *         This parameter can be a value of @ref FLASH_MemType_TypeDef
    529            * @retval FLASH status
    530            */

   \                                 In section .far_func.text, align 1
    531          IN_RAM(FLASH_Status_TypeDef FLASH_WaitForLastOperation(FLASH_MemType_TypeDef FLASH_MemType)) 
    532          {
    533              uint8_t flagstatus = 0x00;
   \                     FLASH_WaitForLastOperation:
   \   000000 4F                    CLR       A
    534              uint32_t timeout = OPERATION_TIMEOUT;
   \   000001 5F                    CLRW      X
   \   000002 5A                    DECW      X
   \   000003 BF00                  LDW       S:?w1, X
   \   000005 AE000F                LDW       X, #0xf
   \   000008 BF00                  LDW       S:?w0, X
   \   00000A 2009                  JRA       L:??FLASH_WaitForLastOperation_0
    535              
    536              /* Wait until operation completion or write protection page occurred */
    537          #if defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined(STM8S105) || \
    538              defined(STM8S005) || defined(STM8AF52Ax) || defined(STM8AF62Ax) || defined(STM8AF626x)  
    539              if (FLASH_MemType == FLASH_MEMTYPE_PROG)
    540              {
    541                  while ((flagstatus == 0x00) && (timeout != 0x00))
    542                  {
    543                      flagstatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_EOP |
    544                                                        FLASH_IAPSR_WR_PG_DIS));
    545                      timeout--;
    546                  }
    547              }
    548              else
    549              {
    550                  while ((flagstatus == 0x00) && (timeout != 0x00))
    551                  {
    552                      flagstatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_HVOFF |
    553                                                        FLASH_IAPSR_WR_PG_DIS));
    554                      timeout--;
    555                  }
    556              }
    557          #else /*STM8S103, STM8S903*/
    558              while ((flagstatus == 0x00) && (timeout != 0x00))
    559              {
    560                  flagstatus = (uint8_t)(FLASH->IAPSR & (FLASH_IAPSR_EOP | FLASH_IAPSR_WR_PG_DIS));
   \                     ??FLASH_WaitForLastOperation_1:
   \   00000C C6505F                LD        A, L:0x505f
   \   00000F A405                  AND       A, #0x5
    561                  timeout--;
   \   000011 8D000000              CALLF     L:?dec32_l0_l0
    562              }
   \                     ??FLASH_WaitForLastOperation_0:
   \   000015 4D                    TNZ       A
   \   000016 260E                  JRNE      L:??FLASH_WaitForLastOperation_2
   \   000018 BE00                  LDW       X, S:?w0
   \   00001A A30000                CPW       X, #0x0
   \   00001D 2605                  JRNE      L:??FLASH_WaitForLastOperation_3
   \   00001F BE00                  LDW       X, S:?w1
   \   000021 A30000                CPW       X, #0x0
   \                     ??FLASH_WaitForLastOperation_3:
   \   000024 26E6                  JRNE      L:??FLASH_WaitForLastOperation_1
    563          
    564          #endif /* STM8S208, STM8S207, STM8S105, STM8AF52Ax, STM8AF62Ax, STM8AF262x */
    565              
    566              if (timeout == 0x00 )
   \                     ??FLASH_WaitForLastOperation_2:
   \   000026 BE00                  LDW       X, S:?w0
   \   000028 A30000                CPW       X, #0x0
   \   00002B 2605                  JRNE      L:??FLASH_WaitForLastOperation_4
   \   00002D BE00                  LDW       X, S:?w1
   \   00002F A30000                CPW       X, #0x0
   \                     ??FLASH_WaitForLastOperation_4:
   \   000032 2602                  JRNE      L:??FLASH_WaitForLastOperation_5
    567              {
    568                  flagstatus = FLASH_STATUS_TIMEOUT;
   \   000034 A602                  LD        A, #0x2
    569              }
    570          
    571              return((FLASH_Status_TypeDef)flagstatus);
   \                     ??FLASH_WaitForLastOperation_5:
   \   000036 87                    RETF
    572          }
    573          
    574          /**
    575            * @brief  Erases a block in the program or data memory.
    576            * @note   This function should be called and executed from RAM.
    577            * @param  FLASH_MemType :  The type of memory to erase
    578            * @param  BlockNum : Indicates the block number to erase
    579            * @retval None.
    580            */

   \                                 In section .far_func.text, align 1
    581          IN_RAM(void FLASH_EraseBlock(uint16_t BlockNum, FLASH_MemType_TypeDef FLASH_MemType))
    582          {
   \                     FLASH_EraseBlock:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 BF00                  LDW       S:?w4, X
   \   000009 B700                  LD        S:?b10, A
    583            uint32_t startaddress = 0;
   \   00000B 5F                    CLRW      X
   \   00000C BF00                  LDW       S:?w3, X
   \   00000E BF00                  LDW       S:?w2, X
    584              
    585          #if defined(STM8S105) || defined(STM8S005) || defined(STM8S103) || defined(STM8S003) || \
    586              defined (STM8S903) || defined (STM8AF626x)
    587            uint32_t PointerAttr  *pwFlash;
    588          #elif defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined (STM8AF62Ax) || defined (STM8AF52Ax) 
    589            uint8_t PointerAttr  *pwFlash;
    590          #endif
    591          
    592            /* Check parameters */
    593            assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   000010 B600                  LD        A, S:?b10
   \   000012 A1FD                  CP        A, #0xfd
   \   000014 2715                  JREQ      L:??FLASH_EraseBlock_0
   \   000016 B600                  LD        A, S:?b10
   \   000018 A1F7                  CP        A, #0xf7
   \   00001A 270F                  JREQ      L:??FLASH_EraseBlock_0
   \   00001C AE0251                LDW       X, #0x251
   \   00001F BF00                  LDW       S:?w1, X
   \   000021 5F                    CLRW      X
   \   000022 BF00                  LDW       S:?w0, X
   \   000024 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000027 8D000000              CALLF     assert_failed
    594            if (FLASH_MemType == FLASH_MEMTYPE_PROG)
   \                     ??FLASH_EraseBlock_0:
   \   00002B B600                  LD        A, S:?b10
   \   00002D A1FD                  CP        A, #0xfd
   \   00002F 2620                  JRNE      L:??FLASH_EraseBlock_1
    595            {
    596                assert_param(IS_FLASH_PROG_BLOCK_NUMBER_OK(BlockNum));
   \   000031 BE00                  LDW       X, S:?w4
   \   000033 A30080                CPW       X, #0x80
   \   000036 250F                  JRC       L:??FLASH_EraseBlock_2
   \   000038 AE0254                LDW       X, #0x254
   \   00003B BF00                  LDW       S:?w1, X
   \   00003D 5F                    CLRW      X
   \   00003E BF00                  LDW       S:?w0, X
   \   000040 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000043 8D000000              CALLF     assert_failed
    597                startaddress = FLASH_PROG_START_PHYSICAL_ADDRESS;
   \                     ??FLASH_EraseBlock_2:
   \   000047 AE8000                LDW       X, #0x8000
   \   00004A BF00                  LDW       S:?w3, X
   \   00004C 58                    SLLW      X
   \   00004D BF00                  LDW       S:?w2, X
   \   00004F 201E                  JRA       L:??FLASH_EraseBlock_3
    598            }
    599            else
    600            {
    601                assert_param(IS_FLASH_DATA_BLOCK_NUMBER_OK(BlockNum));
   \                     ??FLASH_EraseBlock_1:
   \   000051 BE00                  LDW       X, S:?w4
   \   000053 A3000A                CPW       X, #0xa
   \   000056 250F                  JRC       L:??FLASH_EraseBlock_4
   \   000058 AE0259                LDW       X, #0x259
   \   00005B BF00                  LDW       S:?w1, X
   \   00005D 5F                    CLRW      X
   \   00005E BF00                  LDW       S:?w0, X
   \   000060 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000063 8D000000              CALLF     assert_failed
    602                startaddress = FLASH_DATA_START_PHYSICAL_ADDRESS;
   \                     ??FLASH_EraseBlock_4:
   \   000067 AE4000                LDW       X, #0x4000
   \   00006A BF00                  LDW       S:?w3, X
   \   00006C 5F                    CLRW      X
   \   00006D BF00                  LDW       S:?w2, X
    603            }
    604          
    605              /* Point to the first block address */
    606          #if defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined (STM8AF62Ax) || defined (STM8AF52Ax)
    607              pwFlash = (PointerAttr uint8_t *)(uint32_t)(startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE));
    608          #elif defined(STM8S105) || defined(STM8S005) || defined(STM8S103) || defined(STM8S003) || \
    609                defined (STM8S903) || defined (STM8AF626x)
    610              pwFlash = (PointerAttr uint32_t *)(uint16_t)(startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE));
   \                     ??FLASH_EraseBlock_3:
   \   00006F AE0040                LDW       X, #0x40
   \   000072 BF00                  LDW       S:?w0, X
   \   000074 BE00                  LDW       X, S:?w4
   \   000076 8D000000              CALLF     L:?mul16_x_x_w0
   \   00007A 90BE00                LDW       Y, S:?w3
   \   00007D BF00                  LDW       S:?w0, X
   \   00007F 72B90000              ADDW      Y, S:?w0
    611          #endif	/* STM8S208, STM8S207 */
    612          
    613              /* Enable erase block mode */
    614              FLASH->CR2 |= FLASH_CR2_ERASE;
   \   000083 721A505B              BSET      L:0x505b, #0x5
    615              FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NERASE);
   \   000087 721B505C              BRES      L:0x505c, #0x5
    616          
    617          #if defined(STM8S105) || defined(STM8S005) || defined(STM8S103) || defined(STM8S003) ||  \
    618              defined (STM8S903) || defined (STM8AF626x)
    619              *pwFlash = (uint32_t)0;
   \   00008B 5F                    CLRW      X
   \   00008C BF00                  LDW       S:?w1, X
   \   00008E BF00                  LDW       S:?w0, X
   \   000090 93                    LDW       X, Y
   \   000091 8D000000              CALLF     L:?load32_0x_l0
    620          #elif defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined (STM8AF62Ax) || \
    621                defined (STM8AF52Ax)
    622            *pwFlash = (uint8_t)0;
    623            *(pwFlash + 1) = (uint8_t)0;
    624            *(pwFlash + 2) = (uint8_t)0;
    625            *(pwFlash + 3) = (uint8_t)0;    
    626          #endif
    627          }
   \   000095 320000                POP       S:?b10
   \   000098 AC000000              JPF       L:?epilogue_w4
    628          
    629          /**
    630            * @brief  Programs a memory block
    631            * @note   This function should be called and executed from RAM.
    632            * @param  FLASH_MemType : The type of memory to program
    633            * @param  BlockNum : The block number
    634            * @param  FLASH_ProgMode : The programming mode.
    635            * @param  Buffer : Pointer to buffer containing source data.
    636            * @retval None.
    637            */

   \                                 In section .far_func.text, align 1
    638          IN_RAM(void FLASH_ProgramBlock(uint16_t BlockNum, FLASH_MemType_TypeDef FLASH_MemType, 
    639                                  FLASH_ProgramMode_TypeDef FLASH_ProgMode, uint8_t *Buffer))
    640          {
   \                     FLASH_ProgramBlock:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l3
   \   000008 9089                  PUSHW     Y
   \   00000A BF00                  LDW       S:?w7, X
   \   00000C B700                  LD        S:?b12, A
   \   00000E 450000                MOV       S:?b13, S:?b0
    641              uint16_t Count = 0;
   \   000011 3F00                  CLR       S:?b1
   \   000013 3F00                  CLR       S:?b0
    642              uint32_t startaddress = 0;
   \   000015 5F                    CLRW      X
   \   000016 BF00                  LDW       S:?w5, X
   \   000018 BF00                  LDW       S:?w4, X
    643          
    644              /* Check parameters */
    645              assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   00001A B600                  LD        A, S:?b12
   \   00001C A1FD                  CP        A, #0xfd
   \   00001E 2715                  JREQ      L:??FLASH_ProgramBlock_0
   \   000020 B600                  LD        A, S:?b12
   \   000022 A1F7                  CP        A, #0xf7
   \   000024 270F                  JREQ      L:??FLASH_ProgramBlock_0
   \   000026 AE0285                LDW       X, #0x285
   \   000029 BF00                  LDW       S:?w1, X
   \   00002B 5F                    CLRW      X
   \   00002C BF00                  LDW       S:?w0, X
   \   00002E AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000031 8D000000              CALLF     assert_failed
    646              assert_param(IS_FLASH_PROGRAM_MODE_OK(FLASH_ProgMode));
   \                     ??FLASH_ProgramBlock_0:
   \   000035 3D00                  TNZ       S:?b13
   \   000037 2715                  JREQ      L:??FLASH_ProgramBlock_1
   \   000039 B600                  LD        A, S:?b13
   \   00003B A110                  CP        A, #0x10
   \   00003D 270F                  JREQ      L:??FLASH_ProgramBlock_1
   \   00003F AE0286                LDW       X, #0x286
   \   000042 BF00                  LDW       S:?w1, X
   \   000044 5F                    CLRW      X
   \   000045 BF00                  LDW       S:?w0, X
   \   000047 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00004A 8D000000              CALLF     assert_failed
    647              if (FLASH_MemType == FLASH_MEMTYPE_PROG)
   \                     ??FLASH_ProgramBlock_1:
   \   00004E B600                  LD        A, S:?b12
   \   000050 A1FD                  CP        A, #0xfd
   \   000052 2620                  JRNE      L:??FLASH_ProgramBlock_2
    648              {
    649                  assert_param(IS_FLASH_PROG_BLOCK_NUMBER_OK(BlockNum));
   \   000054 BE00                  LDW       X, S:?w7
   \   000056 A30080                CPW       X, #0x80
   \   000059 250F                  JRC       L:??FLASH_ProgramBlock_3
   \   00005B AE0289                LDW       X, #0x289
   \   00005E BF00                  LDW       S:?w1, X
   \   000060 5F                    CLRW      X
   \   000061 BF00                  LDW       S:?w0, X
   \   000063 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000066 8D000000              CALLF     assert_failed
    650                  startaddress = FLASH_PROG_START_PHYSICAL_ADDRESS;
   \                     ??FLASH_ProgramBlock_3:
   \   00006A AE8000                LDW       X, #0x8000
   \   00006D BF00                  LDW       S:?w5, X
   \   00006F 58                    SLLW      X
   \   000070 BF00                  LDW       S:?w4, X
   \   000072 201E                  JRA       L:??FLASH_ProgramBlock_4
    651              }
    652              else
    653              {
    654                  assert_param(IS_FLASH_DATA_BLOCK_NUMBER_OK(BlockNum));
   \                     ??FLASH_ProgramBlock_2:
   \   000074 BE00                  LDW       X, S:?w7
   \   000076 A3000A                CPW       X, #0xa
   \   000079 250F                  JRC       L:??FLASH_ProgramBlock_5
   \   00007B AE028E                LDW       X, #0x28e
   \   00007E BF00                  LDW       S:?w1, X
   \   000080 5F                    CLRW      X
   \   000081 BF00                  LDW       S:?w0, X
   \   000083 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000086 8D000000              CALLF     assert_failed
    655                  startaddress = FLASH_DATA_START_PHYSICAL_ADDRESS;
   \                     ??FLASH_ProgramBlock_5:
   \   00008A AE4000                LDW       X, #0x4000
   \   00008D BF00                  LDW       S:?w5, X
   \   00008F 5F                    CLRW      X
   \   000090 BF00                  LDW       S:?w4, X
    656              }
    657          
    658              /* Point to the first block address */
    659              startaddress = startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE);
   \                     ??FLASH_ProgramBlock_4:
   \   000092 8D000000              CALLF     L:?mov_w1_w7
   \   000096 5F                    CLRW      X
   \   000097 BF00                  LDW       S:?w0, X
   \   000099 AE0040                LDW       X, #0x40
   \   00009C BF00                  LDW       S:?w3, X
   \   00009E 5F                    CLRW      X
   \   00009F BF00                  LDW       S:?w2, X
   \   0000A1 8D000000              CALLF     L:?mul32_l0_l0_l1
   \   0000A5 8D000000              CALLF     L:?mov_l1_l0
   \   0000A9 8D000000              CALLF     L:?mov_l0_l2
   \   0000AD 8D000000              CALLF     L:?add32_l0_l0_l1
   \   0000B1 8D000000              CALLF     L:?mov_l2_l0
    660          
    661              /* Selection of Standard or Fast programming mode */
    662              if (FLASH_ProgMode == FLASH_PROGRAMMODE_STANDARD)
   \   0000B5 3D00                  TNZ       S:?b13
   \   0000B7 260A                  JRNE      L:??FLASH_ProgramBlock_6
    663              {
    664                  /* Standard programming mode */ /*No need in standard mode */
    665                  FLASH->CR2 |= FLASH_CR2_PRG;
   \   0000B9 7210505B              BSET      L:0x505b, #0x0
    666                  FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NPRG);
   \   0000BD 7211505C              BRES      L:0x505c, #0x0
   \   0000C1 2008                  JRA       L:??FLASH_ProgramBlock_7
    667              }
    668              else
    669              {
    670                  /* Fast programming mode */
    671                  FLASH->CR2 |= FLASH_CR2_FPRG;
   \                     ??FLASH_ProgramBlock_6:
   \   0000C3 7218505B              BSET      L:0x505b, #0x4
    672                  FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NFPRG);
   \   0000C7 7219505C              BRES      L:0x505c, #0x4
    673              }
    674          
    675              /* Copy data bytes from RAM to FLASH memory */
    676              for (Count = 0; Count < FLASH_BLOCK_SIZE; Count++)
   \                     ??FLASH_ProgramBlock_7:
   \   0000CB 3F00                  CLR       S:?b1
   \   0000CD 3F00                  CLR       S:?b0
   \   0000CF 2014                  JRA       L:??FLASH_ProgramBlock_8
    677              {
    678          #if defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined(STM8S105) || \
    679              defined(STM8S005) || defined (STM8AF62Ax) || defined (STM8AF52Ax) || defined (STM8AF626x)
    680            *((PointerAttr uint8_t*) (uint16_t)startaddress + Count) = ((uint8_t)(Buffer[Count]));
    681          #elif defined(STM8S103) || defined(STM8S003) ||  defined (STM8S903)
    682            *((PointerAttr uint8_t*) (uint16_t)startaddress + Count) = ((uint8_t)(Buffer[Count]));
   \                     ??FLASH_ProgramBlock_9:
   \   0000D1 BE00                  LDW       X, S:?w5
   \   0000D3 72BB0000              ADDW      X, S:?w0
   \   0000D7 90BE00                LDW       Y, S:?w0
   \   0000DA 72F901                ADDW      Y, (0x1,SP)
   \   0000DD 90F6                  LD        A, (Y)
   \   0000DF F7                    LD        (X), A
    683          #endif       
    684              }
   \   0000E0 BE00                  LDW       X, S:?w0
   \   0000E2 5C                    INCW      X
   \   0000E3 BF00                  LDW       S:?w0, X
   \                     ??FLASH_ProgramBlock_8:
   \   0000E5 BE00                  LDW       X, S:?w0
   \   0000E7 A30040                CPW       X, #0x40
   \   0000EA 25E5                  JRC       L:??FLASH_ProgramBlock_9
    685          }
   \   0000EC 5B02                  ADD       SP, #0x2
   \   0000EE AC000000              JPF       L:?epilogue_l2_l3

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "D:\\\\Project\\\\STM8S_StdP...">`:
   \   000000 443A5C50726F          DC8 44H, 3AH, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \   000008 63745C53544D          DC8 63H, 74H, 5CH, 53H, 54H, 4DH, 38H, 53H
   \   000010 5F5374645065          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \   000018 70685F4C6962          DC8 70H, 68H, 5FH, 4CH, 69H, 62H, 5FH, 56H
   \   000020 322E312E305C          DC8 32H, 2EH, 31H, 2EH, 30H, 5CH, 4CH, 69H
   \   000028 627261726965          DC8 62H, 72H, 61H, 72H, 69H, 65H, 73H, 5CH
   \   000030 53544D38535F          DC8 53H, 54H, 4DH, 38H, 53H, 5FH, 53H, 74H
   \   000038 645065726970          DC8 64H, 50H, 65H, 72H, 69H, 70H, 68H, 5FH
   \   000040 447269766572          DC8 44H, 72H, 69H, 76H, 65H, 72H, 5CH, 73H
   \   000048 72635C73746D          DC8 72H, 63H, 5CH, 73H, 74H, 6DH, 38H, 73H
   \   000050 5F666C617368          DC8 5FH, 66H, 6CH, 61H, 73H, 68H, 2EH, 63H
   \   000058 00                    DC8 0
    686          
    687          #if defined (_COSMIC_) && defined (RAM_EXECUTION)
    688           /* End of FLASH_CODE section */
    689           #pragma section ()
    690          #endif /* _COSMIC_ && RAM_EXECUTION */
    691          
    692          
    693          /**
    694            * @}
    695            */
    696            
    697          /**
    698            * @}
    699            */
    700            
    701          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     FLASH_Unlock                               60
     FLASH_Lock                                 44
     FLASH_DeInit                               24
     FLASH_ITConfig                             48
     FLASH_EraseByte                            91
     FLASH_ProgramByte                         100
     FLASH_ReadByte                             90
     FLASH_ProgramWord                         128
     FLASH_ProgramOptionByte                    92
     FLASH_EraseOptionByte                      80
     FLASH_ReadOptionByte                      107
     FLASH_SetLowPowerMode                      62
     FLASH_SetProgrammingTime                   46
     FLASH_GetLowPowerMode                       6
     FLASH_GetProgrammingTime                    6
     FLASH_GetBootSize                          70
     FLASH_GetFlagStatus                        69
     FLASH_WaitForLastOperation                 55
     FLASH_EraseBlock                          156
     FLASH_ProgramBlock                        242
     ?<Constant "D:\\Project\\STM8S_StdP...">   89

 
 1 576 bytes in section .far_func.text
    89 bytes in section .near.rodata
 
 1 576 bytes of CODE  memory
    89 bytes of CONST memory

Errors: none
Warnings: none
