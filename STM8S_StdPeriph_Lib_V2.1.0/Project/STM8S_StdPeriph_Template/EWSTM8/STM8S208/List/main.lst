###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             03/Feb/2015  08:22:52 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\main.c                                    #
#    Command line =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\main.c -e -Ol --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_cross_call   #
#                    --debug --code_model medium --data_model medium -o       #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\Obj\ --dlib_config        #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.0\stm8\LIB\dlstm8mmn.h" -D USE_STM8_128_EVAL -D        #
#                    STM8S003 -lC D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Proje #
#                    ct\STM8S_StdPeriph_Template\EWSTM8\STM8S208\List\ -lb    #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\ -I                  #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\ -I                             #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\..\..\Libraries\STM8S_StdPeriph #
#                    _Driver\inc\ -I D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Pr #
#                    oject\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Utilities #
#                    \STM8S_EVAL\ -I D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Pr #
#                    oject\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Utilities #
#                    \STM8S_EVAL\STM8S-128_EVAL\ -I                           #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\..\..\Utilities\STM8S_EVAL\Comm #
#                    on\ --vregs 16                                           #
#    List file    =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\main.lst             #
#    Object file  =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\Obj\main.o                #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdPeriph_Template\main.c
      1          /**
      2            ******************************************************************************
      3            * @file UART1_Printf\main.c
      4            * @brief This file contains the main function for: retarget the C library printf
      5            *        /scanf functions to the UART1 example.
      6            * @author  MCD Application Team
      7            * @version  V2.0.1
      8            * @date     18-November-2011
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     14            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     15            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     16            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     17            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18            *
     19            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     20            ******************************************************************************
     21            */
     22          
     23          /* Includes ------------------------------------------------------------------*/
     24          #include "stm8s.h"
     25          #include "stdio.h"
     26          #include "string.h"

   \                                 In section .far_func.text, align 1
   \   __intrinsic __nounwind __far_func char *strstr(char const *, char const *)
   \                     strstr:
   \   000000 AC000000              JPF       __iar_Strstr
     27          #include "stdlib.h"
     28          #include "stm8s_it.h"
     29          /**
     30            * @addtogroup UART1_Printf
     31            * @{
     32            */
     33          /* Private typedef -----------------------------------------------------------*/
     34          /* Private define ------------------------------------------------------------*/
     35          #ifdef _RAISONANCE_
     36          #define PUTCHAR_PROTOTYPE int putchar (char c)
     37          #define GETCHAR_PROTOTYPE int getchar (void)
     38          #elif defined (_COSMIC_)
     39          #define PUTCHAR_PROTOTYPE char putchar (char c)
     40          #define GETCHAR_PROTOTYPE char getchar (void)
     41          #else /* _IAR_ */
     42          #define PUTCHAR_PROTOTYPE int putchar (int c)
     43          #define GETCHAR_PROTOTYPE int getchar (void)
     44          #endif /* _RAISONANCE_ */
     45          /* Private macro -------------------------------------------------------------*/
     46          

   \                                 In section .near.data, align 1
     47          char IP_ADDRESS_SERVER[] = "123.15.65.32:8080";//"www.google.com.vn"
   \                     IP_ADDRESS_SERVER:
   \   000000 3132332E3135          DC8 "123.15.65.32:8080"
     48          //char PORT_SERVER[] = "2082";
     49          
     50          #define PWKEY_GPIO_PORT  (GPIOD)
     51          #define PWKEY_GPIO_PINS  (GPIO_PIN_4)
     52          #define DTR_GPIO_PINS  (GPIO_PIN_3)
     53          #define TIM4_PERIOD       124 // generate interrupt timer after 1ms
     54          #define true     (bool)1
     55          #define false    (bool)0
     56          /* Private variables ---------------------------------------------------------*/
     57          typedef struct
     58          {
     59              char vol[5];
     60              char bat_percent[5] ;
     61              char charging[2] ;
     62          }BATTERRY_INFO ;
     63          

   \                                 In section .near.bss, align 1
     64          extern __IO uint32_t   system_tick = 0;
   \                     system_tick:
   \   000000                       DS8 4
     65          extern uint8_t  gps_fix ;
     66          extern UART_RECEIVE_STRUCT  uart_data ;    	
     67          BATTERRY_INFO getBatterry();
     68          /* Private function prototypes -----------------------------------------------*/
     69          void delay(uint16_t nTime);
     70          static void CLK_Config(void);
     71          static void TIM4_Config(void);
     72          
     73          void power_on();
     74          uint8_t start_GPS();
     75          uint8_t get_GPS(char *gprmc_buff_data);
     76          int8_t sendATcommand(char* ATcommand, char* expected_answer1, unsigned int timeout);
     77          void delay(uint16_t nCount);
     78          uint32_t millis() ;
     79          void Config_GPRS_SIM908();
     80          uint8_t HTTP_Terminate();
     81          /* Private function prototypes -----------------------------------------------*/
     82          /* Private functions ---------------------------------------------------------*/
     83          /**
     84            * @brief  Main program.
     85            * @param  None
     86            * @retval None
     87            */

   \                                 In section .far_func.text, align 1
     88          void setup()
     89          {
     90                  /* Clock configuration -----------------------------------------*/
     91              CLK_Config();
   \                     setup:
   \   000000 8D000000              CALLF     CLK_Config
     92              CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);
   \   000004 4F                    CLR       A
   \   000005 8D000000              CALLF     CLK_HSIPrescalerConfig
     93              /* TIM4 configuration -----------------------------------------*/
     94              TIM4_Config();
   \   000009 8D000000              CALLF     TIM4_Config
     95          
     96              UART1_DeInit();
   \   00000D 8D000000              CALLF     UART1_DeInit
     97              /* UART1 configuration ------------------------------------------------------*/
     98              /* UART1 configured as follow:
     99                  - BaudRate = 115200 baudu
    100                  - Word Length = 8 Bits
    101                  - One Stop Bit
    102                  - No parity
    103                  - Receive and transmit enabled
    104             	 - UART1 Clock disabled
    105              */
    106              UART1_Init((uint32_t)115200, UART1_WORDLENGTH_8D, UART1_STOPBITS_1, UART1_PARITY_NO,
    107                        UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_TXRX_ENABLE);
   \   000011 350C0000              MOV       S:?b7, #0xc
   \   000015 35800000              MOV       S:?b6, #0x80
   \   000019 3F00                  CLR       S:?b5
   \   00001B 3F00                  CLR       S:?b4
   \   00001D 4F                    CLR       A
   \   00001E AEC200                LDW       X, #0xc200
   \   000021 BF00                  LDW       S:?w1, X
   \   000023 5F                    CLRW      X
   \   000024 5C                    INCW      X
   \   000025 BF00                  LDW       S:?w0, X
   \   000027 8D000000              CALLF     UART1_Init
    108              UART1_ITConfig(UART1_IT_RXNE_OR, ENABLE);
   \   00002B A601                  LD        A, #0x1
   \   00002D AE0205                LDW       X, #0x205
   \   000030 8D000000              CALLF     UART1_ITConfig
    109              GPIO_Init(LED_GPIO_PORT, (GPIO_Pin_TypeDef)LED_GPIO_PINS|DTR_GPIO_PINS, GPIO_MODE_OUT_PP_LOW_FAST);
                                              ^
Warning[Pe188]: enumerated type mixed with another type
   \   000034 35E00000              MOV       S:?b0, #0xe0
   \   000038 A618                  LD        A, #0x18
   \   00003A AE5005                LDW       X, #0x5005
   \   00003D 8D000000              CALLF     GPIO_Init
    110              /* Enable general interrupts */
    111              enableInterrupts();
   \   000041 9A                    RIM
    112              power_on(); // Power up Sim908 module
   \   000042 8D000000              CALLF     power_on
    113              delay(10000);
   \   000046 AE2710                LDW       X, #0x2710
   \   000049 8D000000              CALLF     delay
    114              /*****Config Sim908 Module *****************************/
    115              sendATcommand("ATE0","OK",2000); // off echo
   \   00004D AE07D0                LDW       X, #0x7d0
   \   000050 BF00                  LDW       S:?w0, X
   \   000052 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   000056 AE0000                LDW       X, #`?<Constant "ATE0">`
   \   000059 8D000000              CALLF     sendATcommand
    116              //sendATcommand("AT+CIPSHUT","SHUT OK",3000); // disconect gprs
    117              //sendATcommand("AT+CSCLK=0","OK",2000);      // sleep mode
    118              GPIO_WriteLow(PWKEY_GPIO_PORT, (GPIO_Pin_TypeDef)DTR_GPIO_PINS); //wake up
   \   00005D A608                  LD        A, #0x8
   \   00005F AE500F                LDW       X, #0x500f
   \   000062 8D000000              CALLF     GPIO_WriteLow
    119              // Power up GPS
    120              sendATcommand("AT+CGPSPWR=1", "OK", 2000); // power up gps
   \   000066 AE07D0                LDW       X, #0x7d0
   \   000069 BF00                  LDW       S:?w0, X
   \   00006B 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   00006F AE0000                LDW       X, #`?<Constant "AT+CGPSPWR=1">`
   \   000072 8D000000              CALLF     sendATcommand
    121              // Reset GPS Cold mde
    122              sendATcommand("AT+CGPSRST=1", "OK", 2000);
   \   000076 AE07D0                LDW       X, #0x7d0
   \   000079 BF00                  LDW       S:?w0, X
   \   00007B 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   00007F AE0000                LDW       X, #`?<Constant "AT+CGPSRST=1">`
   \   000082 8D000000              CALLF     sendATcommand
    123              sendATcommand("AT+CREG=2","OK",2000);
   \   000086 AE07D0                LDW       X, #0x7d0
   \   000089 BF00                  LDW       S:?w0, X
   \   00008B 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   00008F AE0000                LDW       X, #`?<Constant "AT+CREG=2">`
   \   000092 8D000000              CALLF     sendATcommand
    124              //sendATcommand("AT+CIPSHUT","SHUT OK",30000);
    125              /************End Config Sim908 Module *****************************/
    126              delay(1000);
   \   000096 AE03E8                LDW       X, #0x3e8
   \   000099 8D000000              CALLF     delay
    127              while (sendATcommand("AT+CREG?", "+CREG: 2,1", 2000) == 0); //Wait register to network
   \                     ??setup_0:
   \   00009D AE07D0                LDW       X, #0x7d0
   \   0000A0 BF00                  LDW       S:?w0, X
   \   0000A2 90AE0000              LDW       Y, #`?<Constant "+CREG: 2,1">`
   \   0000A6 AE0000                LDW       X, #`?<Constant "AT+CREG?">`
   \   0000A9 8D000000              CALLF     sendATcommand
   \   0000AD A100                  CP        A, #0x0
   \   0000AF 27EC                  JREQ      L:??setup_0
    128              Config_GPRS_SIM908();
   \   0000B1 8D000000              CALLF     Config_GPRS_SIM908
    129              sendATcommand("AT+SAPBR=1,0","OK",200);
   \   0000B5 AE00C8                LDW       X, #0xc8
   \   0000B8 BF00                  LDW       S:?w0, X
   \   0000BA 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   0000BE AE0000                LDW       X, #`?<Constant "AT+SAPBR=1,0">`
   \   0000C1 8D000000              CALLF     sendATcommand
    130              sendATcommand("AT+CGATT=1","OK",2000);
   \   0000C5 AE07D0                LDW       X, #0x7d0
   \   0000C8 BF00                  LDW       S:?w0, X
   \   0000CA 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   0000CE AE0000                LDW       X, #`?<Constant "AT+CGATT=1">`
   \   0000D1 8D000000              CALLF     sendATcommand
    131              // sets APN , user name and password
    132              sendATcommand("AT+SAPBR=3,1,\"Contype\",\"GPRS\"", "OK", 2000);
   \   0000D5 AE07D0                LDW       X, #0x7d0
   \   0000D8 BF00                  LDW       S:?w0, X
   \   0000DA 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   0000DE AE0000                LDW       X, #`?<Constant "AT+SAPBR=3,1,\\"Contype...">`
   \   0000E1 8D000000              CALLF     sendATcommand
    133              sendATcommand("AT+SAPBR=3,1,\"APN\",\"v-internet\"", "OK", 2000);//3m-world
   \   0000E5 AE07D0                LDW       X, #0x7d0
   \   0000E8 BF00                  LDW       S:?w0, X
   \   0000EA 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   0000EE AE0000                LDW       X, #`?<Constant "AT+SAPBR=3,1,\\"APN\\",\\"v...">`
   \   0000F1 8D000000              CALLF     sendATcommand
    134              sendATcommand("AT+SAPBR=3,1,\"USER\",\"mms\"", "OK", 2000);
   \   0000F5 AE07D0                LDW       X, #0x7d0
   \   0000F8 BF00                  LDW       S:?w0, X
   \   0000FA 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   0000FE AE0000                LDW       X, #`?<Constant "AT+SAPBR=3,1,\\"USER\\",\\"...">`
   \   000101 8D000000              CALLF     sendATcommand
    135              sendATcommand("AT+SAPBR=3,1,\"PWD\",\"mms\"", "OK", 2000);
   \   000105 AE07D0                LDW       X, #0x7d0
   \   000108 BF00                  LDW       S:?w0, X
   \   00010A 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   00010E AE0000                LDW       X, #`?<Constant "AT+SAPBR=3,1,\\"PWD\\",\\"mms\\"">`
   \   000111 8D000000              CALLF     sendATcommand
    136              sendATcommand("AT+HTTPPARA= \"REDIR\",1","OK", 2000);
   \   000115 AE07D0                LDW       X, #0x7d0
   \   000118 BF00                  LDW       S:?w0, X
   \   00011A 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   00011E AE0000                LDW       X, #`?<Constant "AT+HTTPPARA= \\"REDIR\\",1">`
   \   000121 8D000000              CALLF     sendATcommand
    137              HTTP_Terminate();
   \   000125 8D000000              CALLF     HTTP_Terminate
    138              sendATcommand("AT+SAPBR=1,1", "OK", 2000);
   \   000129 AE07D0                LDW       X, #0x7d0
   \   00012C BF00                  LDW       S:?w0, X
   \   00012E 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   000132 AE0000                LDW       X, #`?<Constant "AT+SAPBR=1,1">`
   \   000135 AC000000              JPF       sendATcommand
    139              // gets the GPRS bearer
    140          //    while (sendATcommand("AT+SAPBR=1,1", "OK", 2000) == 0)
    141          //    {
    142          //        delay(2000);
    143          //    }
    144          	
    145          }
    146          
    147          

   \                                 In section .far_func.text, align 1
    148          uint8_t GetResponse(char *expected_answer , uint32_t timeout)
    149          {
   \                     GetResponse:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l3
   \   000008 89                    PUSHW     X
   \   000009 5201                  SUB       SP, #0x1
   \   00000B 8D000000              CALLF     L:?mov_l3_l0
    150              uint8_t answer = 0;
   \   00000F 4F                    CLR       A
   \   000010 6B01                  LD        (0x1,SP), A
    151              uint32_t previous ;
    152              previous = millis();
   \   000012 8D000000              CALLF     millis
   \   000016 8D000000              CALLF     L:?mov_l2_l0
    153              do
    154              {
    155                  if(uart_data.flag_uart_compelete)
   \                     ??GetResponse_0:
   \   00001A C60000                LD        A, L:uart_data + 100
   \   00001D A100                  CP        A, #0x0
   \   00001F 2714                  JREQ      L:??GetResponse_1
    156                  {
    157                      uart_data.flag_uart_compelete = 0;
   \   000021 35000000              MOV       L:uart_data + 100, #0x0
    158                      if (strstr(uart_data.buff, expected_answer) != NULL)
   \   000025 1602                  LDW       Y, (0x2,SP)
   \   000027 AE0000                LDW       X, #uart_data
   \   00002A 8D000000              CALLF     strstr
   \   00002E 5D                    TNZW      X
   \   00002F 2704                  JREQ      L:??GetResponse_1
    159                      {
    160                          answer = 1;
   \   000031 A601                  LD        A, #0x1
   \   000033 6B01                  LD        (0x1,SP), A
    161                      }
    162                  }
    163              }while((answer == 0) && ((millis() - previous) < timeout));
   \                     ??GetResponse_1:
   \   000035 0D01                  TNZ       (0x1,SP)
   \   000037 2616                  JRNE      L:??GetResponse_2
   \   000039 8D000000              CALLF     millis
   \   00003D 8D000000              CALLF     L:?mov_l1_l2
   \   000041 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   000045 8D000000              CALLF     L:?mov_l1_l3
   \   000049 8D000000              CALLF     L:?ucmp32_c_l0_l1
   \   00004D 25CB                  JRC       L:??GetResponse_0
    164              if ((millis() - previous) < timeout)
   \                     ??GetResponse_2:
   \   00004F 8D000000              CALLF     millis
   \   000053 8D000000              CALLF     L:?mov_l1_l2
   \   000057 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   00005B 8D000000              CALLF     L:?mov_l1_l3
   \   00005F 8D000000              CALLF     L:?ucmp32_c_l0_l1
   \   000063 2404                  JRNC      L:??GetResponse_3
    165              {
    166                  return 1;
   \   000065 A601                  LD        A, #0x1
   \   000067 2001                  JRA       L:??GetResponse_4
    167              }
    168              else
    169              {
    170                  return 0;
   \                     ??GetResponse_3:
   \   000069 4F                    CLR       A
   \                     ??GetResponse_4:
   \   00006A 5B03                  ADD       SP, #0x3
   \   00006C AC000000              JPF       L:?epilogue_l2_l3
    171              }
    172          }
    173          
    174          

   \                                 In section .far_func.text, align 1, keep-with-next
    175          void GetCmdDataSIM(char *str , char DATA_AT[5][10])
    176          {
   \                     GetCmdDataSIM:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_w6
   \   000008 90BF00                LDW       S:?w6, Y
    177              //char DATA_AT[5][10];
    178              char * pch;
    179              int i=0;
   \   00000B 3F00                  CLR       S:?b9
   \   00000D 3F00                  CLR       S:?b8
    180              pch = strtok (str,":");
   \   00000F 90AE0000              LDW       Y, #`?<Constant ":">`
   \   000013 8D000000              CALLF     strtok
   \   000017 BF00                  LDW       S:?w5, X
    181              while (pch != NULL)
   \                     ??GetCmdDataSIM_0:
   \   000019 BE00                  LDW       X, S:?w5
   \   00001B 5D                    TNZW      X
   \   00001C 272D                  JREQ      L:??GetCmdDataSIM_1
    182              {
    183                  pch = strtok(NULL,",\"\r\n");
   \   00001E 90AE0000              LDW       Y, #`?<Constant ",\\"\\r\\n">`
   \   000022 5F                    CLRW      X
   \   000023 8D000000              CALLF     strtok
   \   000027 BF00                  LDW       S:?w5, X
    184                  strcpy(DATA_AT[i++],pch);
   \   000029 90BE00                LDW       Y, S:?w5
   \   00002C AE000A                LDW       X, #0xa
   \   00002F BF00                  LDW       S:?w0, X
   \   000031 BE00                  LDW       X, S:?w4
   \   000033 8D000000              CALLF     L:?mul16_x_x_w0
   \   000037 72BB0000              ADDW      X, S:?w6
   \   00003B 8D000000              CALLF     strcpy
   \   00003F BE00                  LDW       X, S:?w4
   \   000041 5C                    INCW      X
   \   000042 BF00                  LDW       S:?w4, X
    185                  if(i == 5) break;
   \   000044 BE00                  LDW       X, S:?w4
   \   000046 A30005                CPW       X, #0x5
   \   000049 26CE                  JRNE      L:??GetCmdDataSIM_0
    186              }
    187          }
   \                     ??GetCmdDataSIM_1:
   \   00004B AC000000              JPF       L:?epilogue_l2_w6
    188          

   \                                 In section .far_func.text, align 1, keep-with-next
    189          BATTERRY_INFO getBatterry()
    190          {
   \                     getBatterry:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 523E                  SUB       SP, #0x3e
   \   000006 BF00                  LDW       S:?w4, X
    191              char DATA_AT[5][10] ;
    192              BATTERRY_INFO info_bat ;
    193              printf("AT+CBC\r");
   \   000008 AE0000                LDW       X, #`?<Constant "AT+CBC\\r">`
   \   00000B 8D000000              CALLF     printf
    194              if(GetResponse("+CBC:", 2000))
   \   00000F AE07D0                LDW       X, #0x7d0
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "+CBC:">`
   \   00001A 8D000000              CALLF     GetResponse
   \   00001E A100                  CP        A, #0x0
   \   000020 2747                  JREQ      L:??getBatterry_0
    195              {
    196                  GetCmdDataSIM(uart_data.buff ,DATA_AT);
   \   000022 9096                  LDW       Y, SP
   \   000024 72A9000D              ADDW      Y, #0xd
   \   000028 AE0000                LDW       X, #uart_data
   \   00002B 8D000000              CALLF     GetCmdDataSIM
    197                  strcpy(info_bat.charging ,DATA_AT[0]);
   \   00002F 9096                  LDW       Y, SP
   \   000031 72A9000D              ADDW      Y, #0xd
   \   000035 96                    LDW       X, SP
   \   000036 1C000B                ADDW      X, #0xb
   \   000039 8D000000              CALLF     strcpy
    198                  strcpy(info_bat.bat_percent ,DATA_AT[1]);
   \   00003D 9096                  LDW       Y, SP
   \   00003F 72A90017              ADDW      Y, #0x17
   \   000043 96                    LDW       X, SP
   \   000044 1C0006                ADDW      X, #0x6
   \   000047 8D000000              CALLF     strcpy
    199                  strcpy(info_bat.vol ,DATA_AT[2]);
   \   00004B 9096                  LDW       Y, SP
   \   00004D 72A90021              ADDW      Y, #0x21
   \   000051 96                    LDW       X, SP
   \   000052 1C0001                ADDW      X, #0x1
   \   000055 8D000000              CALLF     strcpy
    200                  return info_bat ;
   \   000059 9096                  LDW       Y, SP
   \   00005B 72A90001              ADDW      Y, #0x1
   \   00005F BE00                  LDW       X, S:?w4
   \   000061 89                    PUSHW     X
   \   000062 A60C                  LD        A, #0xc
   \   000064 8D000000              CALLF     L:?move1616_v_x_y_a
   \   000068 85                    POPW      X
    201              }
    202          //    return 0;
    203          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "getBatterry"
   \                     ??getBatterry_0:
   \   000069 5B3E                  ADD       SP, #0x3e
   \   00006B AC000000              JPF       L:?epilogue_w4
    204          typedef struct
    205          {
    206            char MNC[3];
    207            char LAC[5];
    208            char CELLID[5];
    209          }CELLID_INFO;
    210          

   \                                 In section .far_func.text, align 1
    211          CELLID_INFO getLacCellid()
    212          {
   \                     getLacCellid:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 523F                  SUB       SP, #0x3f
   \   000006 BF00                  LDW       S:?w4, X
    213              char DATA_AT[5][10] ;
    214              CELLID_INFO info_cellid ;
    215          
    216              printf("AT+CREG?\r");
   \   000008 AE0000                LDW       X, #`?<Constant "AT+CREG?\\r">`
   \   00000B 8D000000              CALLF     printf
    217              if(GetResponse("+CREG:", 2000))
   \   00000F AE07D0                LDW       X, #0x7d0
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "+CREG:">`
   \   00001A 8D000000              CALLF     GetResponse
   \   00001E A100                  CP        A, #0x0
   \   000020 2749                  JREQ      L:??getLacCellid_0
    218              {
    219                  GetCmdDataSIM(uart_data.buff ,DATA_AT);
   \   000022 9096                  LDW       Y, SP
   \   000024 72A9000E              ADDW      Y, #0xe
   \   000028 AE0000                LDW       X, #uart_data
   \   00002B 8D000000              CALLF     GetCmdDataSIM
    220                  strcpy(info_cellid.LAC,strtok (DATA_AT[2],"\""));
   \   00002F 90AE0000              LDW       Y, #`?<Constant "\\"">`
   \   000033 96                    LDW       X, SP
   \   000034 1C0022                ADDW      X, #0x22
   \   000037 8D000000              CALLF     strtok
   \   00003B 9093                  LDW       Y, X
   \   00003D 96                    LDW       X, SP
   \   00003E 1C0004                ADDW      X, #0x4
   \   000041 8D000000              CALLF     strcpy
    221                  strcpy(info_cellid.CELLID ,strtok (DATA_AT[3],"\""));
   \   000045 90AE0000              LDW       Y, #`?<Constant "\\"">`
   \   000049 96                    LDW       X, SP
   \   00004A 1C002C                ADDW      X, #0x2c
   \   00004D 8D000000              CALLF     strtok
   \   000051 9093                  LDW       Y, X
   \   000053 96                    LDW       X, SP
   \   000054 1C0009                ADDW      X, #0x9
   \   000057 8D000000              CALLF     strcpy
    222                  return info_cellid ;
   \   00005B 9096                  LDW       Y, SP
   \   00005D 72A90001              ADDW      Y, #0x1
   \   000061 BE00                  LDW       X, S:?w4
   \   000063 89                    PUSHW     X
   \   000064 A60D                  LD        A, #0xd
   \   000066 8D000000              CALLF     L:?move1616_v_x_y_a
   \   00006A 85                    POPW      X
    223              }
    224          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "getLacCellid"
   \                     ??getLacCellid_0:
   \   00006B 5B3F                  ADD       SP, #0x3f
   \   00006D AC000000              JPF       L:?epilogue_w4

   \                                 In section .far_func.text, align 1
    225          uint32_t millis()
    226          {
    227          	return system_tick ;
   \                     millis:
   \   000000 AE0000                LDW       X, #system_tick
   \   000003 AC000000              JPF       L:?load32_l0_0x
    228          }
    229          

   \                                 In section .far_func.text, align 1, keep-with-next
    230          void power_on()
    231          {
   \                     power_on:
   \   000000 3B0000                PUSH      S:?b8
    232              uint8_t answer=0;
   \   000003 3F00                  CLR       S:?b8
    233              /* Initialize I/Os in Output Mode */
    234              GPIO_Init(PWKEY_GPIO_PORT,(GPIO_Pin_TypeDef)PWKEY_GPIO_PINS|DTR_GPIO_PINS, GPIO_MODE_OUT_PP_LOW_FAST);
                                               ^
Warning[Pe188]: enumerated type mixed with another type
   \   000005 35E00000              MOV       S:?b0, #0xe0
   \   000009 A618                  LD        A, #0x18
   \   00000B AE500F                LDW       X, #0x500f
   \   00000E 8D000000              CALLF     GPIO_Init
    235              // checks if the module is started
    236              answer = sendATcommand("AT", "OK", 2000);
   \   000012 AE07D0                LDW       X, #0x7d0
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   00001B AE0000                LDW       X, #`?<Constant "AT">`
   \   00001E 8D000000              CALLF     sendATcommand
   \   000022 B700                  LD        S:?b8, A
    237              if (answer == 0)
   \   000024 3D00                  TNZ       S:?b8
   \   000026 2641                  JRNE      L:??power_on_0
    238              {   // power on pulse
    239                  GPIO_WriteHigh(PWKEY_GPIO_PORT, (GPIO_Pin_TypeDef)PWKEY_GPIO_PINS);;
   \   000028 A610                  LD        A, #0x10
   \   00002A AE500F                LDW       X, #0x500f
   \   00002D 8D000000              CALLF     GPIO_WriteHigh
    240                  delay(3000);
   \   000031 AE0BB8                LDW       X, #0xbb8
   \   000034 8D000000              CALLF     delay
    241                  GPIO_WriteLow(PWKEY_GPIO_PORT, (GPIO_Pin_TypeDef)PWKEY_GPIO_PINS);;
   \   000038 A610                  LD        A, #0x10
   \   00003A AE500F                LDW       X, #0x500f
   \   00003D 8D000000              CALLF     GPIO_WriteLow
    242                  //Wake up
    243                  GPIO_WriteLow(PWKEY_GPIO_PORT, (GPIO_Pin_TypeDef)DTR_GPIO_PINS);
   \   000041 A608                  LD        A, #0x8
   \   000043 AE500F                LDW       X, #0x500f
   \   000046 8D000000              CALLF     GPIO_WriteLow
    244                  // waits for an answer from the module
    245                  printf("ATE0\r");
   \   00004A AE0000                LDW       X, #`?<Constant "ATE0\\r">`
   \   00004D 8D000000              CALLF     printf
   \   000051 2012                  JRA       L:??power_on_1
    246                  while(answer == 0)
    247                  {
    248                      // Send AT every two seconds and wait for the answer
    249                      answer = sendATcommand("AT\r", "OK", 2000);
   \                     ??power_on_2:
   \   000053 AE07D0                LDW       X, #0x7d0
   \   000056 BF00                  LDW       S:?w0, X
   \   000058 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   00005C AE0000                LDW       X, #`?<Constant "AT\\r">`
   \   00005F 8D000000              CALLF     sendATcommand
   \   000063 B700                  LD        S:?b8, A
    250                     //while(UART1_GetFlagStatus(UART1_FLAG_RXNE) == RESET);
    251                  }
   \                     ??power_on_1:
   \   000065 3D00                  TNZ       S:?b8
   \   000067 27EA                  JREQ      L:??power_on_2
    252              }
    253              printf("ATE0\r");
   \                     ??power_on_0:
   \   000069 AE0000                LDW       X, #`?<Constant "ATE0\\r">`
   \   00006C 8D000000              CALLF     printf
    254          }
   \   000070 320000                POP       S:?b8
   \   000073 87                    RETF
    255          
    256          

   \                                 In section .far_func.text, align 1, keep-with-next
    257          uint8_t start_GPS(){
   \                     start_GPS:
   \   000000 8D000000              CALLF     L:?push_l2
    258          
    259              uint32_t previous;
                              ^
Warning[Pe550]: variable "previous" was set but never used
    260          
    261              previous = millis();
   \   000004 8D000000              CALLF     millis
   \   000008 8D000000              CALLF     L:?mov_l2_l0
    262              //Wake up Module Sim
    263              //GPIO_WriteLow(PWKEY_GPIO_PORT, (GPIO_Pin_TypeDef)DTR_GPIO_PINS);
    264              // Power up GPS
    265              //sendATcommand("AT+CGPSPWR=1", "OK", 2000);
    266              // Reset GPS Hot mde
    267             // sendATcommand("AT+CGPSRST=1", "OK", 2000);
    268              // waits for fix GPS
    269              if((sendATcommand("AT+CGPSSTATUS?", "2D Fix", 2000) == 1 ||
    270                  sendATcommand("AT+CGPSSTATUS?", "3D Fix", 2000)) == 1 )
   \   00000C AE07D0                LDW       X, #0x7d0
   \   00000F BF00                  LDW       S:?w0, X
   \   000011 90AE0000              LDW       Y, #`?<Constant "2D Fix">`
   \   000015 AE0000                LDW       X, #`?<Constant "AT+CGPSSTATUS?">`
   \   000018 8D000000              CALLF     sendATcommand
   \   00001C A101                  CP        A, #0x1
   \   00001E 2714                  JREQ      L:??start_GPS_0
   \   000020 AE07D0                LDW       X, #0x7d0
   \   000023 BF00                  LDW       S:?w0, X
   \   000025 90AE0000              LDW       Y, #`?<Constant "3D Fix">`
   \   000029 AE0000                LDW       X, #`?<Constant "AT+CGPSSTATUS?">`
   \   00002C 8D000000              CALLF     sendATcommand
   \   000030 A100                  CP        A, #0x0
   \   000032 2704                  JREQ      L:??start_GPS_1
   \                     ??start_GPS_0:
   \   000034 A601                  LD        A, #0x1
   \   000036 2001                  JRA       L:??start_GPS_2
   \                     ??start_GPS_1:
   \   000038 4F                    CLR       A
   \                     ??start_GPS_2:
   \   000039 4D                    TNZ       A
   \   00003A 2706                  JREQ      L:??start_GPS_3
    271              {
    272                  return 1;
   \   00003C A601                  LD        A, #0x1
   \   00003E AC000000              JPF       L:?epilogue_l2
    273              }
    274              else
    275              {
    276                  return 0;
   \                     ??start_GPS_3:
   \   000042 4F                    CLR       A
   \   000043 AC000000              JPF       L:?epilogue_l2
    277              }
    278          }
    279          

   \                                 In section .far_func.text, align 1, keep-with-next
    280          uint8_t get_GPS(char *gprmc_buff_data)
    281          {
   \                     get_GPS:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    282             // First get the NMEA string
    283              char * pch;
    284              printf("AT+CGPSINF=32\r");
   \   000006 AE0000                LDW       X, #`?<Constant "AT+CGPSINF=32\\r">`
   \   000009 8D000000              CALLF     printf
    285              if(GetResponse("OK",2000))
   \   00000D AE07D0                LDW       X, #0x7d0
   \   000010 BF00                  LDW       S:?w1, X
   \   000012 5F                    CLRW      X
   \   000013 BF00                  LDW       S:?w0, X
   \   000015 AE0000                LDW       X, #`?<Constant "OK">`
   \   000018 8D000000              CALLF     GetResponse
   \   00001C A100                  CP        A, #0x0
   \   00001E 2719                  JREQ      L:??get_GPS_0
    286              {
    287          		//strcpy(gprmc_buff_data , uart_data.buff + 5);            
    288                  pch = strtok (uart_data.buff + 5,"\r\n");
   \   000020 90AE0000              LDW       Y, #`?<Constant "\\r\\n">`
   \   000024 AE0000                LDW       X, #uart_data + 5
   \   000027 8D000000              CALLF     strtok
    289                  strcpy(gprmc_buff_data , pch);
   \   00002B 9093                  LDW       Y, X
   \   00002D BE00                  LDW       X, S:?w4
   \   00002F 8D000000              CALLF     strcpy
    290          		return 1 ;
   \   000033 A601                  LD        A, #0x1
   \   000035 AC000000              JPF       L:?epilogue_w4
    291              }
    292              return 0;
   \                     ??get_GPS_0:
   \   000039 4F                    CLR       A
   \   00003A AC000000              JPF       L:?epilogue_w4
    293          }
    294          
    295          /*FUNCTION**********************************************************************
    296           *
    297           * Function Name : Config_GPRS_SIM908
    298           * Description   : Config GPRS for modul SIM908
    299           * This function use config gprs to sim908
    300           *
    301           *END**************************************************************************/

   \                                 In section .far_func.text, align 1, keep-with-next
    302          void Config_GPRS_SIM908()
    303          {
    304              sendATcommand("AT+CIPCSGP=1,\"v-internet\",\"\",\"\"","OK", 2000); // For Viettel Network
   \                     Config_GPRS_SIM908:
   \   000000 AE07D0                LDW       X, #0x7d0
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   000009 AE0000                LDW       X, #`?<Constant "AT+CIPCSGP=1,\\"v-inter...">`
   \   00000C AC000000              JPF       sendATcommand
    305              // VinaPhone
    306              //sendATcommand("AT+CIPCSGP=1,\"3m-world\",\"mms\",\"mms\"","OK", 2000); // For Vina Network
    307          }

   \                                 In section .far_func.text, align 1, keep-with-next
    308          uint8_t HTTP_init()
    309          {
    310          
    311              uint8_t answer ;
    312              // Initializes HTTP service
    313              answer = sendATcommand("AT+HTTPINIT", "OK", 10000);
   \                     HTTP_init:
   \   000000 AE2710                LDW       X, #0x2710
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   000009 AE0000                LDW       X, #`?<Constant "AT+HTTPINIT">`
   \   00000C 8D000000              CALLF     sendATcommand
    314              if (answer == 1)
   \   000010 A101                  CP        A, #0x1
   \   000012 2618                  JRNE      L:??HTTP_init_0
    315              {
    316                  // Sets CID parameter
    317                  answer = sendATcommand("AT+HTTPPARA=\"CID\",1", "OK", 5000);
   \   000014 AE1388                LDW       X, #0x1388
   \   000017 BF00                  LDW       S:?w0, X
   \   000019 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   00001D AE0000                LDW       X, #`?<Constant "AT+HTTPPARA=\\"CID\\",1">`
   \   000020 8D000000              CALLF     sendATcommand
    318                  if(!answer)
   \   000024 4D                    TNZ       A
   \   000025 2602                  JRNE      L:??HTTP_init_1
    319                  {
    320                      //printf("Error setting the CID");
    321                      return 0 ;
   \   000027 4F                    CLR       A
   \   000028 87                    RETF
    322                  }
    323                  return 1 ;
   \                     ??HTTP_init_1:
   \   000029 A601                  LD        A, #0x1
   \   00002B 87                    RETF
    324          
    325          
    326              }
    327              else
    328              {
    329                  //printf("Error initializating");
    330                  return 0;
   \                     ??HTTP_init_0:
   \   00002C 4F                    CLR       A
   \   00002D 87                    RETF
    331              }
    332          }
    333          

   \                                 In section .far_func.text, align 1, keep-with-next
    334          uint8_t HTTP_Terminate()
    335          {
    336              uint8_t answer ;
    337              answer =  sendATcommand("AT+HTTPTERM", "OK", 5000);
   \                     HTTP_Terminate:
   \   000000 AE1388                LDW       X, #0x1388
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   000009 AE0000                LDW       X, #`?<Constant "AT+HTTPTERM">`
   \   00000C AC000000              JPF       sendATcommand
    338              return answer ;
    339          }
    340          

   \                                 In section .near.data, align 1
    341          char IMEI_DEVICE[] = "123456789";
   \                     IMEI_DEVICE:
   \   000000 313233343536          DC8 "123456789"

   \                                 In section .far_func.text, align 1, keep-with-next
    342          uint8_t HTTP_Send(char *gprmc_data , char *IMEI)
    343          {
   \                     HTTP_Send:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 52B4                  SUB       SP, #0xb4
   \   000006 BF00                  LDW       S:?w5, X
   \   000008 90BF00                LDW       S:?w4, Y
    344          
    345          	uint8_t answer ;
    346          	char data_server[180];
    347          
    348              memset(data_server , '\0' ,sizeof(data_server)/sizeof(char));
   \   00000B AE00B4                LDW       X, #0xb4
   \   00000E BF00                  LDW       S:?w0, X
   \   000010 905F                  CLRW      Y
   \   000012 96                    LDW       X, SP
   \   000013 1C0001                ADDW      X, #0x1
   \   000016 8D000000              CALLF     memset
    349              // Sets url
    350              //sprintf(data_server, "AT+HTTPPARA=\"URL\",\"http://www.google.com.vn\"");
    351              sprintf(data_server, "AT+HTTPPARA=\"URL\",\"http://%s/gprmc/Data?acct=tracking&dev=gprmc_%s&gprmc=$GPRMC,%s\"", IP_ADDRESS_SERVER,IMEI,gprmc_data);
   \   00001A 8D000000              CALLF     L:?push_w5
   \   00001E 8D000000              CALLF     L:?push_w4
   \   000022 4B00                  PUSH      #BYTE1(IP_ADDRESS_SERVER)
   \   000024 4B00                  PUSH      #BYTE2(IP_ADDRESS_SERVER)
   \   000026 90AE0000              LDW       Y, #`?<Constant "AT+HTTPPARA=\\"URL\\",\\"ht...">`
   \   00002A 96                    LDW       X, SP
   \   00002B 1C0007                ADDW      X, #0x7
   \   00002E 8D000000              CALLF     sprintf
   \   000032 5B06                  ADD       SP, #0x6
    352              answer = sendATcommand(data_server, "OK", 5000);
   \   000034 AE1388                LDW       X, #0x1388
   \   000037 BF00                  LDW       S:?w0, X
   \   000039 90AE0000              LDW       Y, #`?<Constant "OK">`
   \   00003D 96                    LDW       X, SP
   \   00003E 1C0001                ADDW      X, #0x1
   \   000041 8D000000              CALLF     sendATcommand
    353              if (answer == 1)
   \   000045 A101                  CP        A, #0x1
   \   000047 2610                  JRNE      L:??HTTP_Send_0
    354              {
    355                  // Starts GET act , char IMEIion
    356                  answer = sendATcommand("AT+HTTPACTION=0", "+HTTPACTION:0,200", 40000);
   \   000049 AE9C40                LDW       X, #0x9c40
   \   00004C BF00                  LDW       S:?w0, X
   \   00004E 90AE0000              LDW       Y, #`?<Constant "+HTTPACTION:0,200">`
   \   000052 AE0000                LDW       X, #`?<Constant "AT+HTTPACTION=0">`
   \   000055 8D000000              CALLF     sendATcommand
    357              }
    358          
    359              return answer ;
   \                     ??HTTP_Send_0:
   \   000059 5BB4                  ADD       SP, #0xb4
   \   00005B AC000000              JPF       L:?epilogue_l2
    360          
    361          }
    362          

   \                                 In section .far_func.text, align 1, keep-with-next
    363          int8_t sendATcommand(char* ATcommand, char* expected_answer, unsigned int timeout)
    364          {
   \                     sendATcommand:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_w7
   \   000008 3B0000                PUSH      S:?b12
   \   00000B 8D000000              CALLF     L:?push_w0
   \   00000F 90BF00                LDW       S:?w7, Y
    365          
    366              uint8_t answer=0;
   \   000012 3F00                  CLR       S:?b12
    367              uint32_t previous;
                              ^
Warning[Pe550]: variable "previous" was set but never used
    368              printf("%s\r",ATcommand);    // Send the AT command
   \   000014 89                    PUSHW     X
   \   000015 AE0000                LDW       X, #`?<Constant "%s\\r">`
   \   000018 8D000000              CALLF     printf
   \   00001C 5B02                  ADD       SP, #0x2
    369              previous = millis();
   \   00001E 8D000000              CALLF     millis
   \   000022 8D000000              CALLF     L:?mov_l2_l0
    370              // this loop waits for the answer
    371              answer = GetResponse(expected_answer , timeout);
   \   000026 1E01                  LDW       X, (0x1,SP)
   \   000028 BF00                  LDW       S:?w1, X
   \   00002A 5F                    CLRW      X
   \   00002B BF00                  LDW       S:?w0, X
   \   00002D BE00                  LDW       X, S:?w7
   \   00002F 8D000000              CALLF     GetResponse
   \   000033 B700                  LD        S:?b12, A
    372              return answer;
   \   000035 B600                  LD        A, S:?b12
   \   000037 5B02                  ADD       SP, #0x2
   \   000039 320000                POP       S:?b12
   \   00003C 8D000000              CALLF     L:?pop_w7
   \   000040 AC000000              JPF       L:?epilogue_l2
    373          }
    374          

   \                                 In section .near.bss, align 1
    375          uint8_t event_send_gprs = 0 ;
   \                     event_send_gprs:
   \   000000                       DS8 1
    376          #define  TIME_SEND_GPRS     10000
    377          

   \                                 In section .near.bss, align 1
    378          BATTERRY_INFO bat;
   \                     bat:
   \   000000                       DS8 12

   \                                 In section .far_func.text, align 1
    379          void main(void)
    380          {
   \                     main:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 524D                  SUB       SP, #0x4d
    381              uint32_t  time_period_to_send ;
    382          	char   data_gprmc[65];
    383              setup(); //setup sim908
   \   000006 8D000000              CALLF     setup
    384              bat = getBatterry();
   \   00000A 96                    LDW       X, SP
   \   00000B 1C0001                ADDW      X, #0x1
   \   00000E 8D000000              CALLF     getBatterry
   \   000012 9096                  LDW       Y, SP
   \   000014 72A90001              ADDW      Y, #0x1
   \   000018 AE0000                LDW       X, #bat
   \   00001B 89                    PUSHW     X
   \   00001C A60C                  LD        A, #0xc
   \   00001E 8D000000              CALLF     L:?move1616_v_x_y_a
   \   000022 85                    POPW      X
   \   000023 2004                  JRA       L:??main_0
    385              while(!HTTP_init())
    386              {
    387                  HTTP_Terminate() ;
   \                     ??main_1:
   \   000025 8D000000              CALLF     HTTP_Terminate
    388              }
   \                     ??main_0:
   \   000029 8D000000              CALLF     HTTP_init
   \   00002D A100                  CP        A, #0x0
   \   00002F 27F4                  JREQ      L:??main_1
    389              while(1)
    390              {
    391                  //About period time to set gprs flag to send
    392                  if( millis() - time_period_to_send > TIME_SEND_GPRS)
   \                     ??main_2:
   \   000031 8D000000              CALLF     millis
   \   000035 8D000000              CALLF     L:?mov_l1_l2
   \   000039 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   00003D BE00                  LDW       X, S:?w0
   \   00003F A30000                CPW       X, #0x0
   \   000042 2605                  JRNE      L:??main_3
   \   000044 BE00                  LDW       X, S:?w1
   \   000046 A32711                CPW       X, #0x2711
   \                     ??main_3:
   \   000049 250C                  JRC       L:??main_4
    393                  {
    394              		time_period_to_send = millis() ;
   \   00004B 8D000000              CALLF     millis
   \   00004F 8D000000              CALLF     L:?mov_l2_l0
    395              		event_send_gprs = 1 ;
   \   000053 35010000              MOV       L:event_send_gprs, #0x1
    396                  }
    397                  if(event_send_gprs)
   \                     ??main_4:
   \   000057 C60000                LD        A, L:event_send_gprs
   \   00005A A100                  CP        A, #0x0
   \   00005C 27D3                  JREQ      L:??main_2
    398                  {
    399          
    400                      event_send_gprs = 0 ;
   \   00005E 35000000              MOV       L:event_send_gprs, #0x0
    401                      if(start_GPS()) // time out GPS about 90 second if GPS not fix yet
   \   000062 8D000000              CALLF     start_GPS
   \   000066 A100                  CP        A, #0x0
   \   000068 273E                  JREQ      L:??main_5
    402                      {
    403                          gps_fix = 1;
   \   00006A 35010000              MOV       L:gps_fix, #0x1
    404                          GPIO_WriteLow(LED_GPIO_PORT, (GPIO_Pin_TypeDef)LED_GPIO_PINS);
   \   00006E A610                  LD        A, #0x10
   \   000070 AE5005                LDW       X, #0x5005
   \   000073 8D000000              CALLF     GPIO_WriteLow
    405          				memset(data_gprmc , '\0' , sizeof(data_gprmc)/sizeof(char) );
   \   000077 AE0041                LDW       X, #0x41
   \   00007A BF00                  LDW       S:?w0, X
   \   00007C 905F                  CLRW      Y
   \   00007E 96                    LDW       X, SP
   \   00007F 1C000D                ADDW      X, #0xd
   \   000082 8D000000              CALLF     memset
    406                          get_GPS(data_gprmc);
   \   000086 96                    LDW       X, SP
   \   000087 1C000D                ADDW      X, #0xd
   \   00008A 8D000000              CALLF     get_GPS
    407                          while(!HTTP_Send(data_gprmc ,IMEI_DEVICE))
   \                     ??main_6:
   \   00008E 90AE0000              LDW       Y, #IMEI_DEVICE
   \   000092 96                    LDW       X, SP
   \   000093 1C000D                ADDW      X, #0xd
   \   000096 8D000000              CALLF     HTTP_Send
   \   00009A A100                  CP        A, #0x0
   \   00009C 2693                  JRNE      L:??main_2
    408                          {
    409                              HTTP_Terminate();
   \   00009E 8D000000              CALLF     HTTP_Terminate
    410                              HTTP_init();
   \   0000A2 8D000000              CALLF     HTTP_init
   \   0000A6 20E6                  JRA       L:??main_6
    411                          }
    412          
    413                      }
    414                      else
    415                      {
    416                          gps_fix = 0;
   \                     ??main_5:
   \   0000A8 35000000              MOV       L:gps_fix, #0x0
   \   0000AC 2083                  JRA       L:??main_2
    417                      }
    418          
    419                  }
    420              }
    421          }
    422          
    423          /**
    424            * @brief  Inserts a delay time.
    425            * @param  nTime: specifies the delay time length, in milliseconds.
    426            * @retval None
    427            */

   \                                 In section .far_func.text, align 1
    428          void delay(uint16_t nTime)
    429          {
    430            uint32_t  delay_time ;
    431            delay_time = millis() + nTime ;
   \                     delay:
   \   000000 BF00                  LDW       S:?w3, X
   \   000002 5F                    CLRW      X
   \   000003 BF00                  LDW       S:?w2, X
   \   000005 8D000000              CALLF     millis
   \   000009 8D000000              CALLF     L:?add32_l0_l0_l1
   \   00000D 8D000000              CALLF     L:?mov_l1_l0
    432            while (millis() < delay_time);
   \                     ??delay_0:
   \   000011 8D000000              CALLF     millis
   \   000015 8D000000              CALLF     L:?ucmp32_c_l0_l1
   \   000019 25F6                  JRC       L:??delay_0
    433          }
   \   00001B 87                    RETF
    434          

   \                                 In section .far_func.text, align 1
    435          static void CLK_Config(void)
    436          {
    437              /* Initialization of the clock */
    438              /* Clock divider to HSI/1 */
    439              CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);
   \                     CLK_Config:
   \   000000 4F                    CLR       A
   \   000001 AC000000              JPF       CLK_HSIPrescalerConfig
    440          }
    441          /**
    442            * @brief  Configure TIM4 to generate an update interrupt each 1ms
    443            * @param  None
    444            * @retval None
    445            */

   \                                 In section .far_func.text, align 1
    446          static void TIM4_Config(void)
    447          {
    448            /* TIM4 configuration:
    449             - TIM4CLK is set to 16 MHz, the TIM4 Prescaler is equal to 128 so the TIM1 counter
    450             clock used is 16 MHz / 128 = 125 000 Hz
    451            - With 125 000 Hz we can generate time base:
    452                max time base is 2.048 ms if TIM4_PERIOD = 255 --> (255 + 1) / 125000 = 2.048 ms
    453                min time base is 0.016 ms if TIM4_PERIOD = 1   --> (  1 + 1) / 125000 = 0.016 ms
    454            - In this example we need to generate a time base equal to 1 ms
    455             so TIM4_PERIOD = (0.001 * 125000 - 1) = 124 */
    456          
    457            /* Time base configuration */
    458            TIM4_TimeBaseInit(TIM4_PRESCALER_128, TIM4_PERIOD);
   \                     TIM4_Config:
   \   000000 357C0000              MOV       S:?b0, #0x7c
   \   000004 A607                  LD        A, #0x7
   \   000006 8D000000              CALLF     TIM4_TimeBaseInit
    459            /* Clear TIM4 update flag */
    460            TIM4_ClearFlag(TIM4_FLAG_UPDATE);
   \   00000A A601                  LD        A, #0x1
   \   00000C 8D000000              CALLF     TIM4_ClearFlag
    461            /* Enable update interrupt */
    462            TIM4_ITConfig(TIM4_IT_UPDATE, ENABLE);
   \   000010 35010000              MOV       S:?b0, #0x1
   \   000014 A601                  LD        A, #0x1
   \   000016 8D000000              CALLF     TIM4_ITConfig
    463          
    464            /* enable interrupts */
    465            enableInterrupts();
   \   00001A 9A                    RIM
    466          
    467            /* Enable TIM4 */
    468            TIM4_Cmd(ENABLE);
   \   00001B A601                  LD        A, #0x1
   \   00001D AC000000              JPF       TIM4_Cmd
    469          }
    470          
    471          /**
    472            * @brief Retargets the C library printf function to the UART.
    473            * @param c Character to send
    474            * @retval char Character sent
    475            */

   \                                 In section .far_func.text, align 1
    476          PUTCHAR_PROTOTYPE
    477          {
   \                     putchar:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    478            /* Write a character to the UART1 */
    479            UART1_SendData8(c);
   \   000006 B600                  LD        A, S:?b9
   \   000008 8D000000              CALLF     UART1_SendData8
    480            /* Loop until the end of transmission */
    481            while (UART1_GetFlagStatus(UART1_FLAG_TXE) == RESET);
   \                     ??putchar_0:
   \   00000C AE0080                LDW       X, #0x80
   \   00000F 8D000000              CALLF     UART1_GetFlagStatus
   \   000013 A100                  CP        A, #0x0
   \   000015 27F5                  JREQ      L:??putchar_0
    482          
    483            return (c);
   \   000017 BE00                  LDW       X, S:?w4
   \   000019 AC000000              JPF       L:?epilogue_w4
    484          }
    485          
    486          /**
    487            * @brief Retargets the C library scanf function to the USART.
    488            * @param None
    489            * @retval char Character to Read
    490            */

   \                                 In section .far_func.text, align 1
    491          GETCHAR_PROTOTYPE
    492          {
    493          #ifdef _COSMIC_
    494            char c = 0;
    495          #else
    496            int c = 0;
   \                     getchar:
   \   000000 5F                    CLRW      X
    497          #endif
    498            /* Loop until the Read data register flag is SET */
    499            while (UART1_GetFlagStatus(UART1_FLAG_RXNE) == RESET);
   \                     ??getchar_0:
   \   000001 AE0020                LDW       X, #0x20
   \   000004 8D000000              CALLF     UART1_GetFlagStatus
   \   000008 A100                  CP        A, #0x0
   \   00000A 27F5                  JREQ      L:??getchar_0
    500              c = UART1_ReceiveData8();
   \   00000C 8D000000              CALLF     UART1_ReceiveData8
   \   000010 5F                    CLRW      X
   \   000011 97                    LD        XL, A
    501            return (c);
   \   000012 87                    RETF
    502          }
    503          
    504          #ifdef USE_FULL_ASSERT
    505          
    506          /**
    507            * @brief  Reports the name of the source file and the source line number
    508            *   where the assert_param error has occurred.
    509            * @param file: pointer to the source file name
    510            * @param line: assert_param error line source number
    511            * @retval None
    512            */

   \                                 In section .far_func.text, align 1
    513          void assert_failed(uint8_t* file, uint32_t line)
    514          {
    515            /* User can add his own implementation to report the file name and line number,
    516               ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    517          
    518            /* Infinite loop */
    519            while (1)
   \                     assert_failed:
   \                     ??assert_failed_0:
   \   000000 20FE                  JRA       L:??assert_failed_0
    520            {
    521            }
    522          }

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "ATE0">`:
   \   000000 4154453000            DC8 "ATE0"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "OK">`:
   \   000000 4F4B00                DC8 "OK"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+CGPSPWR=1">`:
   \   000000 41542B434750          DC8 "AT+CGPSPWR=1"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+CGPSRST=1">`:
   \   000000 41542B434750          DC8 "AT+CGPSRST=1"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+CREG=2">`:
   \   000000 41542B435245          DC8 "AT+CREG=2"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+CREG?">`:
   \   000000 41542B435245          DC8 "AT+CREG?"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "+CREG: 2,1">`:
   \   000000 2B435245473A          DC8 "+CREG: 2,1"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+SAPBR=1,0">`:
   \   000000 41542B534150          DC8 "AT+SAPBR=1,0"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+CGATT=1">`:
   \   000000 41542B434741          DC8 "AT+CGATT=1"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+SAPBR=3,1,\\"Contype...">`:
   \   000000 41542B534150          DC8 "AT+SAPBR=3,1,\"Contype\",\"GPRS\""

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+SAPBR=3,1,\\"APN\\",\\"v...">`:
   \   000000 41542B534150          DC8 "AT+SAPBR=3,1,\"APN\",\"v-internet\""

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+SAPBR=3,1,\\"USER\\",\\"...">`:
   \   000000 41542B534150          DC8 "AT+SAPBR=3,1,\"USER\",\"mms\""

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+SAPBR=3,1,\\"PWD\\",\\"mms\\"">`:
   \   000000 41542B534150          DC8 "AT+SAPBR=3,1,\"PWD\",\"mms\""

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+HTTPPARA= \\"REDIR\\",1">`:
   \   000000 41542B485454          DC8 "AT+HTTPPARA= \"REDIR\",1"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+SAPBR=1,1">`:
   \   000000 41542B534150          DC8 "AT+SAPBR=1,1"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant ":">`:
   \   000000 3A00                  DC8 ":"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant ",\\"\\r\\n">`:
   \   000000 2C220D0A00            DC8 ",\"\015\012"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+CBC\\r">`:
   \   000000 41542B434243          DC8 "AT+CBC\015"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "+CBC:">`:
   \   000000 2B4342433A00          DC8 "+CBC:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+CREG?\\r">`:
   \   000000 41542B435245          DC8 "AT+CREG?\015"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "+CREG:">`:
   \   000000 2B435245473A          DC8 "+CREG:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\"">`:
   \   000000 2200                  DC8 "\""

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT">`:
   \   000000 415400                DC8 "AT"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "ATE0\\r">`:
   \   000000 415445300D00          DC8 "ATE0\015"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT\\r">`:
   \   000000 41540D00              DC8 "AT\015"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+CGPSSTATUS?">`:
   \   000000 41542B434750          DC8 "AT+CGPSSTATUS?"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "2D Fix">`:
   \   000000 324420466978          DC8 "2D Fix"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "3D Fix">`:
   \   000000 334420466978          DC8 "3D Fix"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+CGPSINF=32\\r">`:
   \   000000 41542B434750          DC8 "AT+CGPSINF=32\015"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\r\\n">`:
   \   000000 0D0A00                DC8 "\015\012"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+CIPCSGP=1,\\"v-inter...">`:
   \   000000 41542B434950          DC8 "AT+CIPCSGP=1,\"v-internet\",\"\",\"\""

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+HTTPINIT">`:
   \   000000 41542B485454          DC8 "AT+HTTPINIT"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+HTTPPARA=\\"CID\\",1">`:
   \   000000 41542B485454          DC8 "AT+HTTPPARA=\"CID\",1"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+HTTPTERM">`:
   \   000000 41542B485454          DC8 "AT+HTTPTERM"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+HTTPPARA=\\"URL\\",\\"ht...">`:
   \   000000 41542B485454          DC8 41H, 54H, 2BH, 48H, 54H, 54H, 50H, 50H
   \   000008 4152413D2255          DC8 41H, 52H, 41H, 3DH, 22H, 55H, 52H, 4CH
   \   000010 222C22687474          DC8 22H, 2CH, 22H, 68H, 74H, 74H, 70H, 3AH
   \   000018 2F2F25732F67          DC8 2FH, 2FH, 25H, 73H, 2FH, 67H, 70H, 72H
   \   000020 6D632F446174          DC8 6DH, 63H, 2FH, 44H, 61H, 74H, 61H, 3FH
   \   000028 616363743D74          DC8 61H, 63H, 63H, 74H, 3DH, 74H, 72H, 61H
   \   000030 636B696E6726          DC8 63H, 6BH, 69H, 6EH, 67H, 26H, 64H, 65H
   \   000038 763D6770726D          DC8 76H, 3DH, 67H, 70H, 72H, 6DH, 63H, 5FH
   \   000040 257326677072          DC8 25H, 73H, 26H, 67H, 70H, 72H, 6DH, 63H
   \   000048 3D244750524D          DC8 3DH, 24H, 47H, 50H, 52H, 4DH, 43H, 2CH
   \   000050 25732200              DC8 25H, 73H, 22H, 0

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "AT+HTTPACTION=0">`:
   \   000000 41542B485454          DC8 "AT+HTTPACTION=0"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "+HTTPACTION:0,200">`:
   \   000000 2B4854545041          DC8 "+HTTPACTION:0,200"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "%s\\r">`:
   \   000000 25730D00              DC8 "%s\015"
    523          #endif
    524          
    525          /**
    526            * @}
    527            */
    528          
    529          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                             Bytes
     --------------                             -----
     strstr                                        4
     IP_ADDRESS_SERVER                            18
     system_tick                                   4
     setup                                       313
     GetResponse                                 112
     GetCmdDataSIM                                79
     getBatterry                                 111
     getLacCellid                                113
     millis                                        7
     power_on                                    116
     start_GPS                                    71
     get_GPS                                      62
     Config_GPRS_SIM908                           16
     HTTP_init                                    46
     HTTP_Terminate                               16
     IMEI_DEVICE                                  10
     HTTP_Send                                    95
     sendATcommand                                68
     event_send_gprs                               1
     bat                                          12
     main                                        174
     delay                                        28
     CLK_Config                                    5
     TIM4_Config                                  33
     putchar                                      29
     getchar                                      19
     assert_failed                                 2
     ?<Constant "ATE0">                            5
     ?<Constant "OK">                              3
     ?<Constant "AT+CGPSPWR=1">                   13
     ?<Constant "AT+CGPSRST=1">                   13
     ?<Constant "AT+CREG=2">                      10
     ?<Constant "AT+CREG?">                        9
     ?<Constant "+CREG: 2,1">                     11
     ?<Constant "AT+SAPBR=1,0">                   13
     ?<Constant "AT+CGATT=1">                     11
     ?<Constant "AT+SAPBR=3,1,\"Contype...">      30
     ?<Constant "AT+SAPBR=3,1,\"APN\",\"v...">    32
     ?<Constant "AT+SAPBR=3,1,\"USER\",\"...">    26
     ?<Constant "AT+SAPBR=3,1,\"PWD\",\"mms\"">   25
     ?<Constant "AT+HTTPPARA= \"REDIR\",1">       23
     ?<Constant "AT+SAPBR=1,1">                   13
     ?<Constant ":">                               2
     ?<Constant ",\"\r\n">                         5
     ?<Constant "AT+CBC\r">                        8
     ?<Constant "+CBC:">                           6
     ?<Constant "AT+CREG?\r">                     10
     ?<Constant "+CREG:">                          7
     ?<Constant "\"">                              2
     ?<Constant "AT">                              3
     ?<Constant "ATE0\r">                          6
     ?<Constant "AT\r">                            4
     ?<Constant "AT+CGPSSTATUS?">                 15
     ?<Constant "2D Fix">                          7
     ?<Constant "3D Fix">                          7
     ?<Constant "AT+CGPSINF=32\r">                15
     ?<Constant "\r\n">                            3
     ?<Constant "AT+CIPCSGP=1,\"v-inter...">      32
     ?<Constant "AT+HTTPINIT">                    12
     ?<Constant "AT+HTTPPARA=\"CID\",1">          20
     ?<Constant "AT+HTTPTERM">                    12
     ?<Constant "AT+HTTPPARA=\"URL\",\"ht...">    84
     ?<Constant "AT+HTTPACTION=0">                16
     ?<Constant "+HTTPACTION:0,200">              18
     ?<Constant "%s\r">                            4

 
 1 519 bytes in section .far_func.text
    17 bytes in section .near.bss
    28 bytes in section .near.data
   535 bytes in section .near.rodata
 
 1 515 bytes of CODE  memory (+ 4 bytes shared)
   535 bytes of CONST memory
    45 bytes of DATA  memory

Errors: none
Warnings: 6
