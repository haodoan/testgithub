###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             24/Jan/2015  12:32:29 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_St #
#                    dPeriph_Driver\src\stm8s_uart1.c                         #
#    Command line =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_St #
#                    dPeriph_Driver\src\stm8s_uart1.c -e -Ol --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_cross_call --debug --code_model medium              #
#                    --data_model medium -o D:\Project\STM8S_StdPeriph_Lib_V2 #
#                    .1.0\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S208\Ob #
#                    j\ --dlib_config "C:\Program Files\IAR Systems\Embedded  #
#                    Workbench 6.0\stm8\LIB\dlstm8mmn.h" -D                   #
#                    USE_STM8_128_EVAL -D STM8S003 -lC                        #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\ -lb                 #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\ -I                  #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\ -I                             #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\..\..\Libraries\STM8S_StdPeriph #
#                    _Driver\inc\ -I D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Pr #
#                    oject\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Utilities #
#                    \STM8S_EVAL\ -I D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Pr #
#                    oject\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Utilities #
#                    \STM8S_EVAL\STM8S-128_EVAL\ -I                           #
#                    D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\..\..\..\Utilities\STM8S_EVAL\Comm #
#                    on\ --vregs 16                                           #
#    List file    =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\List\stm8s_uart1.lst      #
#    Object file  =  D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Project\STM8S_StdP #
#                    eriph_Template\EWSTM8\STM8S208\Obj\stm8s_uart1.o         #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\STM8S_StdPeriph_Lib_V2.1.0\Libraries\STM8S_StdPeriph_Driver\src\stm8s_uart1.c
      1          /**
      2            ********************************************************************************
      3            * @file    stm8s_uart1.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the UART1 peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_uart1.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          /* Public functions ----------------------------------------------------------*/
     35          
     36          /** @}
     37            * @addtogroup UART1_Public_Functions
     38            * @{
     39            */
     40          
     41          /**
     42            * @brief  Deinitializes the UART peripheral.
     43            * @param  None
     44            * @retval None
     45          	*/

   \                                 In section .far_func.text, align 1
     46          void UART1_DeInit(void)
     47          {
     48              /* Clear the Idle Line Detected bit in the status rerister by a read
     49                 to the UART1_SR register followed by a Read to the UART1_DR register */
     50              (void)UART1->SR;
   \                     UART1_DeInit:
   \   000000 C65230                LD        A, L:0x5230
   \   000003 B700                  LD        S:?b0, A
     51              (void)UART1->DR;
   \   000005 C65231                LD        A, L:0x5231
     52          
     53              UART1->BRR2 = UART1_BRR2_RESET_VALUE;  /* Set UART1_BRR2 to reset value 0x00 */
   \   000008 35005233              MOV       L:0x5233, #0x0
     54              UART1->BRR1 = UART1_BRR1_RESET_VALUE;  /* Set UART1_BRR1 to reset value 0x00 */
   \   00000C 35005232              MOV       L:0x5232, #0x0
     55          
     56              UART1->CR1 = UART1_CR1_RESET_VALUE;  /* Set UART1_CR1 to reset value 0x00 */
   \   000010 35005234              MOV       L:0x5234, #0x0
     57              UART1->CR2 = UART1_CR2_RESET_VALUE;  /* Set UART1_CR2 to reset value 0x00 */
   \   000014 35005235              MOV       L:0x5235, #0x0
     58              UART1->CR3 = UART1_CR3_RESET_VALUE;  /* Set UART1_CR3 to reset value 0x00 */
   \   000018 35005236              MOV       L:0x5236, #0x0
     59              UART1->CR4 = UART1_CR4_RESET_VALUE;  /* Set UART1_CR4 to reset value 0x00 */
   \   00001C 35005237              MOV       L:0x5237, #0x0
     60              UART1->CR5 = UART1_CR5_RESET_VALUE;  /* Set UART1_CR5 to reset value 0x00 */
   \   000020 35005238              MOV       L:0x5238, #0x0
     61          
     62              UART1->GTR = UART1_GTR_RESET_VALUE;
   \   000024 35005239              MOV       L:0x5239, #0x0
     63              UART1->PSCR = UART1_PSCR_RESET_VALUE;
   \   000028 3500523A              MOV       L:0x523a, #0x0
     64          }
   \   00002C 87                    RETF
     65          
     66          /**
     67            * @brief  Initializes the UART1 according to the specified parameters.
     68            * @note   Configure in Push Pull or Open Drain mode the Tx pin by setting the
     69            *         correct I/O Port register according the product package and line
     70            *         configuration
     71            * @param  BaudRate: The baudrate.
     72            * @param  WordLength : This parameter can be any of the 
     73            *         @ref UART1_WordLength_TypeDef enumeration.
     74            * @param  StopBits: This parameter can be any of the 
     75            *         @ref UART1_StopBits_TypeDef enumeration.
     76            * @param  Parity: This parameter can be any of the 
     77            *         @ref UART1_Parity_TypeDef enumeration.
     78            * @param  SyncMode: This parameter can be any of the 
     79            *         @ref UART1_SyncMode_TypeDef values.
     80            * @param  Mode: This parameter can be any of the @ref UART1_Mode_TypeDef values
     81            * @retval None
     82            */

   \                                 In section .far_func.text, align 1
     83          void UART1_Init(uint32_t BaudRate, UART1_WordLength_TypeDef WordLength, 
     84                          UART1_StopBits_TypeDef StopBits, UART1_Parity_TypeDef Parity, 
     85                          UART1_SyncMode_TypeDef SyncMode, UART1_Mode_TypeDef Mode)
     86          {
   \                     UART1_Init:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l3
   \   000008 88                    PUSH      A
   \   000009 3B0000                PUSH      S:?b4
   \   00000C 3B0000                PUSH      S:?b5
   \   00000F 3B0000                PUSH      S:?b6
   \   000012 3B0000                PUSH      S:?b7
   \   000015 5204                  SUB       SP, #0x4
   \   000017 8D000000              CALLF     L:?mov_l3_l0
     87              uint32_t BaudRate_Mantissa = 0, BaudRate_Mantissa100 = 0;
   \   00001B AE0000                LDW       X, #0x0
   \   00001E 1F01                  LDW       (0x1,SP), X
   \   000020 AE0000                LDW       X, #0x0
   \   000023 1F03                  LDW       (0x3,SP), X
   \   000025 5F                    CLRW      X
   \   000026 BF00                  LDW       S:?w5, X
   \   000028 BF00                  LDW       S:?w4, X
     88          
     89              /* Check the parameters */
     90              assert_param(IS_UART1_BAUDRATE_OK(BaudRate));
   \   00002A BE00                  LDW       X, S:?w6
   \   00002C A30009                CPW       X, #0x9
   \   00002F 2605                  JRNE      L:??UART1_Init_0
   \   000031 BE00                  LDW       X, S:?w7
   \   000033 A38969                CPW       X, #0x8969
   \                     ??UART1_Init_0:
   \   000036 250F                  JRC       L:??UART1_Init_1
   \   000038 AE005A                LDW       X, #0x5a
   \   00003B BF00                  LDW       S:?w1, X
   \   00003D 5F                    CLRW      X
   \   00003E BF00                  LDW       S:?w0, X
   \   000040 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000043 8D000000              CALLF     assert_failed
     91              assert_param(IS_UART1_WORDLENGTH_OK(WordLength));
   \                     ??UART1_Init_1:
   \   000047 0D09                  TNZ       (0x9,SP)
   \   000049 2715                  JREQ      L:??UART1_Init_2
   \   00004B 7B09                  LD        A, (0x9,SP)
   \   00004D A110                  CP        A, #0x10
   \   00004F 270F                  JREQ      L:??UART1_Init_2
   \   000051 AE005B                LDW       X, #0x5b
   \   000054 BF00                  LDW       S:?w1, X
   \   000056 5F                    CLRW      X
   \   000057 BF00                  LDW       S:?w0, X
   \   000059 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00005C 8D000000              CALLF     assert_failed
     92              assert_param(IS_UART1_STOPBITS_OK(StopBits));
   \                     ??UART1_Init_2:
   \   000060 0D08                  TNZ       (0x8,SP)
   \   000062 2721                  JREQ      L:??UART1_Init_3
   \   000064 7B08                  LD        A, (0x8,SP)
   \   000066 A110                  CP        A, #0x10
   \   000068 271B                  JREQ      L:??UART1_Init_3
   \   00006A 7B08                  LD        A, (0x8,SP)
   \   00006C A120                  CP        A, #0x20
   \   00006E 2715                  JREQ      L:??UART1_Init_3
   \   000070 7B08                  LD        A, (0x8,SP)
   \   000072 A130                  CP        A, #0x30
   \   000074 270F                  JREQ      L:??UART1_Init_3
   \   000076 AE005C                LDW       X, #0x5c
   \   000079 BF00                  LDW       S:?w1, X
   \   00007B 5F                    CLRW      X
   \   00007C BF00                  LDW       S:?w0, X
   \   00007E AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000081 8D000000              CALLF     assert_failed
     93              assert_param(IS_UART1_PARITY_OK(Parity));
   \                     ??UART1_Init_3:
   \   000085 0D07                  TNZ       (0x7,SP)
   \   000087 271B                  JREQ      L:??UART1_Init_4
   \   000089 7B07                  LD        A, (0x7,SP)
   \   00008B A104                  CP        A, #0x4
   \   00008D 2715                  JREQ      L:??UART1_Init_4
   \   00008F 7B07                  LD        A, (0x7,SP)
   \   000091 A106                  CP        A, #0x6
   \   000093 270F                  JREQ      L:??UART1_Init_4
   \   000095 AE005D                LDW       X, #0x5d
   \   000098 BF00                  LDW       S:?w1, X
   \   00009A 5F                    CLRW      X
   \   00009B BF00                  LDW       S:?w0, X
   \   00009D AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   0000A0 8D000000              CALLF     assert_failed
     94              assert_param(IS_UART1_MODE_OK((uint8_t)Mode));
   \                     ??UART1_Init_4:
   \   0000A4 7B05                  LD        A, (0x5,SP)
   \   0000A6 A108                  CP        A, #0x8
   \   0000A8 273F                  JREQ      L:??UART1_Init_5
   \   0000AA 7B05                  LD        A, (0x5,SP)
   \   0000AC A140                  CP        A, #0x40
   \   0000AE 2739                  JREQ      L:??UART1_Init_5
   \   0000B0 7B05                  LD        A, (0x5,SP)
   \   0000B2 A104                  CP        A, #0x4
   \   0000B4 2733                  JREQ      L:??UART1_Init_5
   \   0000B6 7B05                  LD        A, (0x5,SP)
   \   0000B8 A180                  CP        A, #0x80
   \   0000BA 272D                  JREQ      L:??UART1_Init_5
   \   0000BC 7B05                  LD        A, (0x5,SP)
   \   0000BE A10C                  CP        A, #0xc
   \   0000C0 2727                  JREQ      L:??UART1_Init_5
   \   0000C2 7B05                  LD        A, (0x5,SP)
   \   0000C4 A10C                  CP        A, #0xc
   \   0000C6 2721                  JREQ      L:??UART1_Init_5
   \   0000C8 7B05                  LD        A, (0x5,SP)
   \   0000CA A144                  CP        A, #0x44
   \   0000CC 271B                  JREQ      L:??UART1_Init_5
   \   0000CE 7B05                  LD        A, (0x5,SP)
   \   0000D0 A1C0                  CP        A, #0xc0
   \   0000D2 2715                  JREQ      L:??UART1_Init_5
   \   0000D4 7B05                  LD        A, (0x5,SP)
   \   0000D6 A188                  CP        A, #0x88
   \   0000D8 270F                  JREQ      L:??UART1_Init_5
   \   0000DA AE005E                LDW       X, #0x5e
   \   0000DD BF00                  LDW       S:?w1, X
   \   0000DF 5F                    CLRW      X
   \   0000E0 BF00                  LDW       S:?w0, X
   \   0000E2 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   0000E5 8D000000              CALLF     assert_failed
     95              assert_param(IS_UART1_SYNCMODE_OK((uint8_t)SyncMode));
   \                     ??UART1_Init_5:
   \   0000E9 7B06                  LD        A, (0x6,SP)
   \   0000EB A488                  AND       A, #0x88
   \   0000ED A188                  CP        A, #0x88
   \   0000EF 2718                  JREQ      L:??UART1_Init_6
   \   0000F1 7B06                  LD        A, (0x6,SP)
   \   0000F3 A444                  AND       A, #0x44
   \   0000F5 A144                  CP        A, #0x44
   \   0000F7 2710                  JREQ      L:??UART1_Init_6
   \   0000F9 7B06                  LD        A, (0x6,SP)
   \   0000FB A422                  AND       A, #0x22
   \   0000FD A122                  CP        A, #0x22
   \   0000FF 2708                  JREQ      L:??UART1_Init_6
   \   000101 7B06                  LD        A, (0x6,SP)
   \   000103 A411                  AND       A, #0x11
   \   000105 A111                  CP        A, #0x11
   \   000107 260F                  JRNE      L:??UART1_Init_7
   \                     ??UART1_Init_6:
   \   000109 AE005F                LDW       X, #0x5f
   \   00010C BF00                  LDW       S:?w1, X
   \   00010E 5F                    CLRW      X
   \   00010F BF00                  LDW       S:?w0, X
   \   000111 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000114 8D000000              CALLF     assert_failed
     96          
     97              /* Clear the word length bit */
     98              UART1->CR1 &= (uint8_t)(~UART1_CR1_M);  
   \                     ??UART1_Init_7:
   \   000118 72195234              BRES      L:0x5234, #0x4
     99              
    100               /* Set the word length bit according to UART1_WordLength value */
    101              UART1->CR1 |= (uint8_t)WordLength;
   \   00011C 7B09                  LD        A, (0x9,SP)
   \   00011E CA5234                OR        A, L:0x5234
   \   000121 C75234                LD        L:0x5234, A
    102          
    103              /* Clear the STOP bits */
    104              UART1->CR3 &= (uint8_t)(~UART1_CR3_STOP);  
   \   000124 C65236                LD        A, L:0x5236
   \   000127 A4CF                  AND       A, #0xcf
   \   000129 C75236                LD        L:0x5236, A
    105              /* Set the STOP bits number according to UART1_StopBits value  */
    106              UART1->CR3 |= (uint8_t)StopBits;  
   \   00012C 7B08                  LD        A, (0x8,SP)
   \   00012E CA5236                OR        A, L:0x5236
   \   000131 C75236                LD        L:0x5236, A
    107          
    108              /* Clear the Parity Control bit */
    109              UART1->CR1 &= (uint8_t)(~(UART1_CR1_PCEN | UART1_CR1_PS  ));  
   \   000134 C65234                LD        A, L:0x5234
   \   000137 A4F9                  AND       A, #0xf9
   \   000139 C75234                LD        L:0x5234, A
    110              /* Set the Parity Control bit to UART1_Parity value */
    111              UART1->CR1 |= (uint8_t)Parity;  
   \   00013C 7B07                  LD        A, (0x7,SP)
   \   00013E CA5234                OR        A, L:0x5234
   \   000141 C75234                LD        L:0x5234, A
    112          
    113              /* Clear the LSB mantissa of UART1DIV  */
    114              UART1->BRR1 &= (uint8_t)(~UART1_BRR1_DIVM);  
   \   000144 C65232                LD        A, L:0x5232
   \   000147 6B01                  LD        (0x1,SP), A
   \   000149 35005232              MOV       L:0x5232, #0x0
    115              /* Clear the MSB mantissa of UART1DIV  */
    116              UART1->BRR2 &= (uint8_t)(~UART1_BRR2_DIVM);  
   \   00014D C65233                LD        A, L:0x5233
   \   000150 A40F                  AND       A, #0xf
   \   000152 C75233                LD        L:0x5233, A
    117              /* Clear the Fraction bits of UART1DIV */
    118              UART1->BRR2 &= (uint8_t)(~UART1_BRR2_DIVF);  
   \   000155 C65233                LD        A, L:0x5233
   \   000158 A4F0                  AND       A, #0xf0
   \   00015A C75233                LD        L:0x5233, A
    119          
    120              /* Set the UART1 BaudRates in BRR1 and BRR2 registers according to UART1_BaudRate value */
    121              BaudRate_Mantissa    = ((uint32_t)CLK_GetClockFreq() / (BaudRate << 4));
   \   00015D 8D000000              CALLF     L:?mov_l0_l3
   \   000161 A604                  LD        A, #0x4
   \   000163 8D000000              CALLF     L:?sll32_l0_l0_a
   \   000167 8D000000              CALLF     L:?mov_l2_l0
   \   00016B 8D000000              CALLF     CLK_GetClockFreq
   \   00016F 8D000000              CALLF     L:?mov_l1_l2
   \   000173 8D000000              CALLF     L:?udiv32_l0_l0_l1
   \   000177 AE0001                LDW       X, #0x1
   \   00017A 8D000000              CALLF     L:?load32_xsp_l0
    122              BaudRate_Mantissa100 = (((uint32_t)CLK_GetClockFreq() * 100) / (BaudRate << 4));
   \   00017E 8D000000              CALLF     L:?mov_l0_l3
   \   000182 A604                  LD        A, #0x4
   \   000184 8D000000              CALLF     L:?sll32_l0_l0_a
   \   000188 8D000000              CALLF     L:?mov_l2_l0
   \   00018C 8D000000              CALLF     CLK_GetClockFreq
   \   000190 AE0064                LDW       X, #0x64
   \   000193 BF00                  LDW       S:?w3, X
   \   000195 5F                    CLRW      X
   \   000196 BF00                  LDW       S:?w2, X
   \   000198 8D000000              CALLF     L:?mul32_l0_l0_l1
   \   00019C 8D000000              CALLF     L:?mov_l1_l2
   \   0001A0 8D000000              CALLF     L:?udiv32_l0_l0_l1
   \   0001A4 8D000000              CALLF     L:?mov_l2_l0
    123              /* Set the fraction of UART1DIV  */
    124              UART1->BRR2 |= (uint8_t)((uint8_t)(((BaudRate_Mantissa100 - (BaudRate_Mantissa * 100)) << 4) / 100) & (uint8_t)0x0F); 
   \   0001A8 AE0064                LDW       X, #0x64
   \   0001AB BF00                  LDW       S:?w3, X
   \   0001AD 5F                    CLRW      X
   \   0001AE BF00                  LDW       S:?w2, X
   \   0001B0 8D000000              CALLF     L:?load32_l0_dbsp
   \   0001B4 01                    DC8       0x1
   \   0001B5 8D000000              CALLF     L:?mul32_l0_l0_l1
   \   0001B9 8D000000              CALLF     L:?mov_l1_l0
   \   0001BD 8D000000              CALLF     L:?mov_l0_l2
   \   0001C1 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   0001C5 A604                  LD        A, #0x4
   \   0001C7 8D000000              CALLF     L:?sll32_l0_l0_a
   \   0001CB 8D000000              CALLF     L:?udiv32_l0_l0_dl
   \   0001CF 00000064              DC32      0x64
   \   0001D3 B600                  LD        A, S:?b3
   \   0001D5 A40F                  AND       A, #0xf
   \   0001D7 CA5233                OR        A, L:0x5233
   \   0001DA C75233                LD        L:0x5233, A
    125              /* Set the MSB mantissa of UART1DIV  */
    126              UART1->BRR2 |= (uint8_t)((BaudRate_Mantissa >> 4) & (uint8_t)0xF0); 
   \   0001DD 1E03                  LDW       X, (0x3,SP)
   \   0001DF 54                    SRLW      X
   \   0001E0 54                    SRLW      X
   \   0001E1 54                    SRLW      X
   \   0001E2 54                    SRLW      X
   \   0001E3 9F                    LD        A, XL
   \   0001E4 A4F0                  AND       A, #0xf0
   \   0001E6 CA5233                OR        A, L:0x5233
   \   0001E9 C75233                LD        L:0x5233, A
    127              /* Set the LSB mantissa of UART1DIV  */
    128              UART1->BRR1 |= (uint8_t)BaudRate_Mantissa;           
   \   0001EC 1E03                  LDW       X, (0x3,SP)
   \   0001EE 9F                    LD        A, XL
   \   0001EF CA5232                OR        A, L:0x5232
   \   0001F2 C75232                LD        L:0x5232, A
    129          
    130              /* Disable the Transmitter and Receiver before seting the LBCL, CPOL and CPHA bits */
    131              UART1->CR2 &= (uint8_t)~(UART1_CR2_TEN | UART1_CR2_REN); 
   \   0001F5 C65235                LD        A, L:0x5235
   \   0001F8 A4F3                  AND       A, #0xf3
   \   0001FA C75235                LD        L:0x5235, A
    132              /* Clear the Clock Polarity, lock Phase, Last Bit Clock pulse */
    133              UART1->CR3 &= (uint8_t)~(UART1_CR3_CPOL | UART1_CR3_CPHA | UART1_CR3_LBCL); 
   \   0001FD C65236                LD        A, L:0x5236
   \   000200 A4F8                  AND       A, #0xf8
   \   000202 C75236                LD        L:0x5236, A
    134              /* Set the Clock Polarity, lock Phase, Last Bit Clock pulse */
    135              UART1->CR3 |= (uint8_t)((uint8_t)SyncMode & (uint8_t)(UART1_CR3_CPOL | 
    136                                                        UART1_CR3_CPHA | UART1_CR3_LBCL));  
   \   000205 7B06                  LD        A, (0x6,SP)
   \   000207 A407                  AND       A, #0x7
   \   000209 CA5236                OR        A, L:0x5236
   \   00020C C75236                LD        L:0x5236, A
    137          
    138              if ((uint8_t)(Mode & UART1_MODE_TX_ENABLE))
   \   00020F 7B05                  LD        A, (0x5,SP)
   \   000211 A404                  AND       A, #0x4
   \   000213 A100                  CP        A, #0x0
   \   000215 2706                  JREQ      L:??UART1_Init_8
    139              {
    140                  /* Set the Transmitter Enable bit */
    141                  UART1->CR2 |= (uint8_t)UART1_CR2_TEN;  
   \   000217 72165235              BSET      L:0x5235, #0x3
   \   00021B 2004                  JRA       L:??UART1_Init_9
    142              }
    143              else
    144              {
    145                  /* Clear the Transmitter Disable bit */
    146                  UART1->CR2 &= (uint8_t)(~UART1_CR2_TEN);  
   \                     ??UART1_Init_8:
   \   00021D 72175235              BRES      L:0x5235, #0x3
    147              }
    148              if ((uint8_t)(Mode & UART1_MODE_RX_ENABLE))
   \                     ??UART1_Init_9:
   \   000221 7B05                  LD        A, (0x5,SP)
   \   000223 A408                  AND       A, #0x8
   \   000225 A100                  CP        A, #0x0
   \   000227 2706                  JREQ      L:??UART1_Init_10
    149              {
    150                  /* Set the Receiver Enable bit */
    151                  UART1->CR2 |= (uint8_t)UART1_CR2_REN;  
   \   000229 72145235              BSET      L:0x5235, #0x2
   \   00022D 2004                  JRA       L:??UART1_Init_11
    152              }
    153              else
    154              {
    155                  /* Clear the Receiver Disable bit */
    156                  UART1->CR2 &= (uint8_t)(~UART1_CR2_REN);  
   \                     ??UART1_Init_10:
   \   00022F 72155235              BRES      L:0x5235, #0x2
    157              }
    158              /* Set the Clock Enable bit, lock Polarity, lock Phase and Last Bit Clock 
    159                     pulse bits according to UART1_Mode value */
    160              if ((uint8_t)(SyncMode & UART1_SYNCMODE_CLOCK_DISABLE))
   \                     ??UART1_Init_11:
   \   000233 7B06                  LD        A, (0x6,SP)
   \   000235 A480                  AND       A, #0x80
   \   000237 A100                  CP        A, #0x0
   \   000239 2706                  JREQ      L:??UART1_Init_12
    161              {
    162                  /* Clear the Clock Enable bit */
    163                  UART1->CR3 &= (uint8_t)(~UART1_CR3_CKEN); 
   \   00023B 72175236              BRES      L:0x5236, #0x3
   \   00023F 200A                  JRA       L:??UART1_Init_13
    164              }
    165              else
    166              {
    167                  UART1->CR3 |= (uint8_t)((uint8_t)SyncMode & UART1_CR3_CKEN);
   \                     ??UART1_Init_12:
   \   000241 7B06                  LD        A, (0x6,SP)
   \   000243 A408                  AND       A, #0x8
   \   000245 CA5236                OR        A, L:0x5236
   \   000248 C75236                LD        L:0x5236, A
    168              }
    169          }
   \                     ??UART1_Init_13:
   \   00024B 5B09                  ADD       SP, #0x9
   \   00024D AC000000              JPF       L:?epilogue_l2_l3
    170          
    171          /**
    172            * @brief  Enable the UART1 peripheral.
    173            * @param  NewState : The new state of the UART Communication.
    174            *         This parameter can be any of the @ref FunctionalState enumeration.
    175            * @retval None
    176            */

   \                                 In section .far_func.text, align 1
    177          void UART1_Cmd(FunctionalState NewState)
    178          {
    179              if (NewState != DISABLE)
   \                     UART1_Cmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??UART1_Cmd_0
    180              {
    181                  /* UART1 Enable */
    182                  UART1->CR1 &= (uint8_t)(~UART1_CR1_UARTD); 
   \   000003 721B5234              BRES      L:0x5234, #0x5
   \   000007 87                    RETF
    183              }
    184              else
    185              {
    186                  /* UART Disable */
    187                  UART1->CR1 |= UART1_CR1_UARTD;  
   \                     ??UART1_Cmd_0:
   \   000008 721A5234              BSET      L:0x5234, #0x5
    188              }
    189          }
   \   00000C 87                    RETF
    190          
    191          /**
    192            * @brief  Enables or disables the specified USART interrupts.
    193            * @param  UART1_IT specifies the USART interrupt sources to be enabled or disabled.
    194            *         This parameter can be one of the following values:
    195            *         - UART1_IT_TXE:  Tansmit Data Register empty interrupt
    196            *         - UART1_IT_TC:   Transmission complete interrupt
    197            *         - UART1_IT_RXNE: Receive Data register not empty interrupt
    198            *         - UART1_IT_OR: Overrun error interrupt
    199            *         - UART1_IT_IDLE: Idle line detection interrupt
    200            *         - USRT1_IT_ERR:  Error interrupt
    201            * @param  NewState new state of the specified USART interrupts.
    202            *         This parameter can be: ENABLE or DISABLE.
    203            * @retval None
    204            */

   \                                 In section .far_func.text, align 1
    205          void UART1_ITConfig(UART1_IT_TypeDef UART1_IT, FunctionalState NewState)
    206          {
   \                     UART1_ITConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 BF00                  LDW       S:?w4, X
   \   000009 B700                  LD        S:?b10, A
    207              uint8_t uartreg = 0, itpos = 0x00;
   \   00000B 3F00                  CLR       S:?b1
   \   00000D 3F00                  CLR       S:?b0
    208              
    209              /* Check the parameters */
    210              assert_param(IS_UART1_CONFIG_IT_OK(UART1_IT));
   \   00000F BE00                  LDW       X, S:?w4
   \   000011 A30100                CPW       X, #0x100
   \   000014 2732                  JREQ      L:??UART1_ITConfig_0
   \   000016 BE00                  LDW       X, S:?w4
   \   000018 A30277                CPW       X, #0x277
   \   00001B 272B                  JREQ      L:??UART1_ITConfig_0
   \   00001D BE00                  LDW       X, S:?w4
   \   00001F A30266                CPW       X, #0x266
   \   000022 2724                  JREQ      L:??UART1_ITConfig_0
   \   000024 BE00                  LDW       X, S:?w4
   \   000026 A30205                CPW       X, #0x205
   \   000029 271D                  JREQ      L:??UART1_ITConfig_0
   \   00002B BE00                  LDW       X, S:?w4
   \   00002D A30244                CPW       X, #0x244
   \   000030 2716                  JREQ      L:??UART1_ITConfig_0
   \   000032 BE00                  LDW       X, S:?w4
   \   000034 A30346                CPW       X, #0x346
   \   000037 270F                  JREQ      L:??UART1_ITConfig_0
   \   000039 AE00D2                LDW       X, #0xd2
   \   00003C BF00                  LDW       S:?w1, X
   \   00003E 5F                    CLRW      X
   \   00003F BF00                  LDW       S:?w0, X
   \   000041 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000044 8D000000              CALLF     assert_failed
    211              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??UART1_ITConfig_0:
   \   000048 3D00                  TNZ       S:?b10
   \   00004A 2715                  JREQ      L:??UART1_ITConfig_1
   \   00004C B600                  LD        A, S:?b10
   \   00004E A101                  CP        A, #0x1
   \   000050 270F                  JREQ      L:??UART1_ITConfig_1
   \   000052 AE00D3                LDW       X, #0xd3
   \   000055 BF00                  LDW       S:?w1, X
   \   000057 5F                    CLRW      X
   \   000058 BF00                  LDW       S:?w0, X
   \   00005A AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00005D 8D000000              CALLF     assert_failed
    212          
    213              /* Get the UART1 register index */
    214              uartreg = (uint8_t)((uint16_t)UART1_IT >> 0x08);
   \                     ??UART1_ITConfig_1:
   \   000061 BE00                  LDW       X, S:?w4
   \   000063 4F                    CLR       A
   \   000064 01                    RRWA      X, A
   \   000065 41                    EXG       A, XL
   \   000066 B700                  LD        S:?b1, A
   \   000068 41                    EXG       A, XL
    215              /* Get the UART1 IT index */
    216              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART1_IT & (uint8_t)0x0F));
   \   000069 B600                  LD        A, S:?b9
   \   00006B A40F                  AND       A, #0xf
   \   00006D 5F                    CLRW      X
   \   00006E 5C                    INCW      X
   \   00006F 8D000000              CALLF     L:?sll16_x_x_a
   \   000073 41                    EXG       A, XL
   \   000074 B700                  LD        S:?b0, A
   \   000076 41                    EXG       A, XL
    217          
    218              if (NewState != DISABLE)
   \   000077 3D00                  TNZ       S:?b10
   \   000079 272A                  JREQ      L:??UART1_ITConfig_2
    219              {
    220                  /**< Enable the Interrupt bits according to UART1_IT mask */
    221                  if (uartreg == 0x01)
   \   00007B B600                  LD        A, S:?b1
   \   00007D A101                  CP        A, #0x1
   \   00007F 260A                  JRNE      L:??UART1_ITConfig_3
    222                  {
    223                      UART1->CR1 |= itpos;
   \   000081 B600                  LD        A, S:?b0
   \   000083 CA5234                OR        A, L:0x5234
   \   000086 C75234                LD        L:0x5234, A
   \   000089 2048                  JRA       L:??UART1_ITConfig_4
    224                  }
    225                  else if (uartreg == 0x02)
   \                     ??UART1_ITConfig_3:
   \   00008B B600                  LD        A, S:?b1
   \   00008D A102                  CP        A, #0x2
   \   00008F 260A                  JRNE      L:??UART1_ITConfig_5
    226                  {
    227                      UART1->CR2 |= itpos;
   \   000091 B600                  LD        A, S:?b0
   \   000093 CA5235                OR        A, L:0x5235
   \   000096 C75235                LD        L:0x5235, A
   \   000099 2038                  JRA       L:??UART1_ITConfig_4
    228                  }
    229                  else
    230                  {
    231                      UART1->CR4 |= itpos;
   \                     ??UART1_ITConfig_5:
   \   00009B B600                  LD        A, S:?b0
   \   00009D CA5237                OR        A, L:0x5237
   \   0000A0 C75237                LD        L:0x5237, A
   \   0000A3 202E                  JRA       L:??UART1_ITConfig_4
    232                  }
    233              }
    234              else
    235              {
    236                  /**< Disable the interrupt bits according to UART1_IT mask */
    237                  if (uartreg == 0x01)
   \                     ??UART1_ITConfig_2:
   \   0000A5 B600                  LD        A, S:?b1
   \   0000A7 A101                  CP        A, #0x1
   \   0000A9 260C                  JRNE      L:??UART1_ITConfig_6
    238                  {
    239                      UART1->CR1 &= (uint8_t)(~itpos);
   \   0000AB 3300                  CPL       S:?b0
   \   0000AD B600                  LD        A, S:?b0
   \   0000AF C45234                AND       A, L:0x5234
   \   0000B2 C75234                LD        L:0x5234, A
   \   0000B5 201C                  JRA       L:??UART1_ITConfig_4
    240                  }
    241                  else if (uartreg == 0x02)
   \                     ??UART1_ITConfig_6:
   \   0000B7 B600                  LD        A, S:?b1
   \   0000B9 A102                  CP        A, #0x2
   \   0000BB 260C                  JRNE      L:??UART1_ITConfig_7
    242                  {
    243                      UART1->CR2 &= (uint8_t)(~itpos);
   \   0000BD 3300                  CPL       S:?b0
   \   0000BF B600                  LD        A, S:?b0
   \   0000C1 C45235                AND       A, L:0x5235
   \   0000C4 C75235                LD        L:0x5235, A
   \   0000C7 200A                  JRA       L:??UART1_ITConfig_4
    244                  }
    245                  else
    246                  {
    247                      UART1->CR4 &= (uint8_t)(~itpos);
   \                     ??UART1_ITConfig_7:
   \   0000C9 3300                  CPL       S:?b0
   \   0000CB B600                  LD        A, S:?b0
   \   0000CD C45237                AND       A, L:0x5237
   \   0000D0 C75237                LD        L:0x5237, A
    248                  }
    249              }
    250          
    251          }
   \                     ??UART1_ITConfig_4:
   \   0000D3 320000                POP       S:?b10
   \   0000D6 AC000000              JPF       L:?epilogue_w4
    252          /**
    253            * @brief  Enables or disables the UART’s Half Duplex communication.
    254            * @param  NewState new state of the UART Communication.
    255            *         This parameter can be: ENABLE or DISABLE.
    256            * @retval None
    257            */

   \                                 In section .far_func.text, align 1
    258          void UART1_HalfDuplexCmd(FunctionalState NewState)
    259          {
   \                     UART1_HalfDuplexCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    260              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??UART1_HalfDuplexCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??UART1_HalfDuplexCmd_0
   \   00000F AE0104                LDW       X, #0x104
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    261          
    262              if (NewState != DISABLE)
   \                     ??UART1_HalfDuplexCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??UART1_HalfDuplexCmd_1
    263              {
    264                  UART1->CR5 |= UART1_CR5_HDSEL;  /**< UART1 Half Duplex Enable  */
   \   000022 72165238              BSET      L:0x5238, #0x3
   \   000026 2004                  JRA       L:??UART1_HalfDuplexCmd_2
    265              }
    266              else
    267              {
    268                  UART1->CR5 &= (uint8_t)~UART1_CR5_HDSEL; /**< UART1 Half Duplex Disable */
   \                     ??UART1_HalfDuplexCmd_1:
   \   000028 72175238              BRES      L:0x5238, #0x3
    269              }
    270          }
   \                     ??UART1_HalfDuplexCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    271          
    272          /**
    273            * @brief  Configures the UART’s IrDA interface.
    274            * @param  UART1_IrDAMode specifies the IrDA mode.
    275            *         This parameter can be any of the @ref UART1_IrDAMode_TypeDef values.
    276            * @retval None
    277            */

   \                                 In section .far_func.text, align 1
    278          void UART1_IrDAConfig(UART1_IrDAMode_TypeDef UART1_IrDAMode)
    279          {
   \                     UART1_IrDAConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    280              assert_param(IS_UART1_IRDAMODE_OK(UART1_IrDAMode));
   \   000005 B600                  LD        A, S:?b8
   \   000007 A101                  CP        A, #0x1
   \   000009 2713                  JREQ      L:??UART1_IrDAConfig_0
   \   00000B 3D00                  TNZ       S:?b8
   \   00000D 270F                  JREQ      L:??UART1_IrDAConfig_0
   \   00000F AE0118                LDW       X, #0x118
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    281          
    282              if (UART1_IrDAMode != UART1_IRDAMODE_NORMAL)
   \                     ??UART1_IrDAConfig_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??UART1_IrDAConfig_1
    283              {
    284                  UART1->CR5 |= UART1_CR5_IRLP;
   \   000022 72145238              BSET      L:0x5238, #0x2
   \   000026 2004                  JRA       L:??UART1_IrDAConfig_2
    285              }
    286              else
    287              {
    288                  UART1->CR5 &= ((uint8_t)~UART1_CR5_IRLP);
   \                     ??UART1_IrDAConfig_1:
   \   000028 72155238              BRES      L:0x5238, #0x2
    289              }
    290          }
   \                     ??UART1_IrDAConfig_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    291          
    292          /**
    293            * @brief  Enables or disables the UART’s IrDA interface.
    294            * @param  NewState new state of the IrDA mode.
    295            *         This parameter can be: ENABLE or DISABLE.
    296            * @retval None
    297            */

   \                                 In section .far_func.text, align 1
    298          void UART1_IrDACmd(FunctionalState NewState)
    299          {
   \                     UART1_IrDACmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    300          
    301              /* Check parameters */
    302              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??UART1_IrDACmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??UART1_IrDACmd_0
   \   00000F AE012E                LDW       X, #0x12e
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    303          
    304              if (NewState != DISABLE)
   \                     ??UART1_IrDACmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??UART1_IrDACmd_1
    305              {
    306                  /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    307                  UART1->CR5 |= UART1_CR5_IREN;
   \   000022 72125238              BSET      L:0x5238, #0x1
   \   000026 2004                  JRA       L:??UART1_IrDACmd_2
    308              }
    309              else
    310              {
    311                  /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    312                  UART1->CR5 &= ((uint8_t)~UART1_CR5_IREN);
   \                     ??UART1_IrDACmd_1:
   \   000028 72135238              BRES      L:0x5238, #0x1
    313              }
    314          }
   \                     ??UART1_IrDACmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    315          
    316          /**
    317            * @brief  Sets the UART1 LIN Break detection length.
    318            * @param  UART1_LINBreakDetectionLength specifies the LIN break detection length.
    319            *         This parameter can be any of the
    320            *         @ref UART1_LINBreakDetectionLength_TypeDef values.
    321            * @retval None
    322            */

   \                                 In section .far_func.text, align 1
    323          void UART1_LINBreakDetectionConfig(UART1_LINBreakDetectionLength_TypeDef UART1_LINBreakDetectionLength)
    324          {
   \                     UART1_LINBreakDetectionConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    325              assert_param(IS_UART1_LINBREAKDETECTIONLENGTH_OK(UART1_LINBreakDetectionLength));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??UART1_LINBreakDetectionConfig_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??UART1_LINBreakDetectionConfig_0
   \   00000F AE0145                LDW       X, #0x145
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    326          
    327              if (UART1_LINBreakDetectionLength != UART1_LINBREAKDETECTIONLENGTH_10BITS)
   \                     ??UART1_LINBreakDetectionConfig_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??UART1_LINBreakDetectionConfig_1
    328              {
    329                  UART1->CR4 |= UART1_CR4_LBDL;
   \   000022 721A5237              BSET      L:0x5237, #0x5
   \   000026 2004                  JRA       L:??UART1_LINBreakDetectionConfig_2
    330              }
    331              else
    332              {
    333                  UART1->CR4 &= ((uint8_t)~UART1_CR4_LBDL);
   \                     ??UART1_LINBreakDetectionConfig_1:
   \   000028 721B5237              BRES      L:0x5237, #0x5
    334              }
    335          }
   \                     ??UART1_LINBreakDetectionConfig_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    336          
    337          /**
    338            * @brief  Enables or disables the UART1’s LIN mode.
    339            * @param  NewState is new state of the UART1 LIN mode.
    340            *         This parameter can be: ENABLE or DISABLE.
    341            * @retval None
    342            */

   \                                 In section .far_func.text, align 1
    343          void UART1_LINCmd(FunctionalState NewState)
    344          {
   \                     UART1_LINCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    345              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??UART1_LINCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??UART1_LINCmd_0
   \   00000F AE0159                LDW       X, #0x159
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    346          
    347              if (NewState != DISABLE)
   \                     ??UART1_LINCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??UART1_LINCmd_1
    348              {
    349                  /* Enable the LIN mode by setting the LINE bit in the CR2 register */
    350                  UART1->CR3 |= UART1_CR3_LINEN;
   \   000022 721C5236              BSET      L:0x5236, #0x6
   \   000026 2004                  JRA       L:??UART1_LINCmd_2
    351              }
    352              else
    353              {
    354                  /* Disable the LIN mode by clearing the LINE bit in the CR2 register */
    355                  UART1->CR3 &= ((uint8_t)~UART1_CR3_LINEN);
   \                     ??UART1_LINCmd_1:
   \   000028 721D5236              BRES      L:0x5236, #0x6
    356              }
    357          }
   \                     ??UART1_LINCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    358          /**
    359            * @brief  Enables or disables the UART1 Smart Card mode.
    360            * @param  NewState: new state of the Smart Card mode.
    361            * This parameter can be: ENABLE or DISABLE.
    362            * @retval None
    363            */

   \                                 In section .far_func.text, align 1
    364          void UART1_SmartCardCmd(FunctionalState NewState)
    365          {
   \                     UART1_SmartCardCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    366              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??UART1_SmartCardCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??UART1_SmartCardCmd_0
   \   00000F AE016E                LDW       X, #0x16e
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    367          
    368              if (NewState != DISABLE)
   \                     ??UART1_SmartCardCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??UART1_SmartCardCmd_1
    369              {
    370                  /* Enable the SC mode by setting the SCEN bit in the CR5 register */
    371                  UART1->CR5 |= UART1_CR5_SCEN;
   \   000022 721A5238              BSET      L:0x5238, #0x5
   \   000026 2004                  JRA       L:??UART1_SmartCardCmd_2
    372              }
    373              else
    374              {
    375                  /* Disable the SC mode by clearing the SCEN bit in the CR5 register */
    376                  UART1->CR5 &= ((uint8_t)(~UART1_CR5_SCEN));
   \                     ??UART1_SmartCardCmd_1:
   \   000028 721B5238              BRES      L:0x5238, #0x5
    377              }
    378          }
   \                     ??UART1_SmartCardCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    379          
    380          /**
    381            * @brief  Enables or disables NACK transmission.
    382            * @note   This function is valid only for UART1 because is related to SmartCard mode.
    383            * @param  NewState: new state of the Smart Card mode.
    384            *         This parameter can be: ENABLE or DISABLE.
    385            * @retval None
    386            */

   \                                 In section .far_func.text, align 1
    387          void UART1_SmartCardNACKCmd(FunctionalState NewState)
    388          {
   \                     UART1_SmartCardNACKCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    389              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??UART1_SmartCardNACKCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??UART1_SmartCardNACKCmd_0
   \   00000F AE0185                LDW       X, #0x185
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    390          
    391              if (NewState != DISABLE)
   \                     ??UART1_SmartCardNACKCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??UART1_SmartCardNACKCmd_1
    392              {
    393                  /* Enable the NACK transmission by setting the NACK bit in the CR5 register */
    394                  UART1->CR5 |= UART1_CR5_NACK;
   \   000022 72185238              BSET      L:0x5238, #0x4
   \   000026 2004                  JRA       L:??UART1_SmartCardNACKCmd_2
    395              }
    396              else
    397              {
    398                  /* Disable the NACK transmission by clearing the NACK bit in the CR5 register */
    399                  UART1->CR5 &= ((uint8_t)~(UART1_CR5_NACK));
   \                     ??UART1_SmartCardNACKCmd_1:
   \   000028 72195238              BRES      L:0x5238, #0x4
    400              }
    401          }
   \                     ??UART1_SmartCardNACKCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    402          
    403          /**
    404            * @brief  Selects the UART1 WakeUp method.
    405            * @param  UART1_WakeUp: specifies the UART1 wakeup method.
    406            *         This parameter can be any of the @ref UART1_WakeUp_TypeDef values.
    407            * @retval None
    408            */

   \                                 In section .far_func.text, align 1
    409          void UART1_WakeUpConfig(UART1_WakeUp_TypeDef UART1_WakeUp)
    410          {
   \                     UART1_WakeUpConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    411              assert_param(IS_UART1_WAKEUP_OK(UART1_WakeUp));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??UART1_WakeUpConfig_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A108                  CP        A, #0x8
   \   00000D 270F                  JREQ      L:??UART1_WakeUpConfig_0
   \   00000F AE019B                LDW       X, #0x19b
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    412          
    413              UART1->CR1 &= ((uint8_t)~UART1_CR1_WAKE);
   \                     ??UART1_WakeUpConfig_0:
   \   00001E 72175234              BRES      L:0x5234, #0x3
    414              UART1->CR1 |= (uint8_t)UART1_WakeUp;
   \   000022 B600                  LD        A, S:?b8
   \   000024 CA5234                OR        A, L:0x5234
   \   000027 C75234                LD        L:0x5234, A
    415          }
   \   00002A 320000                POP       S:?b8
   \   00002D 87                    RETF
    416          /**
    417            * @brief  Determines if the UART1 is in mute mode or not.
    418            * @param  NewState: new state of the UART1 mode.
    419            *         This parameter can be: ENABLE or DISABLE.
    420            * @retval None
    421            */

   \                                 In section .far_func.text, align 1
    422          void UART1_ReceiverWakeUpCmd(FunctionalState NewState)
    423          {
   \                     UART1_ReceiverWakeUpCmd:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    424              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D00                  TNZ       S:?b8
   \   000007 2715                  JREQ      L:??UART1_ReceiverWakeUpCmd_0
   \   000009 B600                  LD        A, S:?b8
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??UART1_ReceiverWakeUpCmd_0
   \   00000F AE01A8                LDW       X, #0x1a8
   \   000012 BF00                  LDW       S:?w1, X
   \   000014 5F                    CLRW      X
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001A 8D000000              CALLF     assert_failed
    425          
    426              if (NewState != DISABLE)
   \                     ??UART1_ReceiverWakeUpCmd_0:
   \   00001E 3D00                  TNZ       S:?b8
   \   000020 2706                  JREQ      L:??UART1_ReceiverWakeUpCmd_1
    427              {
    428                  /* Enable the mute mode UART1 by setting the RWU bit in the CR2 register */
    429                  UART1->CR2 |= UART1_CR2_RWU;
   \   000022 72125235              BSET      L:0x5235, #0x1
   \   000026 2004                  JRA       L:??UART1_ReceiverWakeUpCmd_2
    430              }
    431              else
    432              {
    433                  /* Disable the mute mode UART1 by clearing the RWU bit in the CR1 register */
    434                  UART1->CR2 &= ((uint8_t)~UART1_CR2_RWU);
   \                     ??UART1_ReceiverWakeUpCmd_1:
   \   000028 72135235              BRES      L:0x5235, #0x1
    435              }
    436          }
   \                     ??UART1_ReceiverWakeUpCmd_2:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    437          
    438          /**
    439            * @brief  Returns the most recent received data by the UART1 peripheral.
    440            * @param  None
    441            * @retval The received data.
    442            */

   \                                 In section .far_func.text, align 1
    443          uint8_t UART1_ReceiveData8(void)
    444          {
    445              return ((uint8_t)UART1->DR);
   \                     UART1_ReceiveData8:
   \   000000 C65231                LD        A, L:0x5231
   \   000003 87                    RETF
    446          }
    447          
    448          /**
    449            * @brief  Returns the most recent received data by the UART1 peripheral.
    450            * @param  None
    451            * @retval The received data.
    452            */

   \                                 In section .far_func.text, align 1
    453          uint16_t UART1_ReceiveData9(void)
    454          {
    455            uint16_t temp = 0;
   \                     UART1_ReceiveData9:
   \   000000 3F00                  CLR       S:?b1
   \   000002 3F00                  CLR       S:?b0
    456            
    457            temp = (uint16_t)(((uint16_t)( (uint16_t)UART1->CR1 & (uint16_t)UART1_CR1_R8)) << 1);
   \   000004 C65234                LD        A, L:0x5234
   \   000007 5F                    CLRW      X
   \   000008 97                    LD        XL, A
   \   000009 02                    RLWA      X, A
   \   00000A A400                  AND       A, #0x0
   \   00000C 02                    RLWA      X, A
   \   00000D A480                  AND       A, #0x80
   \   00000F 02                    RLWA      X, A
   \   000010 58                    SLLW      X
   \   000011 BF00                  LDW       S:?w0, X
    458            return (uint16_t)( (((uint16_t) UART1->DR) | temp ) & ((uint16_t)0x01FF));
   \   000013 C65231                LD        A, L:0x5231
   \   000016 5F                    CLRW      X
   \   000017 97                    LD        XL, A
   \   000018 01                    RRWA      X, A
   \   000019 BA00                  OR        A, S:?b1
   \   00001B 01                    RRWA      X, A
   \   00001C BA00                  OR        A, S:?b0
   \   00001E 01                    RRWA      X, A
   \   00001F 02                    RLWA      X, A
   \   000020 A401                  AND       A, #0x1
   \   000022 02                    RLWA      X, A
   \   000023 A4FF                  AND       A, #0xff
   \   000025 02                    RLWA      X, A
   \   000026 87                    RETF
    459          }
    460          
    461          /**
    462            * @brief  Transmits 8 bit data through the UART1 peripheral.
    463            * @param  Data: The data to transmit.
    464            * @retval None
    465            */

   \                                 In section .far_func.text, align 1
    466          void UART1_SendData8(uint8_t Data)
    467          {
    468              /* Transmit Data */
    469              UART1->DR = Data;
   \                     UART1_SendData8:
   \   000000 C75231                LD        L:0x5231, A
    470          }
   \   000003 87                    RETF
    471          
    472          /**
    473            * @brief  Transmits 9 bit data through the UART peripheral.
    474            * @param  Data : The data to transmit.
    475            *         This parameter should be lower than 0x1FF.
    476            * @retval None
    477            */

   \                                 In section .far_func.text, align 1
    478          void UART1_SendData9(uint16_t Data)
    479          {
   \                     UART1_SendData9:
   \   000000 9093                  LDW       Y, X
    480              /**< Clear the transmit data bit 8 [8]  */
    481              UART1->CR1 &= ((uint8_t)~UART1_CR1_T8);
   \   000002 721D5234              BRES      L:0x5234, #0x6
    482              /**< Write the transmit data bit [8]  */
    483              UART1->CR1 |= (uint8_t)(((uint8_t)(Data >> 2)) & UART1_CR1_T8);
   \   000006 93                    LDW       X, Y
   \   000007 54                    SRLW      X
   \   000008 54                    SRLW      X
   \   000009 9F                    LD        A, XL
   \   00000A A440                  AND       A, #0x40
   \   00000C CA5234                OR        A, L:0x5234
   \   00000F C75234                LD        L:0x5234, A
    484              /**< Write the transmit data bit [0:7] */
    485              UART1->DR   = (uint8_t)(Data);
   \   000012 909F                  LD        A, YL
   \   000014 C75231                LD        L:0x5231, A
    486          }
   \   000017 87                    RETF
    487          
    488          /**
    489            * @brief  Transmits break characters.
    490            * @param  None
    491            * @retval None
    492            */

   \                                 In section .far_func.text, align 1
    493          void UART1_SendBreak(void)
    494          {
    495              UART1->CR2 |= UART1_CR2_SBK;
   \                     UART1_SendBreak:
   \   000000 72105235              BSET      L:0x5235, #0x0
    496          }
   \   000004 87                    RETF
    497          
    498          /**
    499            * @brief  Sets the address of the UART1 node.
    500            * @param  UART1_Address: Indicates the address of the UART1 node.
    501            * @retval None
    502            */

   \                                 In section .far_func.text, align 1
    503          void UART1_SetAddress(uint8_t UART1_Address)
    504          {
   \                     UART1_SetAddress:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    505              /*assert_param for UART1_Address*/
    506              assert_param(IS_UART1_ADDRESS_OK(UART1_Address));
   \   000005 B600                  LD        A, S:?b8
   \   000007 A110                  CP        A, #0x10
   \   000009 250F                  JRC       L:??UART1_SetAddress_0
   \   00000B AE01FA                LDW       X, #0x1fa
   \   00000E BF00                  LDW       S:?w1, X
   \   000010 5F                    CLRW      X
   \   000011 BF00                  LDW       S:?w0, X
   \   000013 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000016 8D000000              CALLF     assert_failed
    507          
    508              /* Clear the UART1 address */
    509              UART1->CR4 &= ((uint8_t)~UART1_CR4_ADD);
   \                     ??UART1_SetAddress_0:
   \   00001A C65237                LD        A, L:0x5237
   \   00001D A4F0                  AND       A, #0xf0
   \   00001F C75237                LD        L:0x5237, A
    510              /* Set the UART1 address node */
    511              UART1->CR4 |= UART1_Address;
   \   000022 B600                  LD        A, S:?b8
   \   000024 CA5237                OR        A, L:0x5237
   \   000027 C75237                LD        L:0x5237, A
    512          }
   \   00002A 320000                POP       S:?b8
   \   00002D 87                    RETF
    513          
    514          /**
    515            * @brief  Sets the specified UART guard time.
    516            * @note   SmartCard Mode should be Enabled
    517            * @param  UART1_GuardTime: specifies the guard time.
    518            * @retval None
    519            */

   \                                 In section .far_func.text, align 1
    520          void UART1_SetGuardTime(uint8_t UART1_GuardTime)
    521          {
    522              /* Set the UART1 guard time */
    523              UART1->GTR = UART1_GuardTime;
   \                     UART1_SetGuardTime:
   \   000000 C75239                LD        L:0x5239, A
    524          }
   \   000003 87                    RETF
    525          
    526          /**
    527            * @brief  Sets the system clock prescaler.
    528            * @note   IrDA Low Power mode or smartcard mode should be enabled
    529            * @note   This function is related to SmartCard and IrDa mode.
    530            * @param  UART1_Prescaler: specifies the prescaler clock.
    531            *         This parameter can be one of the following values:
    532            *         @par IrDA Low Power Mode
    533            *         The clock source is divided by the value given in the register (8 bits)
    534            *         - 0000 0000 Reserved
    535            *         - 0000 0001 divides the clock source by 1
    536            *         - 0000 0010 divides the clock source by 2
    537            *         - ...........................................................
    538            *        @par Smart Card Mode
    539            *        The clock source is divided by the value given in the register
    540            *        (5 significant bits) multiplied by 2
    541            *         - 0 0000 Reserved
    542            *         - 0 0001 divides the clock source by 2
    543            *         - 0 0010 divides the clock source by 4
    544            *         - 0 0011 divides the clock source by 6
    545            *         - ...........................................................
    546            * @retval None
    547            */

   \                                 In section .far_func.text, align 1
    548          void UART1_SetPrescaler(uint8_t UART1_Prescaler)
    549          {
    550              /* Load the UART1 prescaler value*/
    551              UART1->PSCR = UART1_Prescaler;
   \                     UART1_SetPrescaler:
   \   000000 C7523A                LD        L:0x523a, A
    552          }
   \   000003 87                    RETF
    553          
    554          /**
    555            * @brief  Checks whether the specified UART1 flag is set or not.
    556            * @param  UART1_FLAG specifies the flag to check.
    557            *         This parameter can be any of the @ref UART1_Flag_TypeDef enumeration.
    558            * @retval FlagStatus (SET or RESET)
    559            */

   \                                 In section .far_func.text, align 1
    560          FlagStatus UART1_GetFlagStatus(UART1_Flag_TypeDef UART1_FLAG)
    561          {
   \                     UART1_GetFlagStatus:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    562              FlagStatus status = RESET;
   \   000006 4F                    CLR       A
    563          
    564              /* Check parameters */
    565              assert_param(IS_UART1_FLAG_OK(UART1_FLAG));
   \   000007 BE00                  LDW       X, S:?w4
   \   000009 A30080                CPW       X, #0x80
   \   00000C 274E                  JREQ      L:??UART1_GetFlagStatus_0
   \   00000E BE00                  LDW       X, S:?w4
   \   000010 A30040                CPW       X, #0x40
   \   000013 2747                  JREQ      L:??UART1_GetFlagStatus_0
   \   000015 BE00                  LDW       X, S:?w4
   \   000017 A30020                CPW       X, #0x20
   \   00001A 2740                  JREQ      L:??UART1_GetFlagStatus_0
   \   00001C BE00                  LDW       X, S:?w4
   \   00001E A30010                CPW       X, #0x10
   \   000021 2739                  JREQ      L:??UART1_GetFlagStatus_0
   \   000023 BE00                  LDW       X, S:?w4
   \   000025 A30008                CPW       X, #0x8
   \   000028 2732                  JREQ      L:??UART1_GetFlagStatus_0
   \   00002A BE00                  LDW       X, S:?w4
   \   00002C A30004                CPW       X, #0x4
   \   00002F 272B                  JREQ      L:??UART1_GetFlagStatus_0
   \   000031 BE00                  LDW       X, S:?w4
   \   000033 A30002                CPW       X, #0x2
   \   000036 2724                  JREQ      L:??UART1_GetFlagStatus_0
   \   000038 BE00                  LDW       X, S:?w4
   \   00003A A30001                CPW       X, #0x1
   \   00003D 271D                  JREQ      L:??UART1_GetFlagStatus_0
   \   00003F BE00                  LDW       X, S:?w4
   \   000041 A30101                CPW       X, #0x101
   \   000044 2716                  JREQ      L:??UART1_GetFlagStatus_0
   \   000046 BE00                  LDW       X, S:?w4
   \   000048 A30210                CPW       X, #0x210
   \   00004B 270F                  JREQ      L:??UART1_GetFlagStatus_0
   \   00004D AE0235                LDW       X, #0x235
   \   000050 BF00                  LDW       S:?w1, X
   \   000052 5F                    CLRW      X
   \   000053 BF00                  LDW       S:?w0, X
   \   000055 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   000058 8D000000              CALLF     assert_failed
    566          
    567          
    568              /* Check the status of the specified UART1 flag*/
    569              if (UART1_FLAG == UART1_FLAG_LBDF)
   \                     ??UART1_GetFlagStatus_0:
   \   00005C BE00                  LDW       X, S:?w4
   \   00005E A30210                CPW       X, #0x210
   \   000061 2614                  JRNE      L:??UART1_GetFlagStatus_1
    570              {
    571                  if ((UART1->CR4 & (uint8_t)UART1_FLAG) != (uint8_t)0x00)
   \   000063 B600                  LD        A, S:?b9
   \   000065 C45237                AND       A, L:0x5237
   \   000068 A100                  CP        A, #0x0
   \   00006A 2706                  JREQ      L:??UART1_GetFlagStatus_2
    572                  {
    573                      /* UART1_FLAG is set*/
    574                      status = SET;
   \   00006C A601                  LD        A, #0x1
   \   00006E AC000000              JPF       L:?epilogue_w4
    575                  }
    576                  else
    577                  {
    578                      /* UART1_FLAG is reset*/
    579                      status = RESET;
   \                     ??UART1_GetFlagStatus_2:
   \   000072 4F                    CLR       A
   \   000073 AC000000              JPF       L:?epilogue_w4
    580                  }
    581              }
    582              else if (UART1_FLAG == UART1_FLAG_SBK)
   \                     ??UART1_GetFlagStatus_1:
   \   000077 BE00                  LDW       X, S:?w4
   \   000079 A30101                CPW       X, #0x101
   \   00007C 2614                  JRNE      L:??UART1_GetFlagStatus_3
    583              {
    584                  if ((UART1->CR2 & (uint8_t)UART1_FLAG) != (uint8_t)0x00)
   \   00007E B600                  LD        A, S:?b9
   \   000080 C45235                AND       A, L:0x5235
   \   000083 A100                  CP        A, #0x0
   \   000085 2706                  JREQ      L:??UART1_GetFlagStatus_4
    585                  {
    586                      /* UART1_FLAG is set*/
    587                      status = SET;
   \   000087 A601                  LD        A, #0x1
   \   000089 AC000000              JPF       L:?epilogue_w4
    588                  }
    589                  else
    590                  {
    591                      /* UART1_FLAG is reset*/
    592                      status = RESET;
   \                     ??UART1_GetFlagStatus_4:
   \   00008D 4F                    CLR       A
   \   00008E AC000000              JPF       L:?epilogue_w4
    593                  }
    594              }
    595              else
    596              {
    597                  if ((UART1->SR & (uint8_t)UART1_FLAG) != (uint8_t)0x00)
   \                     ??UART1_GetFlagStatus_3:
   \   000092 B600                  LD        A, S:?b9
   \   000094 C45230                AND       A, L:0x5230
   \   000097 A100                  CP        A, #0x0
   \   000099 2706                  JREQ      L:??UART1_GetFlagStatus_5
    598                  {
    599                      /* UART1_FLAG is set*/
    600                      status = SET;
   \   00009B A601                  LD        A, #0x1
   \   00009D AC000000              JPF       L:?epilogue_w4
    601                  }
    602                  else
    603                  {
    604                      /* UART1_FLAG is reset*/
    605                      status = RESET;
   \                     ??UART1_GetFlagStatus_5:
   \   0000A1 4F                    CLR       A
    606                  }
    607              }
    608              /* Return the UART1_FLAG status*/
    609              return status;
   \   0000A2 AC000000              JPF       L:?epilogue_w4
    610          }
    611          
    612          /**
    613            * @brief  Clears the UART1 flags.
    614            * @param  UART1_FLAG specifies the flag to clear
    615            *         This parameter can be any combination of the following values:
    616            *         - UART1_FLAG_LBDF: LIN Break detection flag.
    617            *         - UART1_FLAG_RXNE: Receive data register not empty flag.
    618            * @note
    619            *         - PE (Parity error), FE (Framing error), NE (Noise error), 
    620            *         OR (OverRun error) and IDLE (Idle line detected) flags are 
    621            *         cleared by software sequence: a read operation to UART1_SR register
    622            *         (UART1_GetFlagStatus())followed by a read operation to UART1_DR 
    623            *         register(UART1_ReceiveData8() or UART1_ReceiveData9()).
    624            *           
    625            *         - RXNE flag can be also cleared by a read to the UART1_DR register
    626            *         (UART1_ReceiveData8()or UART1_ReceiveData9()).
    627            *           
    628            *         - TC flag can be also cleared by software sequence: a read operation
    629            *         to UART1_SR register (UART1_GetFlagStatus()) followed by a write 
    630            *         operation to UART1_DR register (UART1_SendData8() or UART1_SendData9()).
    631            *           
    632            *         - TXE flag is cleared only by a write to the UART1_DR register 
    633            *         (UART1_SendData8() or UART1_SendData9()).
    634            *           
    635            *         - SBK flag is cleared during the stop bit of break.
    636            * @retval None
    637            */
    638          

   \                                 In section .far_func.text, align 1
    639          void UART1_ClearFlag(UART1_Flag_TypeDef UART1_FLAG)
    640          {
   \                     UART1_ClearFlag:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    641              assert_param(IS_UART1_CLEAR_FLAG_OK(UART1_FLAG));
   \   000006 BE00                  LDW       X, S:?w4
   \   000008 A30020                CPW       X, #0x20
   \   00000B 2716                  JREQ      L:??UART1_ClearFlag_0
   \   00000D BE00                  LDW       X, S:?w4
   \   00000F A30210                CPW       X, #0x210
   \   000012 270F                  JREQ      L:??UART1_ClearFlag_0
   \   000014 AE0281                LDW       X, #0x281
   \   000017 BF00                  LDW       S:?w1, X
   \   000019 5F                    CLRW      X
   \   00001A BF00                  LDW       S:?w0, X
   \   00001C AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001F 8D000000              CALLF     assert_failed
    642          
    643              /* Clear the Receive Register Not Empty flag */
    644              if (UART1_FLAG == UART1_FLAG_RXNE)
   \                     ??UART1_ClearFlag_0:
   \   000023 BE00                  LDW       X, S:?w4
   \   000025 A30020                CPW       X, #0x20
   \   000028 2608                  JRNE      L:??UART1_ClearFlag_1
    645              {
    646                  UART1->SR = (uint8_t)~(UART1_SR_RXNE);
   \   00002A 35DF5230              MOV       L:0x5230, #0xdf
   \   00002E AC000000              JPF       L:?epilogue_w4
    647              }
    648              /* Clear the LIN Break Detection flag */
    649              else
    650              {
    651                  UART1->CR4 &= (uint8_t)~(UART1_CR4_LBDF);
   \                     ??UART1_ClearFlag_1:
   \   000032 72195237              BRES      L:0x5237, #0x4
    652              }
    653          }
   \   000036 AC000000              JPF       L:?epilogue_w4
    654          
    655          /**
    656            * @brief  Checks whether the specified UART1 interrupt has occurred or not.
    657            * @param  UART1_IT: Specifies the UART1 interrupt pending bit to check.
    658            *         This parameter can be one of the following values:
    659            *         - UART1_IT_LBDF:  LIN Break detection interrupt
    660            *         - UART1_IT_TXE:  Tansmit Data Register empty interrupt
    661            *         - UART1_IT_TC:   Transmission complete interrupt
    662            *         - UART1_IT_RXNE: Receive Data register not empty interrupt
    663            *         - UART1_IT_IDLE: Idle line detection interrupt
    664            *         - UART1_IT_OR:  OverRun Error interrupt
    665            *         - UART1_IT_PE:   Parity Error interrupt
    666            * @retval The new state of UART1_IT (SET or RESET).
    667            */

   \                                 In section .far_func.text, align 1
    668          ITStatus UART1_GetITStatus(UART1_IT_TypeDef UART1_IT)
    669          {
   \                     UART1_GetITStatus:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    670              ITStatus pendingbitstatus = RESET;
   \   000006 3F00                  CLR       S:?b0
    671              uint8_t itpos = 0;
   \   000008 3F00                  CLR       S:?b1
    672              uint8_t itmask1 = 0;
   \   00000A 3F00                  CLR       S:?b2
    673              uint8_t itmask2 = 0;
   \   00000C 4F                    CLR       A
    674              uint8_t enablestatus = 0;
   \   00000D 3F00                  CLR       S:?b3
    675          
    676              /* Check parameters */
    677              assert_param(IS_UART1_GET_IT_OK(UART1_IT));
   \   00000F BE00                  LDW       X, S:?w4
   \   000011 A30277                CPW       X, #0x277
   \   000014 2739                  JREQ      L:??UART1_GetITStatus_0
   \   000016 BE00                  LDW       X, S:?w4
   \   000018 A30266                CPW       X, #0x266
   \   00001B 2732                  JREQ      L:??UART1_GetITStatus_0
   \   00001D BE00                  LDW       X, S:?w4
   \   00001F A30255                CPW       X, #0x255
   \   000022 272B                  JREQ      L:??UART1_GetITStatus_0
   \   000024 BE00                  LDW       X, S:?w4
   \   000026 A30244                CPW       X, #0x244
   \   000029 2724                  JREQ      L:??UART1_GetITStatus_0
   \   00002B BE00                  LDW       X, S:?w4
   \   00002D A30235                CPW       X, #0x235
   \   000030 271D                  JREQ      L:??UART1_GetITStatus_0
   \   000032 BE00                  LDW       X, S:?w4
   \   000034 A30346                CPW       X, #0x346
   \   000037 2716                  JREQ      L:??UART1_GetITStatus_0
   \   000039 BE00                  LDW       X, S:?w4
   \   00003B A30100                CPW       X, #0x100
   \   00003E 270F                  JREQ      L:??UART1_GetITStatus_0
   \   000040 AE02A5                LDW       X, #0x2a5
   \   000043 BF00                  LDW       S:?w1, X
   \   000045 5F                    CLRW      X
   \   000046 BF00                  LDW       S:?w0, X
   \   000048 AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00004B 8D000000              CALLF     assert_failed
    678          
    679              /* Get the UART1 IT index */
    680              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART1_IT & (uint8_t)0x0F));
   \                     ??UART1_GetITStatus_0:
   \   00004F B600                  LD        A, S:?b9
   \   000051 A40F                  AND       A, #0xf
   \   000053 5F                    CLRW      X
   \   000054 5C                    INCW      X
   \   000055 8D000000              CALLF     L:?sll16_x_x_a
   \   000059 41                    EXG       A, XL
   \   00005A B700                  LD        S:?b1, A
   \   00005C 41                    EXG       A, XL
    681              /* Get the UART1 IT index */
    682              itmask1 = (uint8_t)((uint8_t)UART1_IT >> (uint8_t)4);
   \   00005D B600                  LD        A, S:?b9
   \   00005F 4E                    SWAP      A
   \   000060 A40F                  AND       A, #0xf
   \   000062 B700                  LD        S:?b2, A
    683              /* Set the IT mask*/
    684              itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \   000064 5F                    CLRW      X
   \   000065 5C                    INCW      X
   \   000066 B600                  LD        A, S:?b2
   \   000068 8D000000              CALLF     L:?sll16_x_x_a
   \   00006C 9F                    LD        A, XL
    685          
    686          
    687              /* Check the status of the specified UART1 pending bit*/
    688              if (UART1_IT == UART1_IT_PE)
   \   00006D BE00                  LDW       X, S:?w4
   \   00006F A30100                CPW       X, #0x100
   \   000072 261C                  JRNE      L:??UART1_GetITStatus_1
    689              {
    690                  /* Get the UART1_IT enable bit status*/
    691                  enablestatus = (uint8_t)((uint8_t)UART1->CR1 & itmask2);
   \   000074 C45234                AND       A, L:0x5234
   \   000077 B700                  LD        S:?b3, A
    692                  /* Check the status of the specified UART1 interrupt*/
    693          
    694                  if (((UART1->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   000079 B600                  LD        A, S:?b1
   \   00007B C45230                AND       A, L:0x5230
   \   00007E A100                  CP        A, #0x0
   \   000080 270A                  JREQ      L:??UART1_GetITStatus_2
   \   000082 3D00                  TNZ       S:?b3
   \   000084 2706                  JREQ      L:??UART1_GetITStatus_2
    695                  {
    696                      /* Interrupt occurred*/
    697                      pendingbitstatus = SET;
   \   000086 35010000              MOV       S:?b0, #0x1
   \   00008A 2041                  JRA       L:??UART1_GetITStatus_3
    698                  }
    699                  else
    700                  {
    701                      /* Interrupt not occurred*/
    702                      pendingbitstatus = RESET;
   \                     ??UART1_GetITStatus_2:
   \   00008C 3F00                  CLR       S:?b0
   \   00008E 203D                  JRA       L:??UART1_GetITStatus_3
    703                  }
    704              }
    705          
    706              else if (UART1_IT == UART1_IT_LBDF)
   \                     ??UART1_GetITStatus_1:
   \   000090 BE00                  LDW       X, S:?w4
   \   000092 A30346                CPW       X, #0x346
   \   000095 261C                  JRNE      L:??UART1_GetITStatus_4
    707              {
    708                  /* Get the UART1_IT enable bit status*/
    709                  enablestatus = (uint8_t)((uint8_t)UART1->CR4 & itmask2);
   \   000097 C45237                AND       A, L:0x5237
   \   00009A B700                  LD        S:?b3, A
    710                  /* Check the status of the specified UART1 interrupt*/
    711                  if (((UART1->CR4 & itpos) != (uint8_t)0x00) && enablestatus)
   \   00009C B600                  LD        A, S:?b1
   \   00009E C45237                AND       A, L:0x5237
   \   0000A1 A100                  CP        A, #0x0
   \   0000A3 270A                  JREQ      L:??UART1_GetITStatus_5
   \   0000A5 3D00                  TNZ       S:?b3
   \   0000A7 2706                  JREQ      L:??UART1_GetITStatus_5
    712                  {
    713                      /* Interrupt occurred*/
    714                      pendingbitstatus = SET;
   \   0000A9 35010000              MOV       S:?b0, #0x1
   \   0000AD 201E                  JRA       L:??UART1_GetITStatus_3
    715                  }
    716                  else
    717                  {
    718                      /* Interrupt not occurred*/
    719                      pendingbitstatus = RESET;
   \                     ??UART1_GetITStatus_5:
   \   0000AF 3F00                  CLR       S:?b0
   \   0000B1 201A                  JRA       L:??UART1_GetITStatus_3
    720                  }
    721              }
    722              else
    723              {
    724                  /* Get the UART1_IT enable bit status*/
    725                  enablestatus = (uint8_t)((uint8_t)UART1->CR2 & itmask2);
   \                     ??UART1_GetITStatus_4:
   \   0000B3 C45235                AND       A, L:0x5235
   \   0000B6 B700                  LD        S:?b3, A
    726                  /* Check the status of the specified UART1 interrupt*/
    727                  if (((UART1->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   0000B8 B600                  LD        A, S:?b1
   \   0000BA C45230                AND       A, L:0x5230
   \   0000BD A100                  CP        A, #0x0
   \   0000BF 270A                  JREQ      L:??UART1_GetITStatus_6
   \   0000C1 3D00                  TNZ       S:?b3
   \   0000C3 2706                  JREQ      L:??UART1_GetITStatus_6
    728                  {
    729                      /* Interrupt occurred*/
    730                      pendingbitstatus = SET;
   \   0000C5 35010000              MOV       S:?b0, #0x1
   \   0000C9 2002                  JRA       L:??UART1_GetITStatus_3
    731                  }
    732                  else
    733                  {
    734                      /* Interrupt not occurred*/
    735                      pendingbitstatus = RESET;
   \                     ??UART1_GetITStatus_6:
   \   0000CB 3F00                  CLR       S:?b0
    736                  }
    737              }
    738          
    739              /* Return the UART1_IT status*/
    740              return  pendingbitstatus;
   \                     ??UART1_GetITStatus_3:
   \   0000CD B600                  LD        A, S:?b0
   \   0000CF AC000000              JPF       L:?epilogue_w4
    741          }
    742          
    743          /**
    744            * @brief  Clears the UART1 pending flags.
    745            * @param  UART1_IT specifies the pending bit to clear
    746            *         This parameter can be one of the following values:
    747            *         - UART1_IT_LBDF:  LIN Break detection interrupt
    748            *         - UART1_IT_RXNE: Receive Data register not empty interrupt.
    749            * @note
    750            *         - PE (Parity error), FE (Framing error), NE (Noise error), 
    751            *           OR (OverRun error) and IDLE (Idle line detected) pending bits are 
    752            *           cleared by software sequence: a read operation to UART1_SR register
    753            *           (UART1_GetITStatus()) followed by a read operation to UART1_DR register
    754            *           (UART1_ReceiveData8() or UART1_ReceiveData9()).
    755            *   
    756            *         - RXNE pending bit can be also cleared by a read to the UART1_DR register
    757            *           (UART1_ReceiveData8() or UART1_ReceiveData9()).
    758            * 
    759            *         - TC (Transmit complete) pending bit can be cleared by software 
    760            *           sequence: a read operation to UART1_SR register (UART1_GetITStatus())
    761            *           followed by a write operation to UART1_DR register (UART1_SendData8()
    762            *           or UART1_SendData9()).
    763            *             
    764            *         - TXE pending bit is cleared only by a write to the UART1_DR register
    765            *           (UART1_SendData8() or UART1_SendData9()).
    766            * @retval None
    767            */

   \                                 In section .far_func.text, align 1
    768          void UART1_ClearITPendingBit(UART1_IT_TypeDef UART1_IT)
    769          {
   \                     UART1_ClearITPendingBit:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    770              assert_param(IS_UART1_CLEAR_IT_OK(UART1_IT));
   \   000006 BE00                  LDW       X, S:?w4
   \   000008 A30255                CPW       X, #0x255
   \   00000B 2716                  JREQ      L:??UART1_ClearITPendingBit_0
   \   00000D BE00                  LDW       X, S:?w4
   \   00000F A30346                CPW       X, #0x346
   \   000012 270F                  JREQ      L:??UART1_ClearITPendingBit_0
   \   000014 AE0302                LDW       X, #0x302
   \   000017 BF00                  LDW       S:?w1, X
   \   000019 5F                    CLRW      X
   \   00001A BF00                  LDW       S:?w0, X
   \   00001C AE0000                LDW       X, #`?<Constant "D:\\\\Project\\\\STM8S_StdP...">`
   \   00001F 8D000000              CALLF     assert_failed
    771          
    772              /* Clear the Receive Register Not Empty pending bit */
    773              if (UART1_IT == UART1_IT_RXNE)
   \                     ??UART1_ClearITPendingBit_0:
   \   000023 BE00                  LDW       X, S:?w4
   \   000025 A30255                CPW       X, #0x255
   \   000028 2608                  JRNE      L:??UART1_ClearITPendingBit_1
    774              {
    775                  UART1->SR = (uint8_t)~(UART1_SR_RXNE);
   \   00002A 35DF5230              MOV       L:0x5230, #0xdf
   \   00002E AC000000              JPF       L:?epilogue_w4
    776              }
    777              /* Clear the LIN Break Detection pending bit */
    778              else
    779              {
    780                  UART1->CR4 &= (uint8_t)~(UART1_CR4_LBDF);
   \                     ??UART1_ClearITPendingBit_1:
   \   000032 72195237              BRES      L:0x5237, #0x4
    781              }
    782          }
   \   000036 AC000000              JPF       L:?epilogue_w4

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "D:\\\\Project\\\\STM8S_StdP...">`:
   \   000000 443A5C50726F          DC8 44H, 3AH, 5CH, 50H, 72H, 6FH, 6AH, 65H
   \   000008 63745C53544D          DC8 63H, 74H, 5CH, 53H, 54H, 4DH, 38H, 53H
   \   000010 5F5374645065          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \   000018 70685F4C6962          DC8 70H, 68H, 5FH, 4CH, 69H, 62H, 5FH, 56H
   \   000020 322E312E305C          DC8 32H, 2EH, 31H, 2EH, 30H, 5CH, 4CH, 69H
   \   000028 627261726965          DC8 62H, 72H, 61H, 72H, 69H, 65H, 73H, 5CH
   \   000030 53544D38535F          DC8 53H, 54H, 4DH, 38H, 53H, 5FH, 53H, 74H
   \   000038 645065726970          DC8 64H, 50H, 65H, 72H, 69H, 70H, 68H, 5FH
   \   000040 447269766572          DC8 44H, 72H, 69H, 76H, 65H, 72H, 5CH, 73H
   \   000048 72635C73746D          DC8 72H, 63H, 5CH, 73H, 74H, 6DH, 38H, 73H
   \   000050 5F7561727431          DC8 5FH, 75H, 61H, 72H, 74H, 31H, 2EH, 63H
   \   000058 00                    DC8 0
    783          
    784          /**
    785            * @}
    786            */
    787            
    788          /**
    789            * @}
    790            */
    791            
    792          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     UART1_DeInit                               45
     UART1_Init                                593
     UART1_Cmd                                  13
     UART1_ITConfig                            218
     UART1_HalfDuplexCmd                        48
     UART1_IrDAConfig                           48
     UART1_IrDACmd                              48
     UART1_LINBreakDetectionConfig              48
     UART1_LINCmd                               48
     UART1_SmartCardCmd                         48
     UART1_SmartCardNACKCmd                     48
     UART1_WakeUpConfig                         46
     UART1_ReceiverWakeUpCmd                    48
     UART1_ReceiveData8                          4
     UART1_ReceiveData9                         39
     UART1_SendData8                             4
     UART1_SendData9                            24
     UART1_SendBreak                             5
     UART1_SetAddress                           46
     UART1_SetGuardTime                          4
     UART1_SetPrescaler                          4
     UART1_GetFlagStatus                       166
     UART1_ClearFlag                            58
     UART1_GetITStatus                         211
     UART1_ClearITPendingBit                    58
     ?<Constant "D:\\Project\\STM8S_StdP...">   89

 
 1 922 bytes in section .far_func.text
    89 bytes in section .near.rodata
 
 1 922 bytes of CODE  memory
    89 bytes of CONST memory

Errors: none
Warnings: none
